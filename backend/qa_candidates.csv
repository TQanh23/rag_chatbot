document_id,chunk_id,page,text
1e8e6c622bfb571b0b783d8347182318,1e8e6c622bfb571b0b783d8347182318:105,106,65/ 96 Chuyển đổi địa chỉ: Sơ đồ truy nhập Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.4 Chiến lược phân trang
1e8e6c622bfb571b0b783d8347182318,1e8e6c622bfb571b0b783d8347182318:104,105,"Thực hiện chương trình →Truy nhập bộ nhớ Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.4 Chiến lược phân trang l Nạp chương trình l Xây dựng bảng quản lý trang và luôn giữ trong bộ nhớ l PTBR (Page-table base register) trỏ tới PCB. l PTLR(Page-table length register) kích thước PCB. l Thực hiện truy nhập l Địa chỉ truy nhập được chia thành dạng <p, d> l PTBR + p ∗K : Địa chỉ phần tử p của PCB trong bộ nhớ l K Kích thước 1 phần tử của PCB l Kiểm tra Mp l Mp = 0 : Lỗi trang, sinh một ngắt để tiến hành nạp trang l Xin trang vật lý tự do (Hết trang tự do?) l Tìm kiếm trang logic ở bộ nhớ ngoài và nạp trang l Sửa lại trường địa chỉ A và dấu hiệu M l Mp = 1 : Trang đã tồn tại, l Lấy Ap ghép với d ra địa chỉ cần tìm"
1e8e6c622bfb571b0b783d8347182318,1e8e6c622bfb571b0b783d8347182318:12,13,"l Bộ nhớ là tài nguyên quan trọng của hệ thống l Chương trình phải nằm trong bộ nhớ trong để thực hiện l Bộ nhớ được đặc trưng bởi kích thước và tốc độ truy nhập l Bộ nhớ được phân cấp theo tốc độ truy nhập Loại bộ nhớ Kích thước Tốc độ Thanh ghi (Registers) Cache trên VXL Cache mức 2 Bộnhớ chính Bộ nhớ lưu trữ (Disk) Băng từ, đĩa quang bytes Kilo Bytes KiloByte-MegaByte MegaByte-GigaByte GigaByte-Terabytes Không giới hạn Tốc độ CPU(ηs) 10 nano seconds 100 nanoseconds e Micro-seconds Mili-Seconds 10 Seconds Chương 3: Quản lý bộ nhớ 1. Tổng quan 1.2 Bộ nhớ và chương trình Phân cấp bộ nhớ"
1e8e6c622bfb571b0b783d8347182318,1e8e6c622bfb571b0b783d8347182318:26,27,"M0 M1 M2 M3 Hệ điều hành M0 l Mỗi modul được biên tập riêng l Khi thực hiện, hệ thống sẽ định vị modul gốc Chương 3: Quản lý bộ nhớ 1. Tổng quan 1.4 Các cấu trúc chương trình Cấu trúc nạp động"
1e8e6c622bfb571b0b783d8347182318,1e8e6c622bfb571b0b783d8347182318:123,124,"Nạp từng phần của trang chương trình vào bộ nhớ Chương 3: Quản lý bộ nhớ 3. Bộ nhớ ảo 3.1 Giới thiệu l Trang của tiến trình: l bộ nhớ vật lý, l một số trang nằm trên đĩa(bộ nhớ ảo) l Biểu diễn nhờ sử dụng một bit trong bảng quản lý trang l Khi yêu cầu trang, đưa trang từ bộ nhớ thứ cấp -> bộ nhớ vật lý"
1e8e6c622bfb571b0b783d8347182318,1e8e6c622bfb571b0b783d8347182318:66,67,l Có thể kết hợp 2 vùng kề nhau có cùng kích thước l Tiếp tục kết hợp liên tiếp cho tới khi tạo ra vùng trống lớn nhất có thể Ví dụ l Giải phóng vùng nhớ thứ nhất (1K) l Kết hợp 2 vùng 1K thành vùng 2K l Giải phóng vùng nhớ thứ hai (2K) Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.2 Chiến lược phân chương động Buddy Allocation : Thu hồi vùng nhớ
1e8e6c622bfb571b0b783d8347182318,1e8e6c622bfb571b0b783d8347182318:64,65,l Có thể kết hợp 2 vùng kề nhau có cùng kích thước l Tiếp tục kết hợp liên tiếp cho tới khi tạo ra vùng trống lớn nhất có thể Ví dụ l Giải phóng vùng nhớ thứ nhất (1K) Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.2 Chiến lược phân chương động Buddy Allocation : Thu hồi vùng nhớ
1e8e6c622bfb571b0b783d8347182318,1e8e6c622bfb571b0b783d8347182318:115,116,lChiến lược phân chương cố định lChiến lược phân chương động lChiến lược phân đoạn lChiến lược phân trang lChiến lược kết hợp phân đoạn-phân trang Chương 3 Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ
1e8e6c622bfb571b0b783d8347182318,1e8e6c622bfb571b0b783d8347182318:133,134,①Tổng quan ②Các chiến lược quản lý bộ nhớ ③Bộ nhớ ảo ④Quản lý bộ nhớ trong VXL họ Intel Chương 3 Quản lý bộ nhớ
1e8e6c622bfb571b0b783d8347182318,1e8e6c622bfb571b0b783d8347182318:85,86,"subroutine Đoạn 2 array Đoạn 3 main program Đoạn 0 data Đoạn 4 stack Đoạn 1 Ví dụ Không gian địa chỉ logic Bộ nhớ HĐH Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.3 Chiến lược phân đoạn M A L 1 1400 1000 1 6300 400 0 - 400 1 3200 1100 1 4700 1000 SCB Đoạn 0 Đoạn 3 Đoạn 4 Đoạn 1 1400 2400 3200 4300 4700 5700 6300 6700 Địa chỉ <4,185> = ?4885"
1e8e6c622bfb571b0b783d8347182318,1e8e6c622bfb571b0b783d8347182318:84,85,"subroutine Đoạn 2 array Đoạn 3 main program Đoạn 0 data Đoạn 4 stack Đoạn 1 Ví dụ Không gian địa chỉ logic Bộ nhớ HĐH Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.3 Chiến lược phân đoạn M A L 1 1400 1000 1 6300 400 0 - 400 1 3200 1100 1 4700 1000 SCB Đoạn 0 Đoạn 3 Đoạn 4 Đoạn 1 1400 2400 3200 4300 4700 5700 6300 6700 Địa chỉ <3,345> = ? Đoạn 3 bắt đầu tại 3200 P/tử 345 Offset 345 3545"
1e8e6c622bfb571b0b783d8347182318,1e8e6c622bfb571b0b783d8347182318:45,46,lChiến lược phân chương cố định lChiến lược phân chương động lChiến lược phân đoạn lChiến lược phân trang lChiến lược kết hợp phân đoạn-phân trang Chương 3 Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ
1e8e6c622bfb571b0b783d8347182318,1e8e6c622bfb571b0b783d8347182318:69,70,l Có thể kết hợp 2 vùng kề nhau có cùng kích thước l Tiếp tục kết hợp liên tiếp cho tới khi tạo ra vùng trống lớn nhất có thể Ví dụ l Giải phóng vùng nhớ thứ nhất (1K) l Kết hợp 2 vùng 1K thành vùng 2K l Giải phóng vùng nhớ thứ hai (2K) l Kết hợp 2 vùng 2K thành vùng 4K l Giải phóng vùng nhớ thứ ba (2K) l Kết hợp 2 vùng 2K thành vùng 4K Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.2 Chiến lược phân chương động Buddy Allocation : Thu hồi vùng nhớ
1e8e6c622bfb571b0b783d8347182318,1e8e6c622bfb571b0b783d8347182318:67,68,l Có thể kết hợp 2 vùng kề nhau có cùng kích thước l Tiếp tục kết hợp liên tiếp cho tới khi tạo ra vùng trống lớn nhất có thể Ví dụ l Giải phóng vùng nhớ thứ nhất (1K) l Kết hợp 2 vùng 1K thành vùng 2K l Giải phóng vùng nhớ thứ hai (2K) l Kết hợp 2 vùng 2K thành vùng 4K Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.2 Chiến lược phân chương động Buddy Allocation : Thu hồi vùng nhớ
1e8e6c622bfb571b0b783d8347182318,1e8e6c622bfb571b0b783d8347182318:31,32,Ưu điểm l Có thể sử dụng vùng nhớ nhiều hơn phần dành cho chương trình l Hiệu quả sử dụng bộ nhớ cao nếu quản lý tốt Nhược điểm l Tốc độ thực hiện chậm l Sai lầm sẽ dẫn tới lãng phí bộ nhớ và tăng thời gian thực hiện l Yêu cầu người sử dụng phải nạp và xóa các modul l Người dùng phải nắm rõ hệ thống l Giảm tính lưu động 29/ 96 Chương 3: Quản lý bộ nhớ 1. Tổng quan 1.4 Các cấu trúc chương trình Cấu trúc nạp động
1e8e6c622bfb571b0b783d8347182318,1e8e6c622bfb571b0b783d8347182318:42,43,"l Cho phép dùng chương trình có kích thước lớn hơn kích thước hệ điều hành dành cho l Yêu cầu người sử dụng cung cấp các thông tin phụ l Hiệu quả sử dụng phụ thuộc vào các thông tin được cung cấp l Hiệu quả sử dụng bộ nhớ phụ thuộc cách tổ chức các modul trong chương trình l Nếu tồn tại một modul có kích thước lớn hơn các modul khác cùng mức rất nhiều ⇒Hiệu quả giảm rõ rệt l Quá trình nạp các modul là động, nhưng chương trình có tính chất tĩnh ⇒Không thay đổi trong các lần thực hiện l Cung cấp thêm bộ nhớ tự do, hiệu quả vẫn không đổi Chương 3: Quản lý bộ nhớ 1. Tổng quan 1.4 Các cấu trúc chương trình Cấu trúc Overlays:Nhận xét"
1e8e6c622bfb571b0b783d8347182318,1e8e6c622bfb571b0b783d8347182318:27,28,"M0 M1 M2 M3 Hệ điều hành M0 M1 l Mỗi modul được biên tập riêng l Khi thực hiện, hệ thống sẽ định vị modul gốc l Cần tới modul nào sẽ xin bộ nhớ và giải nạp modul vào Chương 3: Quản lý bộ nhớ 1. Tổng quan 1.4 Các cấu trúc chương trình Cấu trúc nạp động"
1e8e6c622bfb571b0b783d8347182318,1e8e6c622bfb571b0b783d8347182318:19,20,Xác định địa chỉ câu lệnh và dữ liệu trong bộ nhớ có thể thực hiện tại các giai đoạn khác nhau khi xử lý chương trình ứng dụng l Giai đoạn dịch: l Sử dụng khi biết chương trình sẽ nằm ở đâu trong bộ nhớ l Khi dịch sẽ sinh ra mã (địa chỉ) tuyệt đối l Phải dịch lại khi vị trí bắt đầu thay đổi l Thời điểm nạp: l Sử dụng khi không biết c/trình sẽ nằm ở đâu trong bộ nhớ l Các đối tượng được dịch ra sẽ mang địa chỉ tương đối l Xác định địa chỉ được hoãn lại tới khi khi nạp chương trình vào bộ nhớ l Trong khi thực hiện: l S/dụng khi các tiến trình có thể thay đổi vị trí trong khi t/hiện l Xác định địa chỉ được hoãn lại tới khi thực thi chương trình l Thường đòi hỏi trợ giúp từ phần cứng l Được sử dụng trong nhiều hệ điều hành Chương 3: Quản lý bộ nhớ 1. Tổng quan 1.3 Liên kết địa chỉ Xác định địa chỉ
1e8e6c622bfb571b0b783d8347182318,1e8e6c622bfb571b0b783d8347182318:132,133,"Thuật toán dựa trên bộ đếm Chương 3: Quản lý bộ nhớ 3. Bộ nhớ ảo 3.2 Các chiến lược đổi trang Sử dụng bộ đếm (một trường của PCB) ghi nhận số lần truy nhập tới trang l LFU: Trang có bộ đếm nhỏ nhất bị thay thế l Trang truy nhập nhiều đến l Trang quan trọng ⇒hợp lý l Trang khởi tạo, chỉ được dùng ở giai đoạn đầu ⇒ không hợp lý ⇒Dịch bộ đếm một bit (chia đôi) theo thời gian l MFU: Trang có bộ đếm lớn nhất l Trang có bộ đếm nhỏ nhất, vừa mới được nạp vào và vẫn chưa được sử dụng nhiều"
1e8e6c622bfb571b0b783d8347182318,1e8e6c622bfb571b0b783d8347182318:56,57,Nguyên tắc: Chia đôi liên tiếp vùng trống tự do cho tới khi thu được vùng trống nhỏ nhất thỏa mãn Cung cấp cho yêu cầu n bytes l Chia vùng trống tìm được thành 2 khối bằng nhau (gọi là buddies) l Tiếp tục chia vùng trống phía trên thành 2 phần cho tới khi đạt vùng trống nhỏ nhất kích thước lớn hơn n Ví dụ l Vùng trống 16K Bytes l Yêu cầu 735 Bytes Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.2 Chiến lược phân chương động Buddy Allocation: Cung cấp nhớ
2d1f518956cdc4b3cf6a9447714cfcd0,2d1f518956cdc4b3cf6a9447714cfcd0:138,139,83 / 107 Chương 4: Quản lý hệ thống file 4. Hệ thống FAT 4.1 Boot sector Giải mã bảng tham số của đĩa dùng NTFS
2d1f518956cdc4b3cf6a9447714cfcd0,2d1f518956cdc4b3cf6a9447714cfcd0:16,17,"Thư mục file hello.c vi trí Buf =Read(SoNT.dat) SoNT.dat vi trí 19/04/2011 Chương 4: Quản lý hệ thống file 1. Hệ thống file 1.1 Khái niệm file Các thao tác cơ bản : Đọc file l Lời gọi hệ thống Read() yêu cầu tên file và vùng đệm ghi KQ l Dùng tên file, tìm kiếm file trong thư mục file l Dựa vào trường vị trí, tìm vị trí của file trên thiết bị lưu trữ l Hệ thống lưu con trỏ đọc (read pointer) chỉ ra vị trí được đọc l Con trỏ đọc thay đổi sau mỗi thao tác đọc dữ liệu Không gian lưu trữ Kiemtra.pdf 235 17 rp 19 23 29 Buf:29 l Dùng một con trỏ cho cả thao tác đọc và ghi: con trỏ file hello.c"
2d1f518956cdc4b3cf6a9447714cfcd0,2d1f518956cdc4b3cf6a9447714cfcd0:155,156,"DATA #2 #3 #4 #5 #6 #7 #8 #9 Chương 4: Quản lý hệ thống file 4. Hệ thống FAT 4.2 Bảng FAT Phương pháp FAT gồm nhiều phần tử l Mỗi phần tử có thể 12bit, 16bit, 32bit l Mỗi phần tử ứng với 1 khối (cluster) trên vùng dữ liệu l 2 phần tử đầu (0,1) có ý nghĩa đặc biệt l Khuôn dạng đĩa, Bit shutdown, Bit diskerrror l Phần tử thứ 2 ứng với cluster đầu của phần Data"
2d1f518956cdc4b3cf6a9447714cfcd0,2d1f518956cdc4b3cf6a9447714cfcd0:96,97,64 / 107 Chương 4: Quản lý hệ thống file 3. Tổ chức thông tin trên đĩa từ 3.2.Cấu trúc logic của đĩa Ví dụ về bảng phân chương mở rộng 1
2d1f518956cdc4b3cf6a9447714cfcd0,2d1f518956cdc4b3cf6a9447714cfcd0:68,69,"Chương 4: Quản lý hệ thống file 3. Tổ chức thông tin trên đĩa từ 3.1 Cấu trúc vật lý của đĩa Định vị thông tin trên đĩa mềm l Sector đơn vị thông tin hệ thống dùng làm việc với đĩa l Sector xác định qua tọa độ 3 chiều: Header, Track, Sector l Ví dụ: Boot Sector của đĩa mềm: Sector <0, 0, 1> l Sector được xác định qua số hiệu sector (tọa độ 1 chiều) l Vị trí tương đối so với sector đầu tiên của đĩa Sector < 0, 0, 3 >→#2"
2d1f518956cdc4b3cf6a9447714cfcd0,2d1f518956cdc4b3cf6a9447714cfcd0:153,154,Chương 4: Quản lý hệ thống file 4. Hệ thống FAT l Boot sector l Bảng FAT (File Allocation Table) l Thư mục gốc
2d1f518956cdc4b3cf6a9447714cfcd0,2d1f518956cdc4b3cf6a9447714cfcd0:55,56,Phân phối chỉ mục Chương 4: Quản lý hệ thống file 2. Cài đặt hệ thống file 2. 2 Các phương pháp phân phối vùng lưu trữ Nguyên tắc: Mỗi file có một khối chỉ mục chính (index block) chứa danh sách các khối dữ liệu của file
2d1f518956cdc4b3cf6a9447714cfcd0,2d1f518956cdc4b3cf6a9447714cfcd0:15,16,"Thư mục file hello.c vi trí Buf =Read(SoNT.dat) SoNT.dat vi trí 19/04/2011 Chương 4: Quản lý hệ thống file 1. Hệ thống file 1.1 Khái niệm file Các thao tác cơ bản : Đọc file l Lời gọi hệ thống Read() yêu cầu tên file và vùng đệm ghi KQ l Dùng tên file, tìm kiếm file trong thư mục file l Dựa vào trường vị trí, tìm vị trí của file trên thiết bị lưu trữ l Hệ thống lưu con trỏ đọc (read pointer) chỉ ra vị trí được đọc l Con trỏ đọc thay đổi sau mỗi thao tác đọc dữ liệu Không gian lưu trữ Kiemtra.pdf 235 17 rp 19 23 29 Buf:23 hello.c"
2d1f518956cdc4b3cf6a9447714cfcd0,2d1f518956cdc4b3cf6a9447714cfcd0:112,113,Chương 4: Quản lý hệ thống file 4. Hệ thống FAT 4.1 Boot sector Ví dụ giải mã bảng tham số đĩa của FAT16 Có 6 sector đứng trước bảng FAT thứ nhất Số sector đứng trước FAT
2d1f518956cdc4b3cf6a9447714cfcd0,2d1f518956cdc4b3cf6a9447714cfcd0:111,112,2 sector cho 1 cluster Chương 4: Quản lý hệ thống file 4. Hệ thống FAT 4.1 Boot sector Ví dụ giải mã bảng tham số đĩa của FAT16 Số sector cho một cluster
2d1f518956cdc4b3cf6a9447714cfcd0,2d1f518956cdc4b3cf6a9447714cfcd0:184,185,File ReadMBR.C Tên file: READMBR Mởrộng:C Lưu trữ 600ms Chương 4: Quản lý hệ thống file 4. Hệ thống FAT 4.3 Thư mục gốc Giải mã ROOT 2
2d1f518956cdc4b3cf6a9447714cfcd0,2d1f518956cdc4b3cf6a9447714cfcd0:18,19,Chương 4: Quản lý hệ thống file 1. Hệ thống file 1.1 Khái niệm file Các thao tác cơ bản : Thay đổi vị trí trong file và thu gọn file l Thay đổi vị trí trong file l Duyệt thư mục để tìm phần tử tương ứng l Con trỏ file được thay bằng giá trị thích hợp l Thao tác này không yêu cầu một hoạt động vào/ra l Thu gọn file l Được sử dụng khi người sử dụng muốn xóa nội dung file nhưng vẫn giữ nguyên các thuộc tính l Tìm kiếm file trong thư mục file l Đặt kích thước file về 0 l Giải phóng vùng nhớ dành cho file
2d1f518956cdc4b3cf6a9447714cfcd0,2d1f518956cdc4b3cf6a9447714cfcd0:82,83,"Chương 4: Quản lý hệ thống file 3. Tổ chức thông tin trên đĩa từ 3.1 Cấu trúc vật lý của đĩa Cấu trúc vật lý đĩa cứng Cấu trúc l Gồm nhiều mặt đĩa, được đánh số từ 0,1 l Các rãnh cùng bán kính tạo nên cylinder, được đánh số từ 0, 1,.. l Các sector trên mỗi mặt của mỗi cylinder, được đánh số từ 1,2,... Định vị thông tin l Tọa độ 3 chiều (H, C, S) l Tọa độ 1 chiều: Số hiệu sector l Nguyên tắc như với đĩa mềm: Sector→Header→Cylinder"
2d1f518956cdc4b3cf6a9447714cfcd0,2d1f518956cdc4b3cf6a9447714cfcd0:9,10,"Thư mục file hello.c vi trí hello.c Write(SoNT.dat, 17) SoNT.dat vi trí 19/04/2011 Chương 4: Quản lý hệ thống file 1. Hệ thống file 1.1 Khái niệm file Các thao tác cơ bản : Ghi file l Lời gọi hệ thống Write() yêu cầu tên file và dữ liệu được ghi l Dùng tên file, tìm kiếm file trong thư mục file l Dựa vào trường vị trí, tìm vị trí của file trên thiết bị lưu trữ l Hệ thống lưu con trỏ ghi (write pointer) để chỉ ra vị trí ghi l Con trỏ ghi thay đổi sau mỗi thao tác ghi Không gian lưu trữ Kiemtra.pdf 235 17 wp"
2d1f518956cdc4b3cf6a9447714cfcd0,2d1f518956cdc4b3cf6a9447714cfcd0:164,165,Chương 4: Quản lý hệ thống file 4. Hệ thống FAT l Boot sector l Bảng FAT (File Allocation Table) l Thư mục gốc
2d1f518956cdc4b3cf6a9447714cfcd0,2d1f518956cdc4b3cf6a9447714cfcd0:117,118,Chương 4: Quản lý hệ thống file 4. Hệ thống FAT 4.1 Boot sector Ví dụ giải mã bảng tham số đĩa của FAT16 Số sector cho một bảng FAT:245
2d1f518956cdc4b3cf6a9447714cfcd0,2d1f518956cdc4b3cf6a9447714cfcd0:69,70,"Chương 4: Quản lý hệ thống file 3. Tổ chức thông tin trên đĩa từ 3.1 Cấu trúc vật lý của đĩa Định vị thông tin trên đĩa mềm l Sector đơn vị thông tin hệ thống dùng làm việc với đĩa l Sector xác định qua tọa độ 3 chiều: Header, Track, Sector l Ví dụ: Boot Sector của đĩa mềm: Sector <0, 0, 1> l Sector được xác định qua số hiệu sector (tọa độ 1 chiều) l Vị trí tương đối so với sector đầu tiên của đĩa Sector < 0, 0, 4 >→#3"
2d1f518956cdc4b3cf6a9447714cfcd0,2d1f518956cdc4b3cf6a9447714cfcd0:113,114,Có 2 bảngFAT Chương 4: Quản lý hệ thống file 4. Hệ thống FAT 4.1 Boot sector Ví dụ giải mã bảng tham số đĩa của FAT16
2d1f518956cdc4b3cf6a9447714cfcd0,2d1f518956cdc4b3cf6a9447714cfcd0:192,193,Chương 4: Quản lý hệ thống file 4. Hệ thống FAT 4.3 Thư mục gốc Giải mã ROOT 3
2d1f518956cdc4b3cf6a9447714cfcd0,2d1f518956cdc4b3cf6a9447714cfcd0:119,120,Sốđầu đọc ghi: 255 Chương 4: Quản lý hệ thống file 4. Hệ thống FAT 4.1 Boot sector Ví dụ giải mã bảng tham số đĩa của FAT16
74040f5628748874779838fa7a292b09,74040f5628748874779838fa7a292b09:100,101,Chương 1 Tổng quan về Hệ Điều Hành 6. Các khái niệm trong Hệ điều hành 6.4 Các cấu trúc hệ thống Máy ảo (Silberschatz 2002)
74040f5628748874779838fa7a292b09,74040f5628748874779838fa7a292b09:10,11,Chương 1 Tổng quan về Hệ Điều Hành 1. Khái niệm Hệ điều hành ①Khái niệm Hệ điều hành lCấu trúc phân lớp của hệ thống tính toán lChức năng hệ điều hành
74040f5628748874779838fa7a292b09,74040f5628748874779838fa7a292b09:4,5,Chương 1 Tổng quan về Hệ Điều Hành 1. Khái niệm Hệ điều hành 1.1. Cấu trúc phân lớp của hệ thống tính toán lSơ đồ kiến trúc của một hệ thống máy tính
74040f5628748874779838fa7a292b09,74040f5628748874779838fa7a292b09:81,82,"Chương 1 Tổng quan về Hệ Điều Hành 6. Các khái niệm trong Hệ điều hành 6.1 Các thành phần của hệ thống l Tiến trình: Chương trình đang thực hiện l Tiến trình sử dụng tài nguyên của hệ thống để hoàn thành công việc l Tài nguyên được cấp khi tiến trình được khởi tạo hay khi đang thi hành l Tiến trình kết thúc, tài nguyên được trả về l Hệ thống có thể tồn tại nhiều tiến trình tại một thời điểm l Tiến trình hệ thống l Tiến trình người sử dụng l Nhiệm của hệ điều hành trong việc quản lý tiến trình l Tạo và hủy các tiến trình của người sử dụng và của hệ thống l Ngưng và thực hiện lại một tiến trình l Cung cấp cơ chế đồng bộ tiến trình l Cung cấp cách thông tin giữa các tiến trình l Cung cấp cơ chế kiểm soát bế tắc giữa các tiến trình Quản lý tiến trình"
74040f5628748874779838fa7a292b09,74040f5628748874779838fa7a292b09:97,98,Chương 1 Tổng quan về Hệ Điều Hành 6. Các khái niệm trong Hệ điều hành 6.4 Các cấu trúc hệ thống Cấu trúc MS-DOS (Silberschatz 2002)
74040f5628748874779838fa7a292b09,74040f5628748874779838fa7a292b09:65,66,"Chương 1 Tổng quan về Hệ Điều Hành 5. Các khái niệm trong Hệ điều hành 5.1. Tiến trình và luồng Hệ thống đa tiến trình phân chia thời gian: lHĐH theo chu kỳ :dừng một tiến trình để bắt đầu một tt khác lCần lưu thông tin các tt ⇒Bảng tiến trình (process table) lMột tiến trình có thể khởi tạo tiến trình khác lShell của HĐH kích hoạt một tiến trình thực hiện lệnh; thực hiện xong, hủy tiến trình mới được kích hoạt lCác tiến trình có thể trao đổi thông tin với nhau l Một tiến trình có thế bao gồm nhiều luồng (tiểu trình)"
74040f5628748874779838fa7a292b09,74040f5628748874779838fa7a292b09:30,31,"* 1981-1995 : l Máy tính có giá trị 1000$; nhân công 100K $/năm ⇒Máy tính được sử dụng rộng rãi để việc hiệu quả hơn l Tính toán cá nhân l Máy tính rẻ, cung cấp cho mỗi người (PC: Máy tính cá nhân). l Hệ điều hành trên máy tính cá nhân l Tài nguyên phần cứng bị giới hạn (Thời gian đầu : 1980s) l HDH trở thành thư viện của các thủ tục cung cấp sẵn l Một chương trình tại một thời điểm (DOS) l Máy tính cá nhân trở nên mạnh l HDH gặp phải những vấn để phức tạp của một HDH lớn như đa nhiệm, bảo vệ bộ nhớ... (WINXP) l Giao diện người sử dung theo đồ họa (MAC, WIN,..) Chương 1 Tổng quan về Hệ Điều Hành 2.Lịch sử Hệ điều hành 2.2. Lịch sử phát triển của Hệ điều hành"
74040f5628748874779838fa7a292b09,74040f5628748874779838fa7a292b09:33,34,"* Các hệ thống phân tán l Giai đoạn phát triển của hệ điều hành mạng và HĐH phân tán Chương 1 Tổng quan về Hệ Điều Hành 2.Lịch sử Hệ điều hành 2.2. Lịch sử phát triển của Hệ điều hành l Các mạng cục bộ l Các máy tính cùng chia xẻ tài nguyên: máy in, File servers,.. l Mô hình Client / Server l Dịch vụ l Tính toán , Lưu trữ l Dịch vụ được cung cấp bởi Internet. l Vấn đề l Độ trễ truyền thông; băng thông, độ tin cậy,.. l Virus (love letter virus 05/2000),.."
74040f5628748874779838fa7a292b09,74040f5628748874779838fa7a292b09:93,94,Chương 1 Tổng quan về Hệ Điều Hành 6. Cấu trúc Hệ điều hành lCác thành phần của hệ thống lDịch vụ Hệ điều hành lLời gọi hệ thống lCác cấu trúc hệ thống
74040f5628748874779838fa7a292b09,74040f5628748874779838fa7a292b09:11,12,Chương 1 Tổng quan về Hệ Điều Hành 1. Khái niệm Hệ điều hành 1.2. Chức năng của hệ điều hành ①Giả lập một máy tính ảo ②Quản lý tài nguyên của hệ thống
74040f5628748874779838fa7a292b09,74040f5628748874779838fa7a292b09:47,48,Chương 1 Tổng quan về Hệ Điều Hành 3. Định nghĩa và phân loại Hệ điều hành 3.2. Phân loại Hệ thống song song l Đa xử lý không đối xứng (ASMP: asymmetric) l Một bộ xử lý chính kiểm soát toàn bộ hệ thống l Các bộ xử lý khác thực hiện theo lệnh của bộ xử lý chính hoặc theo những chỉ thị đã được định nghĩa trước l Mô hình này theo dạng quan hệ chủ tớ: Bộ xử lý chính sẽ lập lịch cho các bộ xử lý khác l VD: IBM System/360
74040f5628748874779838fa7a292b09,74040f5628748874779838fa7a292b09:42,43,Chương 1 Tổng quan về Hệ Điều Hành 3. Định nghĩa và phân loại Hệ điều hành 3.2. Phân loại l Hệ thống xử lý theo lô đơn chương trình l Hệ thống xử lý theo lô đa chương trình l Hệ thống phân chia thời gian l Hệ thống song song l Hệ thống phân tán l Hệ thống xử lý thời gian thực
74040f5628748874779838fa7a292b09,74040f5628748874779838fa7a292b09:0,1,Hệ Điều Hành (Nguyên lý các hệ điều hành) Đỗ Quốc Huy huydq@soict.hust.edu.vn Bộ môn Khoa Học Máy Tính Viện Công Nghệ Thông Tin và Truyền Thông
74040f5628748874779838fa7a292b09,74040f5628748874779838fa7a292b09:78,79,①Khái niệm Hệ điều hành ②Lịch sử phát triển Hệ điều hành ③Định nghĩa và phân loại Hệ điều hành ④Tính chất cơ bản của Hệ điều hành ⑤Các khái niệm trong hệ điều hành ⑥Cấu trúc hệ điều hành ⑦Vấn đề xây dựng Hệ điều hành Chương 1 Tổng quan về Hệ Điều Hành
74040f5628748874779838fa7a292b09,74040f5628748874779838fa7a292b09:18,19,Chương 1 Tổng quan về Hệ Điều Hành 2.Lịch sử Hệ điều hành 2.1. Lịch sử phát triển của máy tính điện tử Lịch sử phát triển của máy tính điện tử l 1941- Konrad Zuse (Đức) Xây dựng máy tính Rơle: Máy tính nhị phân lập trình được dựa trên công nghệ cơ điện. lZ3: sử dụng hệ nhị phân lCó bộ nhớ và điều khiển riêng biệt
74040f5628748874779838fa7a292b09,74040f5628748874779838fa7a292b09:64,65,"Chương 1 Tổng quan về Hệ Điều Hành 5. Các khái niệm trong Hệ điều hành 5.1. Tiến trình và luồng Tiến trình l Tiến trình (tt): một chương trình đang thực hiện lMã lệnh chương trình có thể thực thi lDữ liệu của chương trình lNgăn xếp, con trỏ ngăn xếp, các thanh ghi lCác thông tin cần thiết cho việc thực thi chương trình l Tiến trình >< chương trình l Chương trình: thực thể thụ động, chứa đựng các chỉ thị điều khiển máy tính thực hiện một nhiệm vụ nào đó l Tiến trình: trạng thái động của chương trình."
74040f5628748874779838fa7a292b09,74040f5628748874779838fa7a292b09:67,68,Chương 1 Tổng quan về Hệ Điều Hành 5. Các khái niệm trong Hệ điều hành
74040f5628748874779838fa7a292b09,74040f5628748874779838fa7a292b09:79,80,Chương 1 Tổng quan về Hệ Điều Hành 6. Cấu trúc Hệ điều hành lCác thành phần của hệ thống lDịch vụ Hệ điều hành lLời gọi hệ thống lCác cấu trúc hệ thống
74040f5628748874779838fa7a292b09,74040f5628748874779838fa7a292b09:55,56,Chương 1 Tổng quan về Hệ Điều Hành 4. Tính chất cơ bản của Hệ điều hành An toàn lDữ liệu và chương trình phải được bảo vệ lKhông bị thay đổi ngoài ý muốn và trong mọi chế độ làm việc lHạn chế truy nhập bất hợp pháp lCác tài nguyên khác nhau có yêu cầu bảo vệ khác nhau lBảo vệ nhiều mức với nhiều công cụ khác nhau lQuan trọng với hệ điều hành đa nhiệm
74040f5628748874779838fa7a292b09,74040f5628748874779838fa7a292b09:44,45,"Chương 1 Tổng quan về Hệ Điều Hành 3. Định nghĩa và phân loại Hệ điều hành 3.2. Phân loại Hệ thống xử lý theo lô đa chương trình l Cho phép thực hiện nhiều chương trình đồng thời l Nạp một phần mã và dữ liệu của các chương trình/tiến trình vào bộ nhớ (phần còn lại sẽ được nạp tại thời điểm thích hợp). Chương trình sẵn sàng được thực hiện l Thực hiện chương trình như hệ thống đơn chương trình l Nếu chương trình thực hiện vào ra, processor được chuyên giao cho chương trình đang sẵn sàng khác l Tiết kiệm bộ nhớ (không cần nạp toàn bộ chương trình vào bộ nhớ) l Hạn chế thời gian rỗi của processor l Chi phí cao cho điều phối processor. Chương trình nào tiếp theo sẽ được sử dụng processor? l Giải quyết vấn đề chia sẻ bộ nhớ giữa các chương trình"
a3aa8203ae0398a1ef263322bcadebc3,a3aa8203ae0398a1ef263322bcadebc3:39,40,"SSTF Chương 5: Quản lý vào ra 3. Hệ thống vào ra đĩa 3. 2 Điều phối truy nhập đĩa Chọn truy nhập có t/gian định vị từ vị trí hiện tại nhỏ nhất ⇒Có thể tồn tại y/c phải đợi vô hạn do y/c mới x/hiện gần đầu đọc hơn (tương tự SJF) Yêu cầu truy nhập 98, 183, 37, 122, 14, 124, 65, 67 12 2 2 23 84 24 59 30 Tổng: 236"
a3aa8203ae0398a1ef263322bcadebc3,a3aa8203ae0398a1ef263322bcadebc3:25,26,"Đặt vấn đề Chương 5: Quản lý vào ra 2. Dịch vụ vào ra của hệ thống 2.2 Quản lý lỗi vào ra l Lỗi luôn có thể xảy ra tại mọi bộ phận của hệ thống l Phần cứng: Intel 486? l Phần mềm: Win 98 ? l Tbnv: Hay gặp lỗi do tác động của môi trường l Xử lý lỗi ⇒Trách nhiệm của hệ thống l Được quan tâm ngay tại giai đoạn thiết kế, chế tạo l Kiểm tra chẵn/lẻ (parity check) l Tổng kiểm tra (check sum) l Các phép kiểm tra do phần cứng/phần mềm đảm nhiệm l Yêu cầu sử dụng linh hoạt các phép kiểm tra"
a3aa8203ae0398a1ef263322bcadebc3,a3aa8203ae0398a1ef263322bcadebc3:26,27,"Xử lý lỗi Chương 5: Quản lý vào ra 2. Dịch vụ vào ra của hệ thống 2.2 Quản lý lỗi vào ra l Phát hiện lỗi -> hệ thống cố gắng khắc phục bằng cách t/hiện lại nhiều lần l Nếu lỗi ổn định ⇒Cố gắng khôi phục lại thông tin ban đầu l Trường hợp lưu trữ, để đảm bảo chất lượng thông tin l TBĐK đọc lại kết quả vừa lưu trữ l So sánh với thông tin gốc/So sánh 2 tổng kiểm tra l Kết quả báo cho hệ thống để có xử lý tương ứng ⇒Lặp lại thao tác/ Thông báo lỗi l Thiết bị vào ra thường cung cấp mã trả về (return code) l Phân tích và đánh giá dựa trên mã nhận được"
a3aa8203ae0398a1ef263322bcadebc3,a3aa8203ae0398a1ef263322bcadebc3:44,45,"Vấn đề lựa chọn thuật toán Chương 5: Quản lý vào ra 3. Hệ thống vào ra đĩa 3. 2 Điều phối truy nhập đĩa l SSTF: Phổ biến, hiệu quả hơn FCFS l SCAN/C-SCAN hoạt động tốt hơn cho hệ thống có nhiều y/cầu truy nhập đĩa l Không gặp vấn đề ""starvation: chờ đợi quá lâu"" l Hiệu quả của các t/toán phụ thuộc số lượng và kiểu các y/cầu l Y/cầu truy xuất đĩa bị ảnh hưởng bởi các p/pháp phân phối đĩa cho file l P/phối liên tục: đưa ra các y/cầu truy xuất lân cận nhau l P/phối liên kết/ chỉ mục: có thể gồm các khối được phân bố rộng rãi trên đĩa l T/toán điều phối truy nhập đĩa có thể được viết như những modul riêng biệt của HĐH cho phép có thể thay thế bởi các t/toán khác khi cần thiết l Cả SSTF và LOOK đều có thể là lựa chọn hợp lý cho t/ toán mặc định"
a3aa8203ae0398a1ef263322bcadebc3,a3aa8203ae0398a1ef263322bcadebc3:35,36,Vấn đề truy nhập đĩa Chương 5: Quản lý vào ra 3. Hệ thống vào ra đĩa 3.1 Cấu trúc đĩa từ l Mục đích: cực tiểu hóa thời gian định vị l Thời gian định vị ≈khoảng cách dịch chuyển l Hàng đợi yêu cầu l Đĩa và bộ đ/khiển l sẵn sàng -> y/cầu truy nhập đc thực hiện ngay l chưa sẵn sàng -> y/cầu đc đặt trong hàng đợi l Hoàn thành 1 y/cầu truy nhập đĩa -> lựa chọn y/cầu nào?
a3aa8203ae0398a1ef263322bcadebc3,a3aa8203ae0398a1ef263322bcadebc3:41,42,"C-SCAN Chương 5: Quản lý vào ra 3. Hệ thống vào ra đĩa 3. 2 Điều phối truy nhập đĩa Nguyên tắc: Xử lý các cylinders như một danh sách nối vòng: Cylinder ngoài cùng nối tiếp với cylinder trong cùng l Đầu từ d/chuyển từ cylinder ngoài cùng -> cylinder trong cùng l Phục vụ cho các y/cầu gặp trên đường đi l Khi tới Cylinder trong cùng, quay ngược lại Cylinder ngoài cùng l Không phục vụ cho các y/cầu gặp trên đường đi l Nhận xét: l Thu được thời gian đợi đồng nhất hơn thuật toán SCAN l Khi đầu đọc đạt tới 1 phía của đĩa (cylinders trong cùng, ngoài cùng), mật độ các y/cầu xuất hiện ở phía bên kia > vị trí hiện tại (do vừa đi qua). l Các y/cầu này cũng đợi lâu hơn ⇒Quay ngay lập tức về phía bên kia"
a3aa8203ae0398a1ef263322bcadebc3,a3aa8203ae0398a1ef263322bcadebc3:4,5,"Chương 5: Quản lý vào ra 1. Nguyên tắc chung 1.1 Giới thiệu Thiết bị vào ra Quan điểm l kỹ thuật: là các thiết bị với bộ VXL, motor, các linh kiện khác l lập trình: Giao diện như phần mềm để nhận lệnh, thực hiện và trả kết quả về"
a3aa8203ae0398a1ef263322bcadebc3,a3aa8203ae0398a1ef263322bcadebc3:12,13,Chu kỳ của một yêu cầu vào ra Chương 5: Quản lý vào ra 1. Nguyên tắc chung 1.1 Giới thiệu
a3aa8203ae0398a1ef263322bcadebc3,a3aa8203ae0398a1ef263322bcadebc3:8,9,"Thiết bị điều khiển II Chương 5: Quản lý vào ra 1. Nguyên tắc chung 1.1 Giới thiệu l Mỗi TBĐK có thể điều khiển được 1,2,4,.. Tbnv l Tùy theo số giắc cắm có trên TBĐK l Nếu giao diện điều khiển chuẩn (ANSI, IEEE, ISO,...) có thể nối tới nhiều thiết bị khác l Mỗi TBĐK có các thanh ghi riêng để làm việc với CPU l Dùng các không gian địa chỉ đặc biệt cho các thanh ghi: cổng vào ra"
a3aa8203ae0398a1ef263322bcadebc3,a3aa8203ae0398a1ef263322bcadebc3:3,4,"Chương 5: Quản lý vào ra 1. Nguyên tắc chung 1.1 Giới thiệu Thiết bị vào ra l Đa dạng, nhiều loại thiết bị, mỗi loại có nhiều kiểu khác nhau"
a3aa8203ae0398a1ef263322bcadebc3,a3aa8203ae0398a1ef263322bcadebc3:6,7,Thiết bị điều khiển I Chương 5: Quản lý vào ra 1. Nguyên tắc chung 1.1 Giới thiệu l Thiết bị ngoại vi (Tbnv) đa dạng và nhiều loại l CPU không biết hết ⇒Không tồn tại tín hiệu riêng cho từng thiết bị l Processor không điều khiển trực tiếp thiết bị l TBNV được nối với hệ thống qua thiết bị điều khiển (D.C - Device Controller-Bộ điều khiển thiết bị) l Các mạch điện tử được cắm trên các khe cắm (slot) của mainboard máy tính
a3aa8203ae0398a1ef263322bcadebc3,a3aa8203ae0398a1ef263322bcadebc3:24,25,lVùng đệm (Buffer) lQuản lý lỗi vào ra lKỹ thuật SPOOL Chương 5: Quản lý vào ra 2. Dịch vụ vào ra của hệ thống 2. 2 Quản lý lỗi vào ra
a3aa8203ae0398a1ef263322bcadebc3,a3aa8203ae0398a1ef263322bcadebc3:32,33,lCấu trúc đĩa từ lĐiều phối truy nhập đĩa Chương 5: Quản lý vào ra 3. Hệ thống vào ra đĩa 3.1 Cấu trúc đĩa từ
a3aa8203ae0398a1ef263322bcadebc3,a3aa8203ae0398a1ef263322bcadebc3:19,20,lVùng đệm (Buffer) lQuản lý lỗi vào ra lKỹ thuật SPOOL Chương 5: Quản lý vào ra 2. Dịch vụ vào ra của hệ thống 2.1 Vùng đệm
a3aa8203ae0398a1ef263322bcadebc3,a3aa8203ae0398a1ef263322bcadebc3:17,18,Xử lý ngắt Chương 5: Quản lý vào ra 1. Nguyên tắc chung 1.2 Ngắt và xử lý ngắt ①Ghi nhận đặc trưng sự kiện gây ngắt vào ô nhớ cố định ②Ghi nhận trạng thái của tiến trình bị ngắt ③Chuyển địa chỉ của chương trình xử lý ngắt vào thanh ghi con trỏ lệnh l Sử dụng bảng vector ngắt (IBM-PC) ④Thực hiện chương trình xử lý ngắt ⑤Khôi phục lại tiến trình bị ngắt
a3aa8203ae0398a1ef263322bcadebc3,a3aa8203ae0398a1ef263322bcadebc3:13,14,"Giao tiếp thiết bị ngoại vi với hệ điều hành Chương 5: Quản lý vào ra 1. Nguyên tắc chung 1.1 Giới thiệu l Sau khi HĐH gửi yêu cầu ra tbnv, HĐH cần phải biết l Tbnv hoàn thành yêu cầu vào ra l Tbnv gặp lỗi l Có thể thực hiện theo 2 p/pháp Ngắt và thăm dò l Ngắt (I/O interrupts) l Tbnv phát sinh ra 1 tín hiệu ngắt để báo cho CPU biết l IRQ: Đường dẫn vật lý đến bộ quản lý ngắt l Ánh xạ các tín hiệu IRQ thành các vector ngắt l Gọi tới chương trình xử lý ngắt l Thăm dò (polling) l HĐH chu kỳ kiểm tra thanh ghi trạng thái của thiết bị l Lãng phí chu kỳ thăm dò nếu thao tác vào ra không thường xuyên l Các thiệt bị hiện thời có thể kết hợp cả 2 p/pháp (VD Các thiết bị mạng băng thông cao) l Ngắt khi gói tin đầu tiên tới l Thăm dò với các gói tin tiếp theo cho tới khi vùng đệm rỗng"
a3aa8203ae0398a1ef263322bcadebc3,a3aa8203ae0398a1ef263322bcadebc3:43,44,"LOOK/ C-LOOK Chương 5: Quản lý vào ra 3. Hệ thống vào ra đĩa 3. 2 Điều phối truy nhập đĩa Phiên bản của SCAN/C-SCAN: Đầu đọc không di chuyển tới các cylinders ngoài/trong cùng mà chỉ đến các y/cầu xa nhất về 2 phía rồi quay lại ngay Yêu cầu truy nhập 98, 183, 37, 122, 14, 124, 65, 67"
a3aa8203ae0398a1ef263322bcadebc3,a3aa8203ae0398a1ef263322bcadebc3:15,16,Khái niệm ngắt Chương 5: Quản lý vào ra 1. Nguyên tắc chung 1.2 Ngắt và xử lý ngắt Ngắt là phương tiện để cho các thiết bị khác trong hệ thống báo cho processor biết trạng thái của nó Ngắt là hiện tượng dừng đột xuất chương trình để chuyển sang thực hiện chương trình khác ứng với một sự kiện nào đó xảy ra l Ngắt >< chương trình con ! ?
a3aa8203ae0398a1ef263322bcadebc3,a3aa8203ae0398a1ef263322bcadebc3:9,10,Thiết bị điều khiển III Chương 5: Quản lý vào ra 1. Nguyên tắc chung 1.1 Giới thiệu
a3aa8203ae0398a1ef263322bcadebc3,a3aa8203ae0398a1ef263322bcadebc3:16,17,Phân loại ngắt Chương 5: Quản lý vào ra 1. Nguyên tắc chung 1.2 Ngắt và xử lý ngắt l Theo nguồn gốc l Ngắt bên trong l Ngắt bên ngoài l Theo thiết bị l Ngắt cứng l Ngắt mềm l Theo khả năng quản lý l Ngắt che được l Ngắt không che được l Theo thời điểm ngắt l Yêu cầu l Báo cáo
ea73ad6304ed438f7e7d4c59ddd227a1,ea73ad6304ed438f7e7d4c59ddd227a1:30,31,Chương 2 Quản lí tiến trình 1. Tiến trình 1.4. Hợp tác tiến trình * Khái niệm tiến trình * Điều phối tiến trình (Process Scheduling) * Thao tác trên tiến trình * Hợp tác tiến trình * Truyền thông liên tiến trình
ea73ad6304ed438f7e7d4c59ddd227a1,ea73ad6304ed438f7e7d4c59ddd227a1:126,127,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.4 Kỹ thuật đèn báo lKhái niệm tài nguyên găng lPhương pháp khóa trong lPhương pháp kiểm tra và xác lập lKỹ thuật đèn báo lVí dụ về đồng bộ tiến trình lCông cụ điều độ cấp cao
ea73ad6304ed438f7e7d4c59ddd227a1,ea73ad6304ed438f7e7d4c59ddd227a1:199,202,Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.2. Điều kiện xảy ra bế tắc l Đỉnh kiểu tiến trình được thể hiện bằng hình tròn l Đỉnh kiểu tài nguyên được thể hiện bằng hình chữ nhật l Mỗi đơn vị của kiểu tài nguyên được biểu thị bằng một dấu chấm trong hình chữ nhật l Cung yêu cầu đi từ đỉnh tiến trình tới đỉnh tài nguyên l Cung sử dụng xuất phát từ dấu chấm bên trong đỉnh tài nguyên tới đỉnh tiến trình Đồ thị cung cấp tài nguyên: Biểu diễn đồ trong đồ thị P P P R R R
ea73ad6304ed438f7e7d4c59ddd227a1,ea73ad6304ed438f7e7d4c59ddd227a1:142,143,"Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.4. Kỹ thuật đèn báo lCác phép xử lý P(S) và V(S) là không phân chia được ⇒bản thân P(S) và V(S) cũng là 2 tài nguyên găng ⇒Cũng cần điều độ. lHệ thống một VXL: Cấm ngắt khi thực hiện wait(), signal() lHệ thống nhiều vi xử lý lKhông thể cấm ngắt trên VXL khác lCó thể dùng phương pháp khoa trong ⇒Hiện tượng chờ đợi tích cực, nhưng thời gian chờ đợi ngắn (10 lệnh) Nhận xét"
ea73ad6304ed438f7e7d4c59ddd227a1,ea73ad6304ed438f7e7d4c59ddd227a1:253,256,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.5 Phòng tránh bế tắc Ví dụ minh họa : P1 yêu cầu (1, 0, 2) l Request[1]≤Available ((1, 0, 2) ≤ (3, 3, 2)) ⇒Có thể cung cấp l Nếu cung cấp : Available = ( 2 , 3, 0) R0 R1 R2 P0 0 1 0 P1 3 0 2 P2 3 0 2 P3 2 1 1 P4 0 0 2 Allocation R0 R1 R2 P0 7 4 3 P1 1 2 2 P2 6 0 0 P3 0 1 1 P4 4 3 1 Need Tiến trình P0 P1 P2 P3 P4 Finish T T T T T Work (10,5,7) Yêu cầu được chấp nhận"
ea73ad6304ed438f7e7d4c59ddd227a1,ea73ad6304ed438f7e7d4c59ddd227a1:237,240,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.5 Phòng tránh bế tắc Thuật toán người quản lý nhà băng: Giới thiệu l Thích hợp cho các hệ thống gồm các kiểu tài nguyên có nhiều đơn vị l Một tiến trình mới xuất hiện trong hệ thống cần khai báo số đơn vị lớn nhất của mỗi kiểu tài nguyên sẽ sử dụng l Không được vượt quá tổng số tài nguyên của hệ thống l Khi một tiến trình yêu cầu tài nguyên, hệ thống kiểm tra liệu đáp ứng cho yêu cầu hệ thống có còn an toàn không l Nếu hệ thống vẫn an toàn ⇒Cung cấp tài nguyên cho yêu cầu l Nếu hệ thống không an toàn ⇒Tiến trình phải đợi l Thuật toán cần l Các cấu trúc dữ liệu biểu diễn trạng thái phân phối tài nguyên l Thuật toán kiểm tra tình trạng an toàn của hệ thông l Thuật toán yêu cầu tài nguyên"
ea73ad6304ed438f7e7d4c59ddd227a1,ea73ad6304ed438f7e7d4c59ddd227a1:97,98,Chương 2 Quản lí tiến trình ①Tiến trình ②Luồng (Thread) ③Điều phối CPU ④Tài nguyên găng và điều độ tiến trình ⑤Bế tắc và xử lý bế tắc
ea73ad6304ed438f7e7d4c59ddd227a1,ea73ad6304ed438f7e7d4c59ddd227a1:206,209,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.3. Các phương pháp xử lý bế tắc l Phòng ngừa l Áp dụng các biện pháp để đảm bảo hệ thống không bao giờ rơi vào tình trạng bế tắc l Tốn kém l Áp dụng cho hệ thống hay xảy ra bế tắc và tổn thất do bế tắc gây ra lớn l Phòng tránh l Kiểm tra từng yêu cầu tài nguyên của tiến trình và không chấp nhận yêu cầu nếu việc cung cấp tài nguyên có khả năng dẫn đến tình trạng bế tắc l Thường yêu cầu các thông tin phụ trợ l Áp dụng cho hệ thống ít xảy ra bế tắc nhưng tổn hại lớn l Nhận biết và khắc phục l Cho phép hệ thống hoạt động bình thường ⇒có thểrơi vào tình trạng bế tắc l Định kỳ kiểm tra xem bế tắc có đang xảy ra không l Nếu đang bế tắc, áp dụng các biện pháp loại bỏ bế tắc l Áp dụng cho hệ thống ít xảy ra bế tắc và thiệt hại không lớn Phương pháp"
ea73ad6304ed438f7e7d4c59ddd227a1,ea73ad6304ed438f7e7d4c59ddd227a1:263,266,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.6 Nhận biết và khắc phục Ví dụ minh họa R0 R1 R2 P0 0 0 0 P1 2 0 2 P2 0 0 0 P3 1 0 0 P4 6 0 2 Request R0 R1 R2 P0 0 1 0 P1 2 0 0 P2 3 0 3 P3 2 1 1 P4 0 0 2 Allocation l Tài nguyên hiện có (R0, R1, R2) =(0, 0, 0) Tiến trình P0 P1 P2 P3 P4 Finish T F F F F Work (0,1,0) F F"
ea73ad6304ed438f7e7d4c59ddd227a1,ea73ad6304ed438f7e7d4c59ddd227a1:144,145,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.4. Kỹ thuật đèn báo Ví dụ 1
ea73ad6304ed438f7e7d4c59ddd227a1,ea73ad6304ed438f7e7d4c59ddd227a1:79,80,"Chương 2 Quản lí tiến trình 3. Điều phối CPU 3.1. Các khái niệm cơ bản l Lựa chọn một trong số các tiến trình đang sẵn sàng trong bộ nhớ và cung cấp CPU cho nó l Các tiến trình phải sắp hàng trong hàng đợi l Hàng đợi FIFO, Hàng đợi ưu tiên, DSLK đơn giản . . . l Quyết định điều phối CPU xảy ra khi tiến trình 1) Chuyển từ trạng thái thực hiện sang trạng thái chờ đợi (y/c vào/ra) 2) Chuyển từ trạng thái thực hiện sang trạng thái sẵn sàng (hết thời gian sử dụng CPU →ngắt thời gian) 3) Chuyển từ trạng thái chờ đợi sang trạng thái sẵn sàng (hoàn thành vào/ra) 4) Tiến trình kết thúc l Ghi chú l Trường hợp 1&4 ⇒Điều phối không trưng dụng (non-preemptive) l Trường hợp khác ⇒Điều phối trưng dụng (preemptive) Bộ điều phối CPU"
ea73ad6304ed438f7e7d4c59ddd227a1,ea73ad6304ed438f7e7d4c59ddd227a1:209,212,Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.4 Phòng ngừa bế tắc Điều kiện tài nguyên găng l Giảm bớt mức độ găng của hệ thống l Tài nguyên phân chia được (file chỉ đọc): Sử dụng đồng thời l Tài nguyên không phân chia được: Sử dụng không đồng thời l Kỹ thuật SPOOL(Simultaneous peripheral operation on-line) l Không phân phối tài nguyên khi không thực sự cần thiết l Chỉ một số ít tiến trình có khả năng yêu cầu tài nguyên l Chỉ printer daemon mới làm việc với máy in ⇒Bế tắc cho tài nguyên máy in bị hủy bỏ l Không phải tài nguyên nào cũng dùng kỹ thuật SPOOL được
ea73ad6304ed438f7e7d4c59ddd227a1,ea73ad6304ed438f7e7d4c59ddd227a1:231,234,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.5 Phòng tránh bế tắc Thuật toán dựa vào đồ thị cung cấp tài nguyên l Sử dụng khi mỗi kiểu tài nguyên chỉ có 1 đơn vị l Có chu trình, sẽ có bế tắc l Thêm vào đồ thị loại cung mới: cung đòi hỏi Pi →Rj l Cùng hướng với cung yêu cầu, thể hiện trong đồ thị −− > l Cho biết Pi có thể yêu cầu Rj trong tương lai l Tiến trình khi tham gia hệ thống, phải thêm tất cả các cung đòi hỏi tương ứng vào đồ thị l Khi Pi yêu cầu Rj, cung đòi hỏi Pi →Rj chuyển thành cung yêu cầu Pi →Rj l Khi Pi giải phóng Rj, cung sử dụng Rj →Pi chuyển thành cung đòi hỏi Pi →Rj"
ea73ad6304ed438f7e7d4c59ddd227a1,ea73ad6304ed438f7e7d4c59ddd227a1:101,102,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.1 Khái niệm tài nguyên găng
ea73ad6304ed438f7e7d4c59ddd227a1,ea73ad6304ed438f7e7d4c59ddd227a1:195,198,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.2. Điều kiện xảy ra bế tắc Cần có 4 điều kiện sau, không được thiếu điều kiện nào l Tồn tại tài nguyên găng l Tài nguyên được sử dụng theo mô hình không phân chia được l Chỉ có một tiến trình dung tài nguyên tại một thời điểm l Tiến trình khác cũng yêu cầu tài nguyên ⇒yêu cầu phải được hoãn lại tới khi tài nguyên được giải phóng l Chờ đợi trước khi vào đoạn găng l Tiến trình không được vào đoạn găng phải xếp hàng chờ đợi. l Trong khi chờ đợi vẫn chiếm giữ các tài nguyên được cung cấp l Không có hệ thống phân phối lại tài nguyên găng l Tài nguyên không thể được trưng dụng l Tài nguyên được giải phỏng chỉ bởi tiến trình đang chiếm giữ khi đã hoàn thành nhiệm vụ l Chờ đợi vòng tròn l Tồn tại tập các tiến trình {P0, P2, . . . , Pn} đang đợi nhau theo kiểu: P0 →R1 →P1; P1 →R2 →P2; . . . Pn−1 →Rn →Pn; Pn →R0 →P0 l Chờ đợi vòng tròn tạo ra chu trình không kết thúc Điều kiện cần"
ea73ad6304ed438f7e7d4c59ddd227a1,ea73ad6304ed438f7e7d4c59ddd227a1:114,115,"Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.2. Phương pháp khóa trong l Mỗi t/trình dùng một byte trong vùng nhớ chung làm khóa l Tiến trình vào đoạn găng, đóng khoá (byte khóa: true) l Tiến trình thoát khỏi đoạn găng, mở khóa (byte khóa: false) l Tiến trình muốn vào đoạn găng: kiểm tra khóa của tiến trình còn lại l Đang khóa ⇒Đợi l Đang mở ⇒Được quyền vào đoạn găng Nguyên tắc"
ea73ad6304ed438f7e7d4c59ddd227a1,ea73ad6304ed438f7e7d4c59ddd227a1:194,197,Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.1. Khái niệm bế tắc(Deadlock) l Khái niệm bế tắc l Điều kiện xảy ra bế tắc l Các phương pháp xử lý bế tắc l Phòng ngừa bế tắc l Phòng tránh bế tắc l Nhận biết và khắc phục
ea73ad6304ed438f7e7d4c59ddd227a1,ea73ad6304ed438f7e7d4c59ddd227a1:60,61,"Chương 2 Quản lí tiến trình 2. Luồng 2.1. Giới thiệu Luồng người dùng (User -Level Threads) l Quản lý các luồng được thực hiện bởi chương trình ứng dụng l Nhân hệ thống không biết gì về sự tồn tại luồng l Điều phối tiến trình như một đơn vị duy nhất l Gán cho mỗi tiến trình một trạng thái duy nhất l Sẵn sàng, chờ đợi, thực hiện,.. l Chương trình ứng dụng được lập trình theo mô hình đa luồng được hỗtrợ bởi thư viện luồng l Ưu điểm l Nhanh chóng trong tạo và quản lý luồng l Nhược điểm l Khi một luồng rơi vào trạng thái chờ đợi, tất cả các luồng trong cùng tiến trình bị chờ đợi theo ⇒Không tận dụng được ưu điểm của mô hình lập trình đa luồng"
ea73ad6304ed438f7e7d4c59ddd227a1,ea73ad6304ed438f7e7d4c59ddd227a1:203,206,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.2. Điều kiện xảy ra bế tắc l Trạng thái hệ thống l 3 tiến trình P1, P2, P3 l 4 tài nguyên R1, R2, R3, R4 l P3 yêu cầu tài nguyên R4 l Xuất hiện cung yêu cầu P3 →R4 l Cung yêu cầu P3 →R4 chuyển thành cung sử dụng R4 →P3 l P3 Giải phóng tài nguyên R4 l Cung sử dụng R4 →P3 bị xóa khỏi đồ thị l P3 yêu cầu tài nguyên R1 l Xuất hiện cung yêu cầu P3 →R1 l Trên đồ thị xuất hiện chu trình l Hệ thống bế tắc Đồ thị cung cấp tài nguyên: Ví dụ P1 P2 P3 R2 R3 R1 R4"
ea73ad6304ed438f7e7d4c59ddd227a1,ea73ad6304ed438f7e7d4c59ddd227a1:242,245,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.5 Phòng tránh bế tắc Ví dụ minh họa : Kiểm tra tính an toàn l Số tài nguyên còn sẵn trong hệ thống Avaiable(R0, R1, R2) =(3, 3, 2) l Yêu cầu còn lại của mỗi tiến trình (Need = Max - Allocation) R0 R1 R2 P0 7 5 3 P1 3 2 2 P2 9 0 2 P3 2 2 2 P4 4 3 3 Max R0 R1 R2 P0 0 1 0 P1 2 0 0 P2 3 0 2 P3 2 1 1 P4 0 0 2 Allocation R0 R1 R2 P0 7 4 3 P1 1 2 2 P2 6 0 0 P3 0 1 1 P4 4 3 1 Need"
