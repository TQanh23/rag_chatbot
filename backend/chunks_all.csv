chunk_id,document_id,order_index,page,end_page,section,text_len,text
1e8e6c622bfb571b0b783d8347182318:0,1e8e6c622bfb571b0b783d8347182318,0,1,,,143,Hệ Điều Hành (Nguyên lý các hệ điều hành) Đỗ Quốc Huy huydq@soict.hust.edu.vn Bộ môn Khoa Học Máy Tính Viện Công Nghệ Thông Tin và Truyền Thông
1e8e6c622bfb571b0b783d8347182318:1,1e8e6c622bfb571b0b783d8347182318,1,2,,,854,l Mục đích của hệ thống máy tính: thực hiện chương trình l Chương trình và dữ liệu (toàn bộ hoặc một phần) phải nằm trong bộ nhớ chính trong khi thực hiện l Byte tích cực:Những byte nội dung đang được thực hiện tại thời điểm quan sát l Phần chương trình chưa đưa vào bộ nhớ chính được lưu trên bộ nhớ thứ cấp (VD: đĩa cứng)⇒Bộ nhớ ảo l Cho phép lập trình viên không lo lắng về giới hạn bộ nhớ vật lý l Để s/d CPU hiệu quả và tăng tốc độ đáp ứng của hệ thống: l Cần luân chuyển CPU thường xuyên giữa các tiến trình Điều phối CPU (Phần 3- Chương 2) l Cần nhiều tiến trình sẵn sàng trong bộ nhớ l Hệ số song song của hệ thống: Số tiến trình đồng thời tồn tại trong hệ thống l Tồn tại nhiều chiến lược quản lý bộ nhớ khác nhau l Nhiều chiến lược đòi hỏi trợ giúp từ phần cứng l Thiết kế phần cứng có thể được tích hợp chặt chẽ với HDH Chương 3 Quản lý bộ nhớ
1e8e6c622bfb571b0b783d8347182318:2,1e8e6c622bfb571b0b783d8347182318,2,3,,,111,①Tổng quan ②Các chiến lược quản lý bộ nhớ ③Bộ nhớ ảo ④Quản lý bộ nhớ trong VXL họ Intel Chương 3 Quản lý bộ nhớ
1e8e6c622bfb571b0b783d8347182318:3,1e8e6c622bfb571b0b783d8347182318,3,4,,,112,lVí dụ lBộ nhớ và chương trình lLiên kết địa chỉ lCác cấu trúc chương trình Chương 3 Quản lý bộ nhớ 1. Tổng quan
1e8e6c622bfb571b0b783d8347182318:4,1e8e6c622bfb571b0b783d8347182318,4,5,,,74,Chương 3: Quản lý bộ nhớ 1. Tổng quan 1.1 Ví dụ Quá trình biên dịch file C
1e8e6c622bfb571b0b783d8347182318:5,1e8e6c622bfb571b0b783d8347182318,5,6,,,74,Chương 3: Quản lý bộ nhớ 1. Tổng quan 1.1 Ví dụ Quá trình biên dịch file C
1e8e6c622bfb571b0b783d8347182318:6,1e8e6c622bfb571b0b783d8347182318,6,7,,,74,Chương 3: Quản lý bộ nhớ 1. Tổng quan 1.1 Ví dụ Quá trình biên dịch file C
1e8e6c622bfb571b0b783d8347182318:7,1e8e6c622bfb571b0b783d8347182318,7,8,,,74,Chương 3: Quản lý bộ nhớ 1. Tổng quan 1.1 Ví dụ Quá trình biên dịch file C
1e8e6c622bfb571b0b783d8347182318:8,1e8e6c622bfb571b0b783d8347182318,8,9,,,74,Chương 3: Quản lý bộ nhớ 1. Tổng quan 1.1 Ví dụ Quá trình biên dịch file C
1e8e6c622bfb571b0b783d8347182318:9,1e8e6c622bfb571b0b783d8347182318,9,10,,,355,"Toto project file main.c #include <stdio.h> extern int x, y; extern void toto(); int main(int argc, char *argv[]){ toto(); printf(""KQ: %d \n"",x * y); return 0; } file M1.c int y = 10; file M2.c int x; extern int y; void toto(){ x = 10 * y; } Kết quả KQ: 1000 Chương 3: Quản lý bộ nhớ 1. Tổng quan 1.1 Ví dụ Ví dụ : Tạo chương trình thực thi từ nhiều modul"
1e8e6c622bfb571b0b783d8347182318:10,1e8e6c622bfb571b0b783d8347182318,10,11,,,369,"extern int x,y; extern void toto(); int main(){ toto() printf() } main.c int y=10; M1.c int x; extern int y; toto() M2.c Compiler (tcc -c) x y toto printf main.o [y←10] M1.o [x] y [toto] M2.o Thư viện [printf] Link (tlink) Header [y←10] [x] [printf] - - [toto] xy toto printf x y Chương 3: Quản lý bộ nhớ 1. Tổng quan 1.1 Ví dụ Quá trình biên dịch toto project toto.exe"
1e8e6c622bfb571b0b783d8347182318:11,1e8e6c622bfb571b0b783d8347182318,11,12,,,112,lVí dụ lBộ nhớ và chương trình lLiên kết địa chỉ lCác cấu trúc chương trình Chương 3 Quản lý bộ nhớ 1. Tổng quan
1e8e6c622bfb571b0b783d8347182318:12,1e8e6c622bfb571b0b783d8347182318,12,13,,,593,"l Bộ nhớ là tài nguyên quan trọng của hệ thống l Chương trình phải nằm trong bộ nhớ trong để thực hiện l Bộ nhớ được đặc trưng bởi kích thước và tốc độ truy nhập l Bộ nhớ được phân cấp theo tốc độ truy nhập Loại bộ nhớ Kích thước Tốc độ Thanh ghi (Registers) Cache trên VXL Cache mức 2 Bộnhớ chính Bộ nhớ lưu trữ (Disk) Băng từ, đĩa quang bytes Kilo Bytes KiloByte-MegaByte MegaByte-GigaByte GigaByte-Terabytes Không giới hạn Tốc độ CPU(ηs) 10 nano seconds 100 nanoseconds e Micro-seconds Mili-Seconds 10 Seconds Chương 3: Quản lý bộ nhớ 1. Tổng quan 1.2 Bộ nhớ và chương trình Phân cấp bộ nhớ"
1e8e6c622bfb571b0b783d8347182318:13,1e8e6c622bfb571b0b783d8347182318,13,14,,,254,"00000 00001 FFFFE FFFFF Memory l Dùng lưu trữdữliệu và chương trình l Là mảng các ô nhớkiểu bytes, words l Mỗi ô nhớcó một địa chỉriêng l Địa chỉvật lý: địa chỉx/hiện ởchân VXL Chương 3: Quản lý bộ nhớ 1. Tổng quan 1.2 Bộ nhớ và chương trình Bộ nhớ chính"
1e8e6c622bfb571b0b783d8347182318:14,1e8e6c622bfb571b0b783d8347182318,14,15,,,483,"l Tồn tại trên thiết bị lưu trữ ngoài l Là các file nhị phân thực thi được l Vùng tham số file l Lệnh máy (mã nhị phân), l Vùng dữ liệu (biến toàn cục), . . l Phải được đưa vào bộ nhớ trong và được đặt trong một tiến trình để thực hiện (tiến trình thực hiện chương trình) l Hàng đợi vào (input queue) l Tập các tiến trình ở bộ nhớ ngoài (thông thường: disk) l Đợi để được đưa vào bộ nhớ trong và thực hiên Chương 3: Quản lý bộ nhớ 1. Tổng quan 1.2 Bộ nhớ và chương trình Chương trình"
1e8e6c622bfb571b0b783d8347182318:15,1e8e6c622bfb571b0b783d8347182318,15,16,,,870,"l Nạp chương trình vào bộ nhớ l Đọc và phân tích (dịch) file thực thi (VD file *.com, file *.exe) l Xin vùng nhớ để nạp chương trình từ file trên đĩa l Thiết lập các tham số, các thanh ghi tới giá trị thích hợp l Thực thi chương trình l CPU lấy các lệnh trong bộ nhớ tại vị trí được xác định bởi bộ đếm chương trình (Program counter) l Cặp thanh ghi CS:IP với VXL họ Intel (Ví dụ : 80x86) l CPU giải mã lệnh l Có thể lấy thêm toán hạng từ bộ nhớ l Thực hiện lệnh với toán hạng l Nếu cần thiết, lưu kết quả vào bộ nhớ tại một địa chỉ xác định l Thực hiện xong l Giải phóng vùng không gian nhớ dành cho chương trình l Vấn đề l Chương trình có thể được nạp vào vị trí bất kỳ trong bộ nhớ l Khi thực hiện chương trình sinh ra chuỗi địa chỉ bộ nhớ l Truy nhập địa chỉ bộ nhớ như thế nào? Chương 3: Quản lý bộ nhớ 1. Tổng quan 1.2 Bộ nhớ và chương trình Thực hiện chương trình"
1e8e6c622bfb571b0b783d8347182318:16,1e8e6c622bfb571b0b783d8347182318,16,17,,,112,lVí dụ lBộ nhớ và chương trình lLiên kết địa chỉ lCác cấu trúc chương trình Chương 3 Quản lý bộ nhớ 1. Tổng quan
1e8e6c622bfb571b0b783d8347182318:17,1e8e6c622bfb571b0b783d8347182318,17,18,,,296,Bộnhớtrong Chương trình nguồn Dịch Nạp Chương trình trong bộnhớ Các modul đối tượng khác Thư viện hệ thống Thư viện hệ thống được nạp động 20/ 96 Liên kết Modul đối tượng Modul thực hiện Liên kết động Chương 3: Quản lý bộ nhớ 1. Tổng quan 1.3 Liên kết địa chỉ Các bước xử lý chương trình ứng dụng
1e8e6c622bfb571b0b783d8347182318:18,1e8e6c622bfb571b0b783d8347182318,18,19,,,771,"l Địa chỉ biểu tượng (symbolic) l Là tên của đối tượng trong chương trình nguồn l Ví dụ: counter, x, y,... l Địa chỉ tương đối l Sinh ra từ địa chỉ biểu tượng trong giai đoạn dịch (compiler) l Là vị trí tương đối của đối tượng kể từ đầu modul l Byte thứ 10 kể từ đầu modul l EB08 ⇒JMP +08: Nhảy tới vị trí cách vị trí hiện tại 8 ô l Địa chỉ tuyệt đối l Sinh ra từ địa chỉ tương đối trong giai đoạn nạp chương trình thực thi vào bộ nhớ để thực hiện l Với PC: địa chỉ tương đối <Seg :Ofs>→Seg * 16+Ofs l Là địa chỉ của đối tượng trong bộ nhớ vật lý-địa chỉ vật lý l Ví dụ: JMP 010A⇒Nhảy tới ô nhớ có vị trí 010Ah tại cùng đoạn mã lệnh (CS) l Nếu CS=1555h, sẽ đi tới vị trí: 1555h*10h+010Ah =1560Ah Chương 3: Quản lý bộ nhớ 1. Tổng quan 1.3 Liên kết địa chỉ Các kiểu địa chỉ"
1e8e6c622bfb571b0b783d8347182318:19,1e8e6c622bfb571b0b783d8347182318,19,20,,,804,Xác định địa chỉ câu lệnh và dữ liệu trong bộ nhớ có thể thực hiện tại các giai đoạn khác nhau khi xử lý chương trình ứng dụng l Giai đoạn dịch: l Sử dụng khi biết chương trình sẽ nằm ở đâu trong bộ nhớ l Khi dịch sẽ sinh ra mã (địa chỉ) tuyệt đối l Phải dịch lại khi vị trí bắt đầu thay đổi l Thời điểm nạp: l Sử dụng khi không biết c/trình sẽ nằm ở đâu trong bộ nhớ l Các đối tượng được dịch ra sẽ mang địa chỉ tương đối l Xác định địa chỉ được hoãn lại tới khi khi nạp chương trình vào bộ nhớ l Trong khi thực hiện: l S/dụng khi các tiến trình có thể thay đổi vị trí trong khi t/hiện l Xác định địa chỉ được hoãn lại tới khi thực thi chương trình l Thường đòi hỏi trợ giúp từ phần cứng l Được sử dụng trong nhiều hệ điều hành Chương 3: Quản lý bộ nhớ 1. Tổng quan 1.3 Liên kết địa chỉ Xác định địa chỉ
1e8e6c622bfb571b0b783d8347182318:20,1e8e6c622bfb571b0b783d8347182318,20,21,,,423,"l Địa chỉ logic (địa chỉ ảo) l Được sinh ra trong tiến trình, (CPU đưa ra) l Được khối quản lý bộ nhớ (MMU) chuyển sang địa chỉ vật lý khi truy nhập tới đối tượng trong chương trình l Địa chỉ vật lý l Địa chỉ của một phần tử (byte/word) của bộ nhớ l Tương ứng với địa chỉ logic được CPU đưa ra l Chương trình làm việc với địa chỉ logic Chương 3: Quản lý bộ nhớ 1. Tổng quan 1.3 Liên kết địa chỉ Địa chỉ vật lý-địa chỉ logic"
1e8e6c622bfb571b0b783d8347182318:21,1e8e6c622bfb571b0b783d8347182318,21,22,,,142,lVí dụ lBộ nhớ và chương trình lLiên kết địa chỉ lCác cấu trúc chương trình Chương 3 Quản lý bộ nhớ 1. Tổng quan 1.4 Các cấu trúc chương trình
1e8e6c622bfb571b0b783d8347182318:22,1e8e6c622bfb571b0b783d8347182318,22,23,,,158,25/ 96 ①Cấu trúc tuyến tính ②Cấu trúc nạp động ③Cấu trúc liên kết động ④Cấu trúc Overlays Chương 3: Quản lý bộ nhớ 1. Tổng quan 1. 4 Các cấu trúc chương trình
1e8e6c622bfb571b0b783d8347182318:23,1e8e6c622bfb571b0b783d8347182318,23,24,,,352,"M0 M1 M2 M3 Biên tập M0 M1 M2 M3 l Sau khi biên tập, các modul được tập hợp thành một chương trình hoàn thiện l Chứa đầy đủ các thông tin để có thể thực hiện được l Các biến trỏ ngoài đã thay bằng giá trị cụ thể l Để thực hiện, chỉ cần định vị một lần trong bộ nhớ Chương 3: Quản lý bộ nhớ 1. Tổng quan 1.4 Các cấu trúc chương trình Cấu trúc tuyến tính"
1e8e6c622bfb571b0b783d8347182318:24,1e8e6c622bfb571b0b783d8347182318,24,25,,,397,"27/ 96 l Ưu điểm l Đơn giản, dễ tổ chức biên tập và định vị chương trình l Thời gian thực hiện nhanh l Tính lưu động cao l Nhược điểm l Lãng phí bộ nhớ l Không phải toàn bộ chương trình đều cần thiết cho thực hiện chương trình l Không thực hiện được chương trình có kích thước lớn hơn kích thước bộ nhớ vật lý Chương 3: Quản lý bộ nhớ 1. Tổng quan 1.4 Các cấu trúc chương trình Cấu trúc tuyến tính"
1e8e6c622bfb571b0b783d8347182318:25,1e8e6c622bfb571b0b783d8347182318,25,26,,,142,M0 M1 M2 M3 Hệ điều hành l Mỗi modul được biên tập riêng Chương 3: Quản lý bộ nhớ 1. Tổng quan 1.4 Các cấu trúc chương trình Cấu trúc nạp động
1e8e6c622bfb571b0b783d8347182318:26,1e8e6c622bfb571b0b783d8347182318,26,27,,,192,"M0 M1 M2 M3 Hệ điều hành M0 l Mỗi modul được biên tập riêng l Khi thực hiện, hệ thống sẽ định vị modul gốc Chương 3: Quản lý bộ nhớ 1. Tổng quan 1.4 Các cấu trúc chương trình Cấu trúc nạp động"
1e8e6c622bfb571b0b783d8347182318:27,1e8e6c622bfb571b0b783d8347182318,27,28,,,251,"M0 M1 M2 M3 Hệ điều hành M0 M1 l Mỗi modul được biên tập riêng l Khi thực hiện, hệ thống sẽ định vị modul gốc l Cần tới modul nào sẽ xin bộ nhớ và giải nạp modul vào Chương 3: Quản lý bộ nhớ 1. Tổng quan 1.4 Các cấu trúc chương trình Cấu trúc nạp động"
1e8e6c622bfb571b0b783d8347182318:28,1e8e6c622bfb571b0b783d8347182318,28,29,,,254,"M0 M1 M2 M3 Hệ điều hành M0 M1 M2 l Mỗi modul được biên tập riêng l Khi thực hiện, hệ thống sẽ định vị modul gốc l Cần tới modul nào sẽ xin bộ nhớ và giải nạp modul vào Chương 3: Quản lý bộ nhớ 1. Tổng quan 1.4 Các cấu trúc chương trình Cấu trúc nạp động"
1e8e6c622bfb571b0b783d8347182318:29,1e8e6c622bfb571b0b783d8347182318,29,30,,,352,"M0 M1 M2 M3 Hệ điều hành M0 M1 M2 l Mỗi modul được biên tập riêng l Khi thực hiện, hệ thống sẽ định vị modul gốc l Cần tới modul nào sẽ xin bộ nhớ và giải nạp modul vào l Khi sử dụng xong một modul, hoặc khi thiếu vùng nhớ sẽ đưa nhưng modul không cần thiết ra ngoài Chương 3: Quản lý bộ nhớ 1. Tổng quan 1.4 Các cấu trúc chương trình Cấu trúc nạp động"
1e8e6c622bfb571b0b783d8347182318:30,1e8e6c622bfb571b0b783d8347182318,30,31,,,348,"M0 M1 M2 M3 Hệ điều hành M0 M3 l Mỗi modul được biên tập riêng l Khi thực hiện, hệ thống sẽ định vị modul gốc l Cần tới modul nào sẽxin bộ nhớ và giải nạp modul vào l Khi sử dụng xong một modul, hoặc khi thiếu vùng nhớ sẽ đưa nhưng modul không cần thiết ra ngoài Chương 3: Quản lý bộ nhớ 1. Tổng quan 1.4 Các cấu trúc chương trình Cấu trúc nạp động"
1e8e6c622bfb571b0b783d8347182318:31,1e8e6c622bfb571b0b783d8347182318,31,32,,,414,Ưu điểm l Có thể sử dụng vùng nhớ nhiều hơn phần dành cho chương trình l Hiệu quả sử dụng bộ nhớ cao nếu quản lý tốt Nhược điểm l Tốc độ thực hiện chậm l Sai lầm sẽ dẫn tới lãng phí bộ nhớ và tăng thời gian thực hiện l Yêu cầu người sử dụng phải nạp và xóa các modul l Người dùng phải nắm rõ hệ thống l Giảm tính lưu động 29/ 96 Chương 3: Quản lý bộ nhớ 1. Tổng quan 1.4 Các cấu trúc chương trình Cấu trúc nạp động
1e8e6c622bfb571b0b783d8347182318:32,1e8e6c622bfb571b0b783d8347182318,32,33,,,431,"M toto() toto() M toto l Các liên kết sẽ hoãn lại cho tới khi thực hiện chương trình l Một phần của đoạn mã (stub) được sử dụng để tìm kiếm thủ tục tương ứng trong thư viện trong bộ nhớ l Khi tìm thấy, stub sẽ được thay thế với địa chỉ của thủ tục và thực hiện thủ tục l Hữu ích cho xây dựng thư viện Hệ điều hành Chương 3: Quản lý bộ nhớ 1. Tổng quan 1.4 Các cấu trúc chương trình Cấu trúc liên kết động (DLL:Dynamic-link library)"
1e8e6c622bfb571b0b783d8347182318:33,1e8e6c622bfb571b0b783d8347182318,33,34,,,782,"l Modul được chia thành các mức l Mức 0 chứa modul gốc, nạp và định vị chương trình l Mức 1 chứa các Modul được gọi từ những modul ở mức 0 và không đồng thời tồn tại l . . . l Bộ nhớ cũng được chia thành mức ứng với mức chương trình l Kích thước bằng kích thước của modul lớn nhất cùng mức l Để có cấu trúc Overlay, cần cung cấp thêm các thông tin l Chương trình bao nhiêu mức, mỗi mức gồm những modul nào l Thông tin cung cấp lưu trong file (sơ đồ overlay) l Modul mức 0 được biên tập thành file thực thi riêng l Khi thực hiện chương trình l Nạp modul mức 0 như chương trình tuyến tính l Cần tới modul khác, sẽ nạp modul vào mức bộ nhớ tương ứng l Nếu có modul đồng mức tồn tại, đưa ra bên ngoài Chương 3: Quản lý bộ nhớ 1. Tổng quan 1.4 Các cấu trúc chương trình Cấu trúc Overlays"
1e8e6c622bfb571b0b783d8347182318:34,1e8e6c622bfb571b0b783d8347182318,34,35,,,85,Chương 3: Quản lý bộ nhớ 1. Tổng quan 1.4 Các cấu trúc chương trình Cấu trúc Overlays
1e8e6c622bfb571b0b783d8347182318:35,1e8e6c622bfb571b0b783d8347182318,35,36,,,113,M0 80K 80K 120K Bộnhớ trong Chương 3: Quản lý bộ nhớ 1. Tổng quan 1.4 Các cấu trúc chương trình Cấu trúc Overlays
1e8e6c622bfb571b0b783d8347182318:36,1e8e6c622bfb571b0b783d8347182318,36,37,,,116,M0 80K M1 80K 120K Bộnhớ trong Chương 3: Quản lý bộ nhớ 1. Tổng quan 1.4 Các cấu trúc chương trình Cấu trúc Overlays
1e8e6c622bfb571b0b783d8347182318:37,1e8e6c622bfb571b0b783d8347182318,37,38,,,120,M0 80K M1 80K M11 120K Bộnhớ trong Chương 3: Quản lý bộ nhớ 1. Tổng quan 1.4 Các cấu trúc chương trình Cấu trúc Overlays
1e8e6c622bfb571b0b783d8347182318:38,1e8e6c622bfb571b0b783d8347182318,38,39,,,125,80K 80K 120K M0 M1 M11 M11 Bộ nhớ trong Chương 3: Quản lý bộ nhớ 1. Tổng quan 1.4 Các cấu trúc chương trình Cấu trúc Overlays
1e8e6c622bfb571b0b783d8347182318:39,1e8e6c622bfb571b0b783d8347182318,39,40,,,121,M0 80K M1 80K M12 120K Bộ nhớ trong Chương 3: Quản lý bộ nhớ 1. Tổng quan 1.4 Các cấu trúc chương trình Cấu trúc Overlays
1e8e6c622bfb571b0b783d8347182318:40,1e8e6c622bfb571b0b783d8347182318,40,41,,,124,80K 80K 120K M0 M1 M12 M1 Bộ nhớ trong Chương 3: Quản lý bộ nhớ 1. Tổng quan 1.4 Các cấu trúc chương trình Cấu trúc Overlays
1e8e6c622bfb571b0b783d8347182318:41,1e8e6c622bfb571b0b783d8347182318,41,42,,,125,M 1 M0 80K M2 80K M12 120K Bộ nhớ trong Chương 3: Quản lý bộ nhớ 1. Tổng quan 1.4 Các cấu trúc chương trình Cấu trúc Overlays
1e8e6c622bfb571b0b783d8347182318:42,1e8e6c622bfb571b0b783d8347182318,42,43,,,635,"l Cho phép dùng chương trình có kích thước lớn hơn kích thước hệ điều hành dành cho l Yêu cầu người sử dụng cung cấp các thông tin phụ l Hiệu quả sử dụng phụ thuộc vào các thông tin được cung cấp l Hiệu quả sử dụng bộ nhớ phụ thuộc cách tổ chức các modul trong chương trình l Nếu tồn tại một modul có kích thước lớn hơn các modul khác cùng mức rất nhiều ⇒Hiệu quả giảm rõ rệt l Quá trình nạp các modul là động, nhưng chương trình có tính chất tĩnh ⇒Không thay đổi trong các lần thực hiện l Cung cấp thêm bộ nhớ tự do, hiệu quả vẫn không đổi Chương 3: Quản lý bộ nhớ 1. Tổng quan 1.4 Các cấu trúc chương trình Cấu trúc Overlays:Nhận xét"
1e8e6c622bfb571b0b783d8347182318:43,1e8e6c622bfb571b0b783d8347182318,43,44,,,53,34/ 96 Chương 3: Quản lý bộ nhớ 1. Tổng quan Kết luận
1e8e6c622bfb571b0b783d8347182318:44,1e8e6c622bfb571b0b783d8347182318,44,45,,,111,①Tổng quan ②Các chiến lược quản lý bộ nhớ ③Bộ nhớ ảo ④Quản lý bộ nhớ trong VXL họ Intel Chương 3 Quản lý bộ nhớ
1e8e6c622bfb571b0b783d8347182318:45,1e8e6c622bfb571b0b783d8347182318,45,46,,,203,lChiến lược phân chương cố định lChiến lược phân chương động lChiến lược phân đoạn lChiến lược phân trang lChiến lược kết hợp phân đoạn-phân trang Chương 3 Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ
1e8e6c622bfb571b0b783d8347182318:46,1e8e6c622bfb571b0b783d8347182318,46,47,,,528,Hệđiều hành Chương1 Chương2 Chương3 Process Size time P1 120 20 P2 80 15 P3 70 5 P4 50 5 P5 140 12 Hàng đợi l Bộ nhớ được chia thành n phần l Mỗi phần gọi là một chương (partition) l kích thước: không nhất thiết phải bằng nhau l được sử dụng như một vùng nhớ độc lập l Tại một thời điểm chỉ cho phép một chương trình tồn tại l Các chương trình nằm trong vùng nhớ cho tới khi kết thúc l Ví dụ: Xét hệ thống: 0 150 300 500 600 Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.1 Chiến lược phân chương cố định Nguyên tắc
1e8e6c622bfb571b0b783d8347182318:47,1e8e6c622bfb571b0b783d8347182318,47,48,,,660,"l Đơn giản, dễ tổ chức bảo vệ l Chương trình và vùng nhớ có một khóa bảo vệ l So sánh 2 khóa với nhau khi nạp chương trình l Giảm thời gian tìm kiếm l Phải sao các modul điều khiển ra làm nhiều bản và lưu ở nhiều nơi l Hệ số song song không thể vượt quá n l Bị phân đoạn bộ nhớ l Kích thước chương trình lớn hơn kích thước chương lớn nhất l Tổng bộ nhớ tự do còn lớn, nhưng không dùng để nạp các chương trình khác ⇒Sửa lại cấu trúc chương, kết hợp một số chương kề nhau l Áp dụng l Thường dùng cho quản lý các đĩa dung lượng lớn l Hệ điều hành OS/360 của IBM Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.1 Chiến lược phân chương cố định Nhận xét"
1e8e6c622bfb571b0b783d8347182318:48,1e8e6c622bfb571b0b783d8347182318,48,49,,,203,lChiến lược phân chương cố định lChiến lược phân chương động lChiến lược phân đoạn lChiến lược phân trang lChiến lược kết hợp phân đoạn-phân trang Chương 3 Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ
1e8e6c622bfb571b0b783d8347182318:49,1e8e6c622bfb571b0b783d8347182318,49,50,,,748,Chỉ có một danh sách quản lý bộ nhớ tự do l Thời điểm ban đầu toàn bộ bộ nhớ là tự do với các tiến trình ⇒vùng trống lớn nhất (hole) l Khi một tiến trình yêu cầu bộ nhớ l Tìm trong DS vùng trống một phần tử đủ lớn cho yêu cầu l Nếu tìm thấy l Vùng trống được chia thành 2 phần l Một phần cung cấp theo yêu cầu l Một phần trả lại danh sách vùng trống tự do l Nếu không tìm thấy l Phải chờ tới khi có được một vùng trống thỏa mãn l Cho phép tiến trình khác trong hàng đợi thực hiện (nếu độ ưu tiên đảm bảo) l Khi một tiến trình kết thúc l Vùng nhớ chiếm được trả về DS quản lý vùng trống tự do l Kết hợp với các vùng trống khác liên kề nếu cần thiết Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.2 Chiến lược phân chương động Nguyên tắc
1e8e6c622bfb571b0b783d8347182318:50,1e8e6c622bfb571b0b783d8347182318,50,51,,,228,0 400 2560 Process Size time P1 600 10 P2 1000 5 P3 300 20 P4 700 8 P5 500 15 File đợi 0 400 2560 ? Hệ điều hành Hệ điều hành Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.2 Chiến lược phân chương động Bộ nhớ chính
1e8e6c622bfb571b0b783d8347182318:51,1e8e6c622bfb571b0b783d8347182318,51,52,,,297,Có nhiều chiến lược lựa chọn vùng trống cho yêu cầu First Fit : Vùng trống đầu tiên thỏa mãn Best Fit : Vùng trống vừa vặn nhất Worst Fit : Vùng trống kích thước lớn nhất Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.2 Chiến lược phân chương động Chiến lược lựa chọn vùng trống tự do
1e8e6c622bfb571b0b783d8347182318:52,1e8e6c622bfb571b0b783d8347182318,52,53,,,322,"l Giả sử các vùng bộ nhớ còn trống có kích thước 100K, 500K, 200K, 300K, and 600K (theo thứ tự), l First-fit, Best-fit, and Worst-fit Sẽ nạp các tiến trình 212K, 417K, 112K, and 426K như thế nào? Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.2 Chiến lược phân chương động Chiến lược lựa chọn vùng trống tự do"
1e8e6c622bfb571b0b783d8347182318:53,1e8e6c622bfb571b0b783d8347182318,53,54,,,470,Nguyên tắc: Chia đôi liên tiếp vùng trống tự do cho tới khi thu được vùng trống nhỏ nhất thỏa mãn Cung cấp cho yêu cầu n bytes l Chia vùng trống tìm được thành 2 khối bằng nhau (gọi là buddies) l Tiếp tục chia vùng trống phía trên thành 2 phần cho tới khi đạt vùng trống nhỏ nhất kích thước lớn hơn n Ví dụ l Vùng trống 16K Bytes l Yêu cầu 735 Bytes Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.2 Chiến lược phân chương động Buddy Allocation: Cung cấp nhớ
1e8e6c622bfb571b0b783d8347182318:54,1e8e6c622bfb571b0b783d8347182318,54,55,,,470,Nguyên tắc: Chia đôi liên tiếp vùng trống tự do cho tới khi thu được vùng trống nhỏ nhất thỏa mãn Cung cấp cho yêu cầu n bytes l Chia vùng trống tìm được thành 2 khối bằng nhau (gọi là buddies) l Tiếp tục chia vùng trống phía trên thành 2 phần cho tới khi đạt vùng trống nhỏ nhất kích thước lớn hơn n Ví dụ l Vùng trống 16K Bytes l Yêu cầu 735 Bytes Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.2 Chiến lược phân chương động Buddy Allocation: Cung cấp nhớ
1e8e6c622bfb571b0b783d8347182318:55,1e8e6c622bfb571b0b783d8347182318,55,56,,,470,Nguyên tắc: Chia đôi liên tiếp vùng trống tự do cho tới khi thu được vùng trống nhỏ nhất thỏa mãn Cung cấp cho yêu cầu n bytes l Chia vùng trống tìm được thành 2 khối bằng nhau (gọi là buddies) l Tiếp tục chia vùng trống phía trên thành 2 phần cho tới khi đạt vùng trống nhỏ nhất kích thước lớn hơn n Ví dụ l Vùng trống 16K Bytes l Yêu cầu 735 Bytes Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.2 Chiến lược phân chương động Buddy Allocation: Cung cấp nhớ
1e8e6c622bfb571b0b783d8347182318:56,1e8e6c622bfb571b0b783d8347182318,56,57,,,470,Nguyên tắc: Chia đôi liên tiếp vùng trống tự do cho tới khi thu được vùng trống nhỏ nhất thỏa mãn Cung cấp cho yêu cầu n bytes l Chia vùng trống tìm được thành 2 khối bằng nhau (gọi là buddies) l Tiếp tục chia vùng trống phía trên thành 2 phần cho tới khi đạt vùng trống nhỏ nhất kích thước lớn hơn n Ví dụ l Vùng trống 16K Bytes l Yêu cầu 735 Bytes Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.2 Chiến lược phân chương động Buddy Allocation: Cung cấp nhớ
1e8e6c622bfb571b0b783d8347182318:57,1e8e6c622bfb571b0b783d8347182318,57,58,,,470,Nguyên tắc: Chia đôi liên tiếp vùng trống tự do cho tới khi thu được vùng trống nhỏ nhất thỏa mãn Cung cấp cho yêu cầu n bytes l Chia vùng trống tìm được thành 2 khối bằng nhau (gọi là buddies) l Tiếp tục chia vùng trống phía trên thành 2 phần cho tới khi đạt vùng trống nhỏ nhất kích thước lớn hơn n Ví dụ l Vùng trống 16K Bytes l Yêu cầu 735 Bytes Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.2 Chiến lược phân chương động Buddy Allocation: Cung cấp nhớ
1e8e6c622bfb571b0b783d8347182318:58,1e8e6c622bfb571b0b783d8347182318,58,59,,,470,Nguyên tắc: Chia đôi liên tiếp vùng trống tự do cho tới khi thu được vùng trống nhỏ nhất thỏa mãn Cung cấp cho yêu cầu n bytes l Chia vùng trống tìm được thành 2 khối bằng nhau (gọi là buddies) l Tiếp tục chia vùng trống phía trên thành 2 phần cho tới khi đạt vùng trống nhỏ nhất kích thước lớn hơn n Ví dụ l Vùng trống 16K Bytes l Yêu cầu 735 Bytes Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.2 Chiến lược phân chương động Buddy Allocation: Cung cấp nhớ
1e8e6c622bfb571b0b783d8347182318:59,1e8e6c622bfb571b0b783d8347182318,59,60,,,448,"l Hệ thống duy trì các danh sách vùng trống kích thước 1, 2, . . . , 2n bytes l Với yêu cầu K, tìm phần tử nhỏ nhất kích thước lớn hơn K l Nếu phần tử nhỏ nhất lớn hơn 2K, chia liên tiếp tới khi được vùng nhỏ nhất kích thước lớn hơn K l Nhận xét: Với bộ nhớ kích thước n, cần duyệt log2n danh sách ⇒Nhanh Ví dụ bộ nhớ 16K bytes Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.2 Chiến lược phân chương động Buddy Allocation: Cung cấp nhớ"
1e8e6c622bfb571b0b783d8347182318:60,1e8e6c622bfb571b0b783d8347182318,60,61,,,468,"l Hệ thống duy trì các danh sách vùng trống kích thước 1, 2, . . . , 2n bytes l Với yêu cầu K, tìm phần tử nhỏ nhất kích thước lớn hơn K l Nếu phần tử nhỏ nhất lớn hơn 2K, chia liên tiếp tới khi được vùng nhỏ nhất kích thước lớn hơn K l Nhận xét: Với bộ nhớ kích thước n, cần duyệt log2n danh sách ⇒Nhanh Ví dụ bộ nhớ 16K bytes l Yêu cầu 735 bytes Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.2 Chiến lược phân chương động Buddy Allocation: Cung cấp nhớ"
1e8e6c622bfb571b0b783d8347182318:61,1e8e6c622bfb571b0b783d8347182318,61,62,,,489,"l Hệ thống duy trì các danh sách vùng trống kích thước 1, 2, . . . , 2n bytes l Với yêu cầu K, tìm phần tử nhỏ nhất kích thước lớn hơn K l Nếu phần tử nhỏ nhất lớn hơn 2K, chia liên tiếp tới khi được vùng nhỏ nhất kích thước lớn hơn K l Nhận xét: Với bộ nhớ kích thước n, cần duyệt log2n danh sách ⇒Nhanh Ví dụ bộ nhớ 16K bytes l Yêu cầu 735 bytes l Yêu cầu 1205 bytes Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.2 Chiến lược phân chương động Buddy Allocation: Cung cấp nhớ"
1e8e6c622bfb571b0b783d8347182318:62,1e8e6c622bfb571b0b783d8347182318,62,63,,,510,"l Hệ thống duy trì các danh sách vùng trống kích thước 1, 2, . . . , 2n bytes l Với yêu cầu K, tìm phần tử nhỏ nhất kích thước lớn hơn K l Nếu phần tử nhỏ nhất lớn hơn 2K, chia liên tiếp tới khi được vùng nhỏ nhất kích thước lớn hơn K l Nhận xét: Với bộ nhớ kích thước n, cần duyệt log2n danh sách ⇒Nhanh Ví dụ bộ nhớ 16K bytes l Yêu cầu 735 bytes l Yêu cầu 1205 bytes l Yêu cầu 2010 bytes Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.2 Chiến lược phân chương động Buddy Allocation: Cung cấp nhớ"
1e8e6c622bfb571b0b783d8347182318:63,1e8e6c622bfb571b0b783d8347182318,63,64,,,257,l Có thể kết hợp 2 vùng kề nhau có cùng kích thước l Tiếp tục kết hợp liên tiếp cho tới khi tạo ra vùng trống lớn nhất có thể Ví dụ Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.2 Chiến lược phân chương động Buddy Allocation : Thu hồi vùng nhớ
1e8e6c622bfb571b0b783d8347182318:64,1e8e6c622bfb571b0b783d8347182318,64,65,,,293,l Có thể kết hợp 2 vùng kề nhau có cùng kích thước l Tiếp tục kết hợp liên tiếp cho tới khi tạo ra vùng trống lớn nhất có thể Ví dụ l Giải phóng vùng nhớ thứ nhất (1K) Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.2 Chiến lược phân chương động Buddy Allocation : Thu hồi vùng nhớ
1e8e6c622bfb571b0b783d8347182318:65,1e8e6c622bfb571b0b783d8347182318,65,66,,,327,l Có thể kết hợp 2 vùng kề nhau có cùng kích thước l Tiếp tục kết hợp liên tiếp cho tới khi tạo ra vùng trống lớn nhất có thể Ví dụ l Giải phóng vùng nhớ thứ nhất (1K) l Kết hợp 2 vùng 1K thành vùng 2K Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.2 Chiến lược phân chương động Buddy Allocation : Thu hồi vùng nhớ
1e8e6c622bfb571b0b783d8347182318:66,1e8e6c622bfb571b0b783d8347182318,66,67,,,362,l Có thể kết hợp 2 vùng kề nhau có cùng kích thước l Tiếp tục kết hợp liên tiếp cho tới khi tạo ra vùng trống lớn nhất có thể Ví dụ l Giải phóng vùng nhớ thứ nhất (1K) l Kết hợp 2 vùng 1K thành vùng 2K l Giải phóng vùng nhớ thứ hai (2K) Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.2 Chiến lược phân chương động Buddy Allocation : Thu hồi vùng nhớ
1e8e6c622bfb571b0b783d8347182318:67,1e8e6c622bfb571b0b783d8347182318,67,68,,,396,l Có thể kết hợp 2 vùng kề nhau có cùng kích thước l Tiếp tục kết hợp liên tiếp cho tới khi tạo ra vùng trống lớn nhất có thể Ví dụ l Giải phóng vùng nhớ thứ nhất (1K) l Kết hợp 2 vùng 1K thành vùng 2K l Giải phóng vùng nhớ thứ hai (2K) l Kết hợp 2 vùng 2K thành vùng 4K Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.2 Chiến lược phân chương động Buddy Allocation : Thu hồi vùng nhớ
1e8e6c622bfb571b0b783d8347182318:68,1e8e6c622bfb571b0b783d8347182318,68,69,,,430,l Có thể kết hợp 2 vùng kề nhau có cùng kích thước l Tiếp tục kết hợp liên tiếp cho tới khi tạo ra vùng trống lớn nhất có thể Ví dụ l Giải phóng vùng nhớ thứ nhất (1K) l Kết hợp 2 vùng 1K thành vùng 2K l Giải phóng vùng nhớ thứ hai (2K) l Kết hợp 2 vùng 2K thành vùng 4K l Giải phóng vùng nhớ thứ ba (2K) Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.2 Chiến lược phân chương động Buddy Allocation : Thu hồi vùng nhớ
1e8e6c622bfb571b0b783d8347182318:69,1e8e6c622bfb571b0b783d8347182318,69,70,,,464,l Có thể kết hợp 2 vùng kề nhau có cùng kích thước l Tiếp tục kết hợp liên tiếp cho tới khi tạo ra vùng trống lớn nhất có thể Ví dụ l Giải phóng vùng nhớ thứ nhất (1K) l Kết hợp 2 vùng 1K thành vùng 2K l Giải phóng vùng nhớ thứ hai (2K) l Kết hợp 2 vùng 2K thành vùng 4K l Giải phóng vùng nhớ thứ ba (2K) l Kết hợp 2 vùng 2K thành vùng 4K Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.2 Chiến lược phân chương động Buddy Allocation : Thu hồi vùng nhớ
1e8e6c622bfb571b0b783d8347182318:70,1e8e6c622bfb571b0b783d8347182318,70,71,,,498,l Có thể kết hợp 2 vùng kề nhau có cùng kích thước l Tiếp tục kết hợp liên tiếp cho tới khi tạo ra vùng trống lớn nhất có thể Ví dụ l Giải phóng vùng nhớ thứ nhất (1K) l Kết hợp 2 vùng 1K thành vùng 2K l Giải phóng vùng nhớ thứ hai (2K) l Kết hợp 2 vùng 2K thành vùng 4K l Giải phóng vùng nhớ thứ ba (2K) l Kết hợp 2 vùng 2K thành vùng 4K l Kết hợp 2 vùng 4K thành vùng 8K Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.2 Chiến lược phân chương động Buddy Allocation : Thu hồi vùng nhớ
1e8e6c622bfb571b0b783d8347182318:71,1e8e6c622bfb571b0b783d8347182318,71,72,,,533,l Có thể kết hợp 2 vùng kề nhau có cùng kích thước l Tiếp tục kết hợp liên tiếp cho tới khi tạo ra vùng trống lớn nhất có thể Ví dụ l Giải phóng vùng nhớ thứ nhất (1K) l Kết hợp 2 vùng 1K thành vùng 2K l Giải phóng vùng nhớ thứ hai (2K) l Kết hợp 2 vùng 2K thành vùng 4K l Giải phóng vùng nhớ thứ ba (2K) l Kết hợp 2 vùng 2K thành vùng 4K l Kết hợp 2 vùng 4K thành vùng 8K l Kết hợp 2 vùng 8K thành vùng 16K Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.2 Chiến lược phân chương động Buddy Allocation : Thu hồi vùng nhớ
1e8e6c622bfb571b0b783d8347182318:72,1e8e6c622bfb571b0b783d8347182318,72,73,,,941,"Sau một thời gian hoạt động, các vùng trống nằm rải rác khắp nơi gây ra hiện tượng thiếu bộ nhớ. ⇒Cần phải bố trí lại bộ nhớ l Dịch chuyển các tiến trình l Vấn đề không đơn giản vì các đối tượng bên trong khi chuyển sang vị trí mới sẽ mang địa chỉ khác đi l Sử dụng thanh ghi dịch chuyển (relocation register) chứa giá trị bằng độ dịch chuyển của tiến trình l Vấn đề lựa chọn phương pháp để chi phí nhỏ nhất l Dịch chuyển tất cả về một phía ⇒vùng trống lớn nhất l Dịch chuyển để tạo ra ngay lập tức một vùng trống vừa vặn l Phương pháp tráo đổi (swapping) l Lựa chọn thời điểm dừng tiến trình đang thực hiện l Đưa tiến trình và trạng thái tương ứng ra bên ngoài l Giải phóng vùng nhớ để kết hợp với các phần tử liền kề l Tái định vị vào vị trí cũ và khôi phục trạng thái cũ l Dùng thanh ghi dịch chuyển nếu đưa vào vị trí khác Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.2 Chiến lược phân chương động Vấn đề bố trí lại bộ nhớ"
1e8e6c622bfb571b0b783d8347182318:73,1e8e6c622bfb571b0b783d8347182318,73,74,,,680,"l Không phải sao lưu modul điều khiển ra nhiều nơi l Tăng/giảm hệ số song song tùy theo số lượng và kích thước chương trình l Không thực hiện được chương trình có kích thước lớn hơn kích thước bộ nhớ vật lý l Gây ra hiện tượng rác l Bộ nhớ không được sử dụng, nhưng cũng không nằm trong DS quản lý bộ nhớ tự do l Do lỗi hệ điều hành l Do phần mềm phá hoại l Gây ra hiện tượng phân đoạn ngoài l Vùng nhớ tự do được quản lý đầy đủ, nhưng nằm rải rác nên không sử dụng được l Gây ra hiện tượng phân đoạn trong l Vùng nhớ dành cho chương trình nhưng không được chương trình sử dụng tới Nhận xét Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.2 Chiến lược phân chương động"
1e8e6c622bfb571b0b783d8347182318:74,1e8e6c622bfb571b0b783d8347182318,74,75,,,203,lChiến lược phân chương cố định lChiến lược phân chương động lChiến lược phân đoạn lChiến lược phân trang lChiến lược kết hợp phân đoạn-phân trang Chương 3 Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ
1e8e6c622bfb571b0b783d8347182318:75,1e8e6c622bfb571b0b783d8347182318,75,76,,,657,"l Chương trình thường gồm các modul l Một chương trình chính (main program) l Tập các chương trình con l Các biến, các cấu trúc dữ liệu,. . . l Các modul, đối tượng trong c/trình được xác định bằng tên l Hàm sqrt(), thủ tục printf() . . . l x, y, counter, Buffer. . . l Các p/tử trong modul được x/định theo độ lệch với vị trí đầu l Câu lệnh thư 10 của hàm sqrt(). . . l Phần tử thứ 2 của mảng Buffer. . . Chương trình được tổ chức như thế nào trong bộ nhớ? l Stack nằm trên hay Data nằm trên trong bộ nhớ? l Địa chỉ vật lý các đối tượng . . . ? ⇒Không quan tâm Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.3 Chiến lược phân đoạn Chương trình"
1e8e6c622bfb571b0b783d8347182318:76,1e8e6c622bfb571b0b783d8347182318,76,77,,,510,"subroutines array main program data stack Không gian địa chỉ logic Khi đưa c/trình vào bộ nhớ để thực hiện C/trình gồm nhiều đoạn khác nhau l Mỗi đoạn là một khối logic, ứng với một modul l Mã lệnh: main(), thủ tục, hàm. . . l Dữ liệu: Đối tượng toàn cục, cục bộ l Các đoạn khác: stack, mảng. . . l Mỗi đoạn chiếm một vùng liên tục l Có vị trí bắt đầu và kích thước l Có thể nằm tại bất cứ đâu trong bộ nhớ Quan điểm người dùng Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.3 Chiến lược phân đoạn"
1e8e6c622bfb571b0b783d8347182318:77,1e8e6c622bfb571b0b783d8347182318,77,78,,,624,"Khi đưa c/trình vào bộ nhớ để thực hiện C/trình gồm nhiều đoạn khác nhau l Mỗi đoạn là một khối logic, ứng với một modul l Mã lệnh: main(), thủ tục, hàm. . . l Dữ liệu: Đối tượng toàn cục, cục bộ l Các đoạn khác: stack, mảng. . . l Mỗi đoạn chiếm một vùng liên tục l Có vị trí bắt đầu và kích thước l Có thể nằm tại bất cứ đâu trong bộ nhớ l Đối tượng trong đoạn được xác định bởi vị trí tương đối so với đầu đoạn l Lệnh thứ 5 của chương trình chính l Phần tử đầu tiên của stack. . . l Vị trí các đối tượng trong bộ nhớ? Quan điểm người dùng Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.3 Chiến lược phân đoạn"
1e8e6c622bfb571b0b783d8347182318:78,1e8e6c622bfb571b0b783d8347182318,78,79,,,200,subroutine Đoạn 2 array Đoạn 3 main program Đoạn 0 data Đoạn 4 stack Đoạn 1 Ví dụ Không gian địa chỉ logic Bộ nhớ HĐH Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.3 Chiến lược phân đoạn
1e8e6c622bfb571b0b783d8347182318:79,1e8e6c622bfb571b0b783d8347182318,79,80,,,224,subroutine Đoạn 2 array Đoạn 3 main program Đoạn 0 data Đoạn 4 stack Đoạn 1 HĐH Đoạn 0 Đoạn 3 1400 4300 Ví dụ Không gian địa chỉ logic Bộ nhớ Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.3 Chiến lược phân đoạn
1e8e6c622bfb571b0b783d8347182318:80,1e8e6c622bfb571b0b783d8347182318,80,81,,,165,HĐH Đoạn 0 1400 4300 Ví dụ Bộ nhớ Lệnh thứ 5 P/tử thứ 11 5x4 11x2 Đoạn 3 1420 4322 Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.3 Chiến lược phân đoạn
1e8e6c622bfb571b0b783d8347182318:81,1e8e6c622bfb571b0b783d8347182318,81,82,,,712,"Mark Address Length . . . . . . . . . . . . . . . . . . Cấu trúc phân đoạn Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.3 Chiến lược phân đoạn 0 ... n l Chương trình là tập hợp các đoạn (modul,segment) l Tên đoạn (số hiệu đoạn), độ dài của đoạn l Mỗi đoạn có thể được biên tập riêng. l Dịch và biên tập chương trình tạo ra bảng quản lý đoạn (SCB: Segement Control Block) l Mỗi phần tử của bảng ứng với một đoạn của chương trình l Dấu hiệu (Mark(0/1)): Đoạn đã tồn tại trong bộ nhớ l Địa chỉ (Address): Vị trí cơ sở (base) của đoạn trong bộ nhớ l Độ dài (Length): Độ dài của đoạn l Địa chỉ truy nhập: tên (số hiệu) đoạn và độ lệch trong đoạn Vấn đề: Chuyển đổi từ địa chỉ 2 chiều ⇒địa chỉ một chiều"
1e8e6c622bfb571b0b783d8347182318:82,1e8e6c622bfb571b0b783d8347182318,82,83,,,253,subroutine Đoạn 2 array Đoạn 3 main program Đoạn 0 data Đoạn 4 stack Đoạn 1 Ví dụ Không gian địa chỉ logic Bộ nhớ HĐH Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.3 Chiến lược phân đoạn M A L 0 - 1000 0 - 400 0 - 400 0 - 1100 0 - 1000 SCB
1e8e6c622bfb571b0b783d8347182318:83,1e8e6c622bfb571b0b783d8347182318,83,84,,,333,subroutine Đoạn 2 array Đoạn 3 main program Đoạn 0 data Đoạn 4 stack Đoạn 1 Ví dụ Không gian địa chỉ logic Bộ nhớ HĐH Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.3 Chiến lược phân đoạn M A L 1 1400 1000 1 6300 400 0 - 400 1 3200 1100 1 4700 1000 SCB Đoạn 0 Đoạn 3 Đoạn 4 Đoạn 1 1400 2400 3200 4300 4700 5700 6300 6700
1e8e6c622bfb571b0b783d8347182318:84,1e8e6c622bfb571b0b783d8347182318,84,85,,,402,"subroutine Đoạn 2 array Đoạn 3 main program Đoạn 0 data Đoạn 4 stack Đoạn 1 Ví dụ Không gian địa chỉ logic Bộ nhớ HĐH Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.3 Chiến lược phân đoạn M A L 1 1400 1000 1 6300 400 0 - 400 1 3200 1100 1 4700 1000 SCB Đoạn 0 Đoạn 3 Đoạn 4 Đoạn 1 1400 2400 3200 4300 4700 5700 6300 6700 Địa chỉ <3,345> = ? Đoạn 3 bắt đầu tại 3200 P/tử 345 Offset 345 3545"
1e8e6c622bfb571b0b783d8347182318:85,1e8e6c622bfb571b0b783d8347182318,85,86,,,357,"subroutine Đoạn 2 array Đoạn 3 main program Đoạn 0 data Đoạn 4 stack Đoạn 1 Ví dụ Không gian địa chỉ logic Bộ nhớ HĐH Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.3 Chiến lược phân đoạn M A L 1 1400 1000 1 6300 400 0 - 400 1 3200 1100 1 4700 1000 SCB Đoạn 0 Đoạn 3 Đoạn 4 Đoạn 1 1400 2400 3200 4300 4700 5700 6300 6700 Địa chỉ <4,185> = ?4885"
1e8e6c622bfb571b0b783d8347182318:86,1e8e6c622bfb571b0b783d8347182318,86,87,,,377,"subroutine Đoạn 2 array Đoạn 3 main program Đoạn 0 data Đoạn 4 stack Đoạn 1 Ví dụ Không gian địa chỉ logic Bộ nhớ HĐH Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.3 Chiến lược phân đoạn M A L 1 1400 1000 1 6300 400 0 - 400 1 3200 1100 1 4700 1000 SCB Đoạn 0 Đoạn 3 Đoạn 4 Đoạn 1 1400 2400 3200 4300 4700 5700 6300 6700 Địa chỉ <2,120> = ? Jmp <2:120> Đoạn 2 2800"
1e8e6c622bfb571b0b783d8347182318:87,1e8e6c622bfb571b0b783d8347182318,87,88,,,380,"subroutine Đoạn 2 array Đoạn 3 main program Đoạn 0 data Đoạn 4 stack Đoạn 1 Ví dụ Không gian địa chỉ logic Bộ nhớ HĐH Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.3 Chiến lược phân đoạn M A L 1 1400 1000 1 6300 400 1 2800 400 1 3200 1100 1 4700 1000 SCB Đoạn 0 Đoạn 3 Đoạn 4 Đoạn 1 1400 2400 3200 4300 4700 5700 6300 6700 Địa chỉ <2,120> = ? Jmp <2:120> Đoạn 2 2800"
1e8e6c622bfb571b0b783d8347182318:88,1e8e6c622bfb571b0b783d8347182318,88,89,,,383,"subroutine Đoạn 2 array Đoạn 3 main program Đoạn 0 data Đoạn 4 stack Đoạn 1 Ví dụ Không gian địa chỉ logic Bộ nhớ HĐH Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.3 Chiến lược phân đoạn M A L 1 1400 1000 1 6300 400 1 2800 400 1 3200 1100 1 4700 1000 SCB Đoạn 0 Đoạn 3 Đoạn 4 Đoạn 1 1400 2400 3200 4300 4700 5700 6300 6700 Địa chỉ <2,120> = 2920 Jmp <2:120> Đoạn 2 2800"
1e8e6c622bfb571b0b783d8347182318:89,1e8e6c622bfb571b0b783d8347182318,89,90,,,395,"subroutine Đoạn 2 array Đoạn 3 main program Đoạn 0 data Đoạn 4 stack Đoạn 1 Ví dụ Không gian địa chỉ logic Bộ nhớ HĐH Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.3 Chiến lược phân đoạn M A L 1 1400 1000 1 6300 400 1 2800 400 1 3200 1100 1 4700 1000 SCB Đoạn 0 Đoạn 3 Đoạn 4 Đoạn 1 1400 2400 3200 4300 4700 5700 6300 6700 Địa chỉ <2,450> = ? Jmp <2:120> Đoạn 2 2800 Lỗi truy nhập!"
1e8e6c622bfb571b0b783d8347182318:90,1e8e6c622bfb571b0b783d8347182318,90,91,,,889,"Chuyển đổi địa chỉ Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.3 Chiến lược phân đoạn l Khi thực hiện chương trình l Bảng quản lý đoạn được nạp vào bộ nhớ l STBR (Segment-table base register): Vị trí SCB trong bộ nhớ l STLR (Segment-table length register): Số phần tử của SCB l Truy nhập tới địa chỉ logic < s, d > ① s ≥ STLR : Lỗi ② STBR + s * K : Vị trí phần tử s trong SCB ③ Kiểm tra trường dấu hiệu M của phần tử SCBs l M = 0: Đoạn s chưa tồn tại trong bộ nhớ ⇒Lỗi truy nhập ⇒Hệ điều hành phải nạp đoạn l Xin vùng nhớ có kích thước được ghi trong trường L l Tìm modul tương ứng ở bộ nhớ ngoài và nạp và định vị vào vùng nhớ xin được l Sửa lại trường địa chỉ A và trường dấu hiệu M(M = 1) l Truy nhập bộ nhớ như trường hợp không gặp lỗi truy nhập l M = 1 :Đoạn s đã tồn tại trong bộ nhớ l d ≥ Ls: Lỗi truy nhập (vượt quá kích thước đoạn) l d + As: Địa chỉ vật lý cần tìm"
1e8e6c622bfb571b0b783d8347182318:91,1e8e6c622bfb571b0b783d8347182318,91,92,,,118,Chuyển đổi địa chỉ: Sơ đồ truy nhập Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.3 Chiến lược phân đoạn
1e8e6c622bfb571b0b783d8347182318:92,1e8e6c622bfb571b0b783d8347182318,92,93,,,561,Tiến trình 1 Data (Read only) sqrt() S0 S3 S0 Nhận xét: ưu điểm Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.3 Chiến lược phân đoạn l Sơ đồ nạp modul không cần sự tham gia của người sử dụng l Dễ dàng thực hiện nhiệm vụ bảo vệ đoạn l Kiểm tra lỗi truy nhập bộ nhớ l Địa chỉ không hợp lệ :vươt quá kích thước đoạn l Kiểm tra tính chất truy nhập l Đoạn mã: chỉ đọc -> Viết vào đoạn mã: lỗi truy nhập l Kiểm tra quyền truy nhập modul l Thêm trường quyền truy nhập(user/system) vào SCB l Cho phép sử dụng chung đoạn (VD Soạn thảo văn bản) Tiến trình 2
1e8e6c622bfb571b0b783d8347182318:93,1e8e6c622bfb571b0b783d8347182318,93,94,,,290,"Dùng chung đoạn : Vấn đề chính Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.3 Chiến lược phân đoạn l Đoạn dùng chung phải cùng số hiệu trong SCB l Call (0, 120) ? l Read (1, 245) ? l Giải quyết bằng cách truy nhập gián tiếp l JMP + 08 l Thanh ghi đoạn chứa số hi đoạn (ES:BX)"
1e8e6c622bfb571b0b783d8347182318:94,1e8e6c622bfb571b0b783d8347182318,94,95,,,695,"Nhận xét : Nhược điểm Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.3 Chiến lược phân đoạn l Hiệu quả sử dụng phụ thuộc vào cấu trúc chương trình l Bị phân mảnh bộ nhớ l Phân phối vùng nhớ theo các chiến lược first fit /best fit... l Cần phải bố trí lại bộ nhớ (dịch chuyển, swapping) l Có thể dựa vào bảng SCB l M ←0 : Đoạn chưa được nạp vào l Vùng nhớ được xác định bởi A và L được trả về DS tự do l Vấn đề lựa chọn modul cần đưa ra l Đưa ra modul tồn tại lâu nhất l Đưa ra modul có lần sử dụng cuối cách xa nhất l Đưa ra modul có tần xuất sử dụng thấp nhất ⇒Cần phương tiên ghi lại số lần và thời điểm truy nhập đoạn l Giải pháp: phân phối bộ nhớ theo các đoạn bằng nhau (page)?"
1e8e6c622bfb571b0b783d8347182318:95,1e8e6c622bfb571b0b783d8347182318,95,96,,,203,lChiến lược phân chương cố định lChiến lược phân chương động lChiến lược phân đoạn lChiến lược phân trang lChiến lược kết hợp phân đoạn-phân trang Chương 3 Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ
1e8e6c622bfb571b0b783d8347182318:96,1e8e6c622bfb571b0b783d8347182318,96,97,,,932,"Nguyên tắc Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.4 Chiến lược phân trang l Bộ nhớ vật lý được chia thành từng khối có kích thước bằng nhau: trang vật lý (frames – khung trang) l Trang vật lý được đánh số 0, 1, 2, . . . : địa chỉ vật lý của trang l Trang được dùng làm đơn vị phân phối nhớ l Bộ nhớ logic (chương trình) được chia thành từng trang có kích thước bằng trang vật lý: trang logic (pages) l Khi thực hiện chương trình l Nạp trang logic (từ bộ nhớ ngoài) vào trang vật lý l Xây dựng một bảng quản lý trang (PCB: Page Control Block) dùng để xác định mối quan hệ giữa trang vật lý và trang logic l Mỗi phần tử của PCB ứng với một trang chương trình l Cho biết trang vật lý chứa trang logic tương ứng l Ví dụ PCB[8] = 4 ⇒? l Địa chỉ truy nhập được chia thành l Số hiệu trang (p) : Chỉ số trong PCB để tìm đ/chỉ cơ sở trang l Độ lệch trong trang (d): Kết hợp địa chỉ cơ sở của trang để tìm ra đ/chỉ vật lý"
1e8e6c622bfb571b0b783d8347182318:97,1e8e6c622bfb571b0b783d8347182318,97,98,,,196,6 5 4 3 2 1 0 3 2 1 0 Trang0 Trang1 Trang2 Trang3 Ví dụ Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.4 Chiến lược phân trang 7 Bộ nhớ logic Bộ nhớ vật lý 2 1 6 5 0 1 2 3 PCB Trang 0
1e8e6c622bfb571b0b783d8347182318:98,1e8e6c622bfb571b0b783d8347182318,98,99,,,196,6 5 4 3 2 1 0 3 2 1 0 Trang0 Trang1 Trang2 Trang3 Ví dụ Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.4 Chiến lược phân trang 7 Bộ nhớ logic Bộ nhớ vật lý 2 1 6 5 0 1 2 3 PCB Trang 1
1e8e6c622bfb571b0b783d8347182318:99,1e8e6c622bfb571b0b783d8347182318,99,100,,,196,6 5 4 3 2 1 0 3 2 1 0 Trang0 Trang1 Trang2 Trang3 Ví dụ Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.4 Chiến lược phân trang 7 Bộ nhớ logic Bộ nhớ vật lý 2 1 6 5 0 1 2 3 PCB Trang 2
1e8e6c622bfb571b0b783d8347182318:100,1e8e6c622bfb571b0b783d8347182318,100,101,,,196,6 5 4 3 2 1 0 3 2 1 0 Trang0 Trang1 Trang2 Trang3 Ví dụ Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.4 Chiến lược phân trang 7 Bộ nhớ logic Bộ nhớ vật lý 2 1 6 5 0 1 2 3 PCB Trang 3
1e8e6c622bfb571b0b783d8347182318:101,1e8e6c622bfb571b0b783d8347182318,101,102,,,791,"Ghi chú Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.4 Chiến lược phân trang l Dung lượng trang luôn là lũy thừa của 2 l Cho phép ghép giữa số hiệu trang vật lý và độ lệch trong trang l Ví dụ: Bộ nhớ n bit, kích thước trang 2k số hiệu trang độ lệch l Không cần thiết nạp toàn bộ trang logic vào l Số trang vật lý phụ thuộc k/thước bộ nhớ, số trang logic tùy ý l PCB cần trường dấu hiệu (Mark) cho biết trang đã được nạp vào bộ nhớ chưa l M = 0 Trang chưa tồn tại l M = 1 Trang đã được đưa vào bộ nhớ vật lý l Phân biệt chiến lược phân trang - phân đoạn l Chiến lược phân đoạn l Các modul phụ thuộc cấu trúc logic của chương trình l Chiến lược phân trang l Các khối có kích thước độc lập kích thước chương trình l Kích thước khối phụ thuộc phần cứng (VD: 29 →213 bytes) n − k k"
1e8e6c622bfb571b0b783d8347182318:102,1e8e6c622bfb571b0b783d8347182318,102,103,,,241,"Ví dụ Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.4 Chiến lược phân trang Bộ nhớ vật lý 2 1 6 5 0 1 2 3 PCB Bộ nhớ logic Truy nhập địa chỉ logic [ 6 ] ? Địa chỉ [ 6 ]: Trang 1, độ lệch 2 Địa chỉ <1,2> = 6*4 + 2 = 26 (624) g g"
1e8e6c622bfb571b0b783d8347182318:103,1e8e6c622bfb571b0b783d8347182318,103,104,,,225,Thực hiện chương trình →Nạp chương trình vào bộ nhớ Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.4 Chiến lược phân trang l Nếu đủ trang vật lý tự do ⇒nạp toàn bộ l Nếu không đủ trang vật lý tự do ⇒nạp từng phần
1e8e6c622bfb571b0b783d8347182318:104,1e8e6c622bfb571b0b783d8347182318,104,105,,,731,"Thực hiện chương trình →Truy nhập bộ nhớ Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.4 Chiến lược phân trang l Nạp chương trình l Xây dựng bảng quản lý trang và luôn giữ trong bộ nhớ l PTBR (Page-table base register) trỏ tới PCB. l PTLR(Page-table length register) kích thước PCB. l Thực hiện truy nhập l Địa chỉ truy nhập được chia thành dạng <p, d> l PTBR + p ∗K : Địa chỉ phần tử p của PCB trong bộ nhớ l K Kích thước 1 phần tử của PCB l Kiểm tra Mp l Mp = 0 : Lỗi trang, sinh một ngắt để tiến hành nạp trang l Xin trang vật lý tự do (Hết trang tự do?) l Tìm kiếm trang logic ở bộ nhớ ngoài và nạp trang l Sửa lại trường địa chỉ A và dấu hiệu M l Mp = 1 : Trang đã tồn tại, l Lấy Ap ghép với d ra địa chỉ cần tìm"
1e8e6c622bfb571b0b783d8347182318:105,1e8e6c622bfb571b0b783d8347182318,105,106,,,126,65/ 96 Chuyển đổi địa chỉ: Sơ đồ truy nhập Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.4 Chiến lược phân trang
1e8e6c622bfb571b0b783d8347182318:106,1e8e6c622bfb571b0b783d8347182318,106,107,,,653,Nạp trang và thay thế trang Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.4 Chiến lược phân trang l Nhận xét l Số trang vật lý dành cho chương trình lớn l Thực hiện nhanh nhưng hệ số song song giảm l Số trang vật lý dành cho chương trình bé l Hệ số song song cao nhưng thực hiện chậm do hay thiếu trang ⇒Hiệu quả phụ thuộc các chiến lược nạp trang và thay thế trang l Các chiến lược nạp trang l Nạp tất cả: Nạp toàn bộ chương trình l Nạp trước: Dự báo trang cần thiết tiếp theo l Nạp theo yêu cầu: Chỉ nạp khi cần thiết l Các chiến lược thay thế trang l FIFO First In First Out l LRU Least Recently Used l LFU Least Frequently Used l . . .
1e8e6c622bfb571b0b783d8347182318:107,1e8e6c622bfb571b0b783d8347182318,107,108,,,553,Ưu điểm Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.4 Chiến lược phân trang l Tăng tốc độ truy nhập l Hai lần truy nhập bộ nhớ (vào PCB và vào địa chỉ cần tìm) l Thực hiện phép ghép thay vì phép cộng l Không tồn tại hiện tượng phân đoạn ngoài l Hệ số song song cao l Chỉ cần một vài trang của chương trình trong bộ nhớ l Cho phép viết chương trình lớn tùy ý l Dễ dàng thực hiện nhiệm vụ bảo vệ l Địa chỉ truy nhập hợp lệ (vượt quá kích thước) l Tính chất truy nhập (đọc/ghi) l Quyền truy nhập (user/system) l Cho phép sử dụng chung trang
1e8e6c622bfb571b0b783d8347182318:108,1e8e6c622bfb571b0b783d8347182318,108,109,,,243,Dùng chung trang : Soạn thảo văn bản Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.4 Chiến lược phân trang l Mỗi trang 50K l 3 trang mã l 1 trang dữ liệu l 40 người dùng l Không dùng chung l Cần 8000K l Dùng chung l Chỉ cần 2150K
1e8e6c622bfb571b0b783d8347182318:109,1e8e6c622bfb571b0b783d8347182318,109,110,,,630,"Dùng chung trang : Nguyên tắc Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.4 Chiến lược phân trang l Cần thiết trong môi trường hoạt động phân chia l Giảm kích thước vùng nhớ cho tất cả các tiến trình l Phần mã dùng chung l Chỉ một phiên bản phân chia giữa các tiến trình trong bộ nhớ l Ví dụ: Soạn thảo văn bản, chương trình dịch.... l Vấn đề: Mã dùng chung không đổi l Trang dùng chung phải cùng vị trí trong không gian logic của tất cả tiến trình ⇒Cùng số hiệu trong bảng quản lý trang l Phần mã và dữ liệu riêng biệt l Riêng biệt cho các tiến trình l Có thể nằm ở vị trí bất kỳ trong bộ nhớ logic của tiến trình"
1e8e6c622bfb571b0b783d8347182318:110,1e8e6c622bfb571b0b783d8347182318,110,111,,,515,"Nhược điểm Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.4 Chiến lược phân trang l Tồn tại hiện tượng phân đoạn trong l Luôn xuất hiện ở trang cuối cùng l Giảm hiện tượng phân đoạn trang bởi giảm kích thước trang ? l Hay gặp lỗi trang l Bảng quản lý trang lớn l Đòi hỏi hỗ trợ của phần cứng l Chi phí cho chiến lược phân trang lớn l Khi chương trình lớn, bảng quản lý trang nhiều phần tử l Chương trình 230, k/thước trang 212-> PCB có 220 phần tử l Tốn bộ nhớ lưu trữ PCB l Giải quyết: Trang nhiều mức"
1e8e6c622bfb571b0b783d8347182318:111,1e8e6c622bfb571b0b783d8347182318,111,112,,,470,"Trang nhiều mức Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.4 Chiến lược phân trang Nguyên tắc: Bảng quản lý trang được phân trang Ví dụ trang 2 mức l Máy 32 bít địa chỉ (232); trang kích thước 4K (212) được chia l Số hiệu trang -20 bit l Độ lệch trong trang -12 bit l Bảng trang được phân trang. Số hiệu trang được chia thành l Bảng trang ngoài (thư mục trang) - 10 bit l Độ lệch trong một thư mục trang – 10 bit l Địa chỉ truy nhập có dạng <p1, p2, d >"
1e8e6c622bfb571b0b783d8347182318:112,1e8e6c622bfb571b0b783d8347182318,112,113,,,118,Trang nhiều mức: Ví dụ trang 2 mức Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.4 Chiến lược phân trang
1e8e6c622bfb571b0b783d8347182318:113,1e8e6c622bfb571b0b783d8347182318,113,114,,,400,"Trang nhiều mức: Truy nhập bộ nhớ Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.4 Chiến lược phân trang l Khi thực hiện : Hệ thống nạp thư mục trang vào bộ nhớ l Bảng trang và trang không sử dụng không cần nạp vào bộ nhớ l Cần 3 lần truy nhập tới bộ nhớ l Vấn đề: Với hệ thống 64 bit l Trang 3, 4,... mức l Cần 4, 5,... lần truy nhập bô nhớ ⇒chậm l Giải quyết: Bộ đệm chuyển hóa địa chỉ"
1e8e6c622bfb571b0b783d8347182318:114,1e8e6c622bfb571b0b783d8347182318,114,115,,,457,"Bộ đệm chuyển hóa địa chỉ Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.4 Chiến lược phân trang TLB: translation look-aside buffers l Tập thanh ghi liên kết (associative registers) l Truy nhập song song l Mỗi phần tử gồm l Khóa: Page number l Giá trị: Frame number l TLB chứa đ/chỉ những trang mới truy nhập l Khi có y/cầu <p,d> l Tìm p trong TLB l Không có, tìm p trong PCB rồi đưa < p, f > vào TLB 98% truy nhập bộ nhớ được thực hiện qua TLB"
1e8e6c622bfb571b0b783d8347182318:115,1e8e6c622bfb571b0b783d8347182318,115,116,,,203,lChiến lược phân chương cố định lChiến lược phân chương động lChiến lược phân đoạn lChiến lược phân trang lChiến lược kết hợp phân đoạn-phân trang Chương 3 Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ
1e8e6c622bfb571b0b783d8347182318:116,1e8e6c622bfb571b0b783d8347182318,116,117,,,755,"Nguyên tắc Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2. 5 Chiến lược kết hợp phân đoạn-phân trang l Chương trình được biên tập theo chế độ phân đoạn l Tạo ra bảng quản lý đoạn SCB l Mỗi phần tử của bảng quản lý đoạn ứng với một đoạn, gồm 3 trường M, A, L l Mỗi đoạn được biên tập riêng theo chế độ phân trang l Tạo ra bảng quản lý trang cho từng đoạn l Địa chỉ truy nhập: bộ 3 < s, p, d > l Thực hiện truy nhập địa chỉ l STBR + s ⇒: địa chỉ phần tử s l Kiểm tra trường dấu hiệu Ms, nạp PCBs nếu cần l As + p ⇒Địa chỉ phần tử p của PCBs l Kiểm tra trường dấu hiệu Mp, nạp PCBs nếu cần l Ghép Ap với d ra được địa chỉ cần tìm l Được sử dụng trong VXL Intel 80386, MULTICS . . . l Quản lý bộ nhớ của VXL họ intel l Chế độ thực l Chế độ bảo vệ"
1e8e6c622bfb571b0b783d8347182318:117,1e8e6c622bfb571b0b783d8347182318,117,118,,,125,Sơ đồ truy nhập bộ nhớ Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2. 5 Chiến lược kết hợp phân đoạn-phân trang
1e8e6c622bfb571b0b783d8347182318:118,1e8e6c622bfb571b0b783d8347182318,118,119,,,286,Phân đoạn M A L 0 − 2340 1 2140 5730 0 − 4264 0 − 1766 Bảng: SCB M A L 0 − 3 0 5 6 0 − 5 0 − 2 Bảng: SCB M A 0 − 1 8 0 − 0 − 0 − 0 − Bảng: PCB2 Tổng kết Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2. 5 Chiến lược kết hợp phân đoạn-phân trang Kết hợp Phân đoạn – Phân trang
1e8e6c622bfb571b0b783d8347182318:119,1e8e6c622bfb571b0b783d8347182318,119,120,,,111,①Tổng quan ②Các chiến lược quản lý bộ nhớ ③Bộ nhớ ảo ④Quản lý bộ nhớ trong VXL họ Intel Chương 3 Quản lý bộ nhớ
1e8e6c622bfb571b0b783d8347182318:120,1e8e6c622bfb571b0b783d8347182318,120,121,,,90,①Giới thiệu ②Các chiến lược đổi trang Chương 3: Quản lý bộ nhớ 3. Bộ nhớ ảo 3.1 Giới thiệu
1e8e6c622bfb571b0b783d8347182318:121,1e8e6c622bfb571b0b783d8347182318,121,122,,,729,"Đặt vấn đề Chương 3: Quản lý bộ nhớ 3. Bộ nhớ ảo 3.1 Giới thiệu l Câu lệnh phải nằm trong bộ nhớ khi thực hiện ! l Toàn bộ chương trình phải nằm trong bộ nhớ ? l Cấu trúc động; cấu trúc Overlays... : Nạp từng phần l Đòi hỏi sự chú ý đặc biệt từ lập trình viên ⇒Không cần thiết l Đoạn chương trình xử lý báo lỗi l Lỗi ít xảy tra, ít được thực hiện l Phần khai không dùng tới l Khai báo ma trận 100x100, sử dụng 10x 10 l Thực hiện c/trình chỉ có 1 phần nằm trong bộ nhớ cho phép l Viết chương trình trong không gian địa chỉ áo (virtual address space) l lớn tùy ý l Nhiều chương trình đồng thời tồn tại ⇒tăng hiệu suất sử dụng CPU l Giảm yêu cầu vào/ra cho việc nạp và hoán đổi chương trình l Kích thước phần hoán đổi (swap) nhỏ hơn"
1e8e6c622bfb571b0b783d8347182318:122,1e8e6c622bfb571b0b783d8347182318,122,123,,,321,Khái niệm bộ nhớ ảo Chương 3: Quản lý bộ nhớ 3. Bộ nhớ ảo 3.1 Giới thiệu l Dùng bộ nhớ thứ cấp (HardDisk) lưu trữ phần chương trình chưa đưa vào bộ nhớ vật lý l Phân tách bộ nhớ logic (của người dùng) với bộ nhớ vật lý l Cho phép thể ánh xạ vùng nhớ logic lớn vào bộ nhớ vật lý nhỏ l Cài đặt theo l Phân trang l Phân đoạn
1e8e6c622bfb571b0b783d8347182318:123,1e8e6c622bfb571b0b783d8347182318,123,124,,,303,"Nạp từng phần của trang chương trình vào bộ nhớ Chương 3: Quản lý bộ nhớ 3. Bộ nhớ ảo 3.1 Giới thiệu l Trang của tiến trình: l bộ nhớ vật lý, l một số trang nằm trên đĩa(bộ nhớ ảo) l Biểu diễn nhờ sử dụng một bit trong bảng quản lý trang l Khi yêu cầu trang, đưa trang từ bộ nhớ thứ cấp -> bộ nhớ vật lý"
1e8e6c622bfb571b0b783d8347182318:124,1e8e6c622bfb571b0b783d8347182318,124,125,,,120,"Xử lý lỗi trang Chương 3: Quản lý bộ nhớ 3. Bộ nhớ ảo 3.1 Giới thiệu Nếu không có frames tự do, phải tiến hành đổi trang"
1e8e6c622bfb571b0b783d8347182318:125,1e8e6c622bfb571b0b783d8347182318,125,126,,,233,Đổi trang Chương 3: Quản lý bộ nhớ 3. Bộ nhớ ảo 3.1 Giới thiệu ① Xác định vị trí trang logic trên đĩa ② Lựa chọn trang vật lý l Ghi ra đĩa l Sửa lại bit valid- invalid ③ Nạp trang logic vào trang vật lý được chọn ④ Restart tiến trình
1e8e6c622bfb571b0b783d8347182318:126,1e8e6c622bfb571b0b783d8347182318,126,127,,,104,①Giới thiệu ②Các chiến lược đổi trang Chương 3: Quản lý bộ nhớ 3. Bộ nhớ ảo 3.2 Các chiến lược đổi trang
1e8e6c622bfb571b0b783d8347182318:127,1e8e6c622bfb571b0b783d8347182318,127,128,,,367,Các chiến lược Chương 3: Quản lý bộ nhớ 3. Bộ nhớ ảo 3.2 Các chiến lược đổi trang l FIFO (First In First Out): Vào trước ra trước l OPT/MIN: Thuật toán thay thế trang tối ưu l LRU (Least Recently Used): Trang có lần sử dụng cuối cách đây lâu nhất l LFU (Least Frequently used):Tần xuất sử dụng thấp nhất l MFU (Most Frequently used): Tần xuất sử dụng cao nhất l . . .
1e8e6c622bfb571b0b783d8347182318:128,1e8e6c622bfb571b0b783d8347182318,128,129,,,485,"Ví dụ FIFO Chương 3: Quản lý bộ nhớ 3. Bộ nhớ ảo 3.2 Các chiến lược đổi trang Nhận xét l Hiệu quả khi chương trình có cấu trúc tuyến tính. l Kém hiểu quả khi chương trình theo nguyên tắc lập trình cấu trúc l Đơn giản dễ thực hiện l Dùng hàng đợi lưu các trang của chương trình trong bộ nhớ l Chèn ở cuối hàng, Thay thế trang ở đầu hàng l Tăng trang vật lý, không đảm bảo giảm số lần gặp lỗi trang l Dãy truy nhập: 1 2 3 4 1 2 5 1 2 3 4 5 l 3 frames: 9 lỗi trang; 4 frames: 10 lỗi trang"
1e8e6c622bfb571b0b783d8347182318:129,1e8e6c622bfb571b0b783d8347182318,129,130,,,213,OPT OPT Chương 3: Quản lý bộ nhớ 3. Bộ nhớ ảo 3.2 Các chiến lược đổi trang Nguyên tắc: Đưa ra trang có lần sử dụng tiếp theo cách xa nhất l Số lần gặp lỗi trang ít nhất l Khó dự báo được diễn biến của chương trình
1e8e6c622bfb571b0b783d8347182318:130,1e8e6c622bfb571b0b783d8347182318,130,131,,,416,L ✞ RU LRU Chương 3: Quản lý bộ nhớ 3. Bộ nhớ ảo 3.2 Các chiến lược đổi trang Nguyên tắc: Đưa ra trang có lần sử dụng cuối cách xa nhất l Hiệu quả cho chiến lược thay thế trang l Đảm bảo giảm số lỗi trang khi tăng số trang vật lý l Tập các trang trong bộ nhớ có n frames luôn là tập con của các trang trong bộ nhớ có n + 1 frames l Y/cầu sự trợ giúp kỹ thuật để chỉ ra thời điểm truy nhập cuối l Cài đặt như thế nào?
1e8e6c622bfb571b0b783d8347182318:131,1e8e6c622bfb571b0b783d8347182318,131,132,,,695,"LRU: Cài đặt Chương 3: Quản lý bộ nhớ 3. Bộ nhớ ảo 3.2 Các chiến lược đổi trang l Bộ đếm l Thêm một trường ghi thời điểm truy nhập vào mỗi phần tử của PCB l Thêm vào khối điều khiển (C.U) đồng hồ/bộ đếm l Khi có yêu cầu truy nhâp trang l Tăng bộ đếm l Chép nội dung bộ đếm vào trường thời điểm truy nhập tại phần tử tương ứng trong PCB l Cần có thủ tục cập nhật PCB (ghi vào trường thời điểm) và thủ tục tìm kiếm trang có giá trị trường thời điểm nhỏ nhất l Hiện tượng tràn số ! ? l Dãy số(Stack) l Dùng dãy số ghi số trang l Truy nhập tới một trang, cho phần tử tương ứng lên đầu dãy l Thay thế trang: Phần tử cuối dãy l Thường cài đặt dưới dạng DSLK 2 chiều l 4 phép gán con trỏ ⇒tốn thời gian"
1e8e6c622bfb571b0b783d8347182318:132,1e8e6c622bfb571b0b783d8347182318,132,133,,,486,"Thuật toán dựa trên bộ đếm Chương 3: Quản lý bộ nhớ 3. Bộ nhớ ảo 3.2 Các chiến lược đổi trang Sử dụng bộ đếm (một trường của PCB) ghi nhận số lần truy nhập tới trang l LFU: Trang có bộ đếm nhỏ nhất bị thay thế l Trang truy nhập nhiều đến l Trang quan trọng ⇒hợp lý l Trang khởi tạo, chỉ được dùng ở giai đoạn đầu ⇒ không hợp lý ⇒Dịch bộ đếm một bit (chia đôi) theo thời gian l MFU: Trang có bộ đếm lớn nhất l Trang có bộ đếm nhỏ nhất, vừa mới được nạp vào và vẫn chưa được sử dụng nhiều"
1e8e6c622bfb571b0b783d8347182318:133,1e8e6c622bfb571b0b783d8347182318,133,134,,,111,①Tổng quan ②Các chiến lược quản lý bộ nhớ ③Bộ nhớ ảo ④Quản lý bộ nhớ trong VXL họ Intel Chương 3 Quản lý bộ nhớ
1e8e6c622bfb571b0b783d8347182318:134,1e8e6c622bfb571b0b783d8347182318,134,135,,,715,"Các chế độ Chương 3: Quản lý bộ nhớ 4. Quản lý bộ nhớ trong vi xử lý họ Intel l Intel 8086, 8088 l Chỉ có một chế độ quản lý: Chế độ thực (Real Mode) l Quản lý vùng nhớ lên đến 1MB ( 20bit ) l Xác định địa chỉ ô nhớ bằng 2 giá trị 16 bit: Segment, Offset l Thanh ghi đoạn: CS, SS, DS, ES, l Thanh ghi độ lệch: IP, SP, BP... l Địa chỉ vật lý: Seg SHL 4 + Ofs l Intel 80286 l Chế độ thực, tương thích với 8086 l Chế độ bảo vệ (Protected mode), l Sử dụng phương pháp phân đoạn l Khai thác được bộ nhớ vật lý 16M (24bit ) l Intel 80386, Intel 80486, Pentium,.. l Chế độ thực, tương thích với 8086 l Chế độ bảo vệ :Kết hợp phân đoạn, phân trang l Chế độ ảo (Virtual mode) l Cho phép thực hiện mã 8086 trong chế độ bảo vệ"
1e8e6c622bfb571b0b783d8347182318:135,1e8e6c622bfb571b0b783d8347182318,135,136,,,113,"Chế độ bảo vệ trong Intel 386, 486, Pentium,.. Chương 3: Quản lý bộ nhớ 4. Quản lý bộ nhớ trong vi xử lý họ Intel"
1e8e6c622bfb571b0b783d8347182318:136,1e8e6c622bfb571b0b783d8347182318,136,137,,,406,2 Kết luận Chương 3: Quản lý bộ nhớ ①Tổng quan 1. Ví dụ 2. Bộ nhớ và chương trình 3. Liên kết địa chỉ 4. Các cấu trúc chương trình ②Các chiến lược quản lý bộ nhớ 1. Chiến lược phân chương cố định 2. Chiến lược phân chương động 3. Chiến lược phân đoạn 4. Chiến lược phân trang 5. Chiến lược kết hợp phân đoạn-phân trang ③Bộ nhớ ảo 1. Giới thiệu 2. Các chiến lược đổi trang ④Quản lý bộ nhớ trong VXL họ Intel
2d1f518956cdc4b3cf6a9447714cfcd0:0,2d1f518956cdc4b3cf6a9447714cfcd0,0,1,,,143,Hệ Điều Hành (Nguyên lý các hệ điều hành) Đỗ Quốc Huy huydq@soict.hust.edu.vn Bộ môn Khoa Học Máy Tính Viện Công Nghệ Thông Tin và Truyền Thông
2d1f518956cdc4b3cf6a9447714cfcd0:1,2d1f518956cdc4b3cf6a9447714cfcd0,1,2,,,928,"l Bộ nhớ ngoài (đĩa từ, băng từ, đĩa quang,..): dung lượng lớn và cho phép lưu trữ lâu dài l Được người dùng sử dụng lưu trữ dữ liệu và chương trình l Dữ liệu và chương trình được lưu dưới dạng file (tập tin/tệp) ⇒Tạo nên hệ thống file l Hệ thống file gồm 2 phần riêng biệt l Các file: Chứa dữ liệu/chương trình của hệ thống/người dùng l Cấu trúc thư mục : Cung cấp các thông tin về file l Hệ thống file lớn ⇒Quản lý như thế nào? l Các thuộc tính của file, thao tác cần phải cung cấp? l Lưu trữ và truy xuất dữ liệu trên thiết bị lưu trữ như thế nào? l Phương pháp cung cấp không gian lưu trữ, quản lý vùng tự do ⇒Khó khăn phải trong suốt với người dùng (tính thuận tiện) l Các file dữ liệu /chương trình có thể sử dụng chung l Đảm bảo tính toàn vẹn dữ liệu và loại bỏ truy nhập bất hợp lệ? l Dữ liệu không lưu trữ tập trung ⇒hệ thống file phân tán l Truy nhập file từ xa, đảm bảo tính toàn vẹn... Chương 4 Quản lý hệ thống file"
2d1f518956cdc4b3cf6a9447714cfcd0:2,2d1f518956cdc4b3cf6a9447714cfcd0,2,3,,,113,①Hệ thống file ②Cài đặt hệ thống file ③Tổ chức thông tin trên đĩa từ ④Hệ thống FAT Chương 4 Quản lý hệ thống file
2d1f518956cdc4b3cf6a9447714cfcd0:3,2d1f518956cdc4b3cf6a9447714cfcd0,3,4,,,101,lKhái niệm file lCấu trúc thư mục Chương 4: Quản lý hệ thống file 1. Hệ thống file 1.1 Khái niệm file
2d1f518956cdc4b3cf6a9447714cfcd0:4,2d1f518956cdc4b3cf6a9447714cfcd0,4,5,,,723,"Chương 4: Quản lý hệ thống file 1. Hệ thống file 1.1 Khái niệm file Giới thiệu l Thông tin lưu trữ trên nhiều phương tiện/thiết bị lưu trữ khác nhau l Ví dụ: Đĩa từ, băng từ, đĩa quang... l Thiết bị lưu trữ được mô hình như một mảng của các khối nhớ l File là tập thông tin ghi trên thiết bị lưu trữ. l File là đơn vị lưu trữ của hệ điều hành trên bộ nhớ ngoài l File bao gồm dãy các bits, bytes, dòng, bản ghi,... mang ý nghĩa được định nghĩa bởi người tạo ra l Cấu trúc của file được định nghĩa theo loại file l File văn bản: Chuỗi ký tự tổ chức thành dòng l File đối tượng: Bytes được tổ chức thành khối để chương trình liên kết (linker) hiểu được l File thực thi: Chuỗi các mã lệnh có thể thực hiện trong bộ nhớ l . . ."
2d1f518956cdc4b3cf6a9447714cfcd0:5,2d1f518956cdc4b3cf6a9447714cfcd0,5,6,,,1051,"Chương 4: Quản lý hệ thống file 1. Hệ thống file 1.1 Khái niệm file Các thuộc tính file l Tên file (Name): Chuỗi ký tự (hello.c) l Thông tin lưu dưới dạng người dùng có thể đọc được l Có thể phân biệt chữ hoa/chữ thường l Đảm bảo tính độc lập của file với tiến trình, người dùng... l A tạo file hello.c bằng notepad trên hệ Windows l B dùng emacs trên linux sửa lại file bởi xác định tên hello.c l Định danh (Identifier): Thẻ xác định duy nhất một file l Kiểu (Type): Dùng cho hệ thống hỗ trợ nhiều kiểu file l Có thể xác định kiểu file dựa trên một phần của tên file l Ví dụ: .exe, .com/ .doc, .txt/ .c, .jav, .pas/ .pdf, .jpg,... l Dựa trên kiểu, HĐH sẽ thao tác trên tập tin phù hợp l Thực hiện file thực thi mà file nguồn đã sửa ⇒Dịch lại l Nháy đúp vào một file văn bản (*.doc)⇒Gọi word processor l Vị trí (Position): Trỏ tới thiết bị và vị trí của file trên đó l Kích thước (Size): Kích thước hiện thời/ tối đa của file l Bảo vệ (Protection): Điều khiển truy nhập: Ai có thể đọc/ghi.. l Thời gian (Time): Thời điểm tạo, sửa đổi, sử dụng cuối ..."
2d1f518956cdc4b3cf6a9447714cfcd0:6,2d1f518956cdc4b3cf6a9447714cfcd0,6,7,,,570,Không gian lưu trữ hello.c vi trí hdh.pdf vi trí hello.c hdh.pdf Bản ghi file Chương 4: Quản lý hệ thống file 1. Hệ thống file 1.1 Khái niệm file Các thuộc tính file (tiếp tục) l Thuộc tính file được lưu trong cấu trúc dữ liệu: Bản ghi file l Có thể chỉ chứa tên file và định danh file; định danh file xác định các thông tin còn lại l Kích thước từ vài bytes lên tới kilobytes l Các bản ghi file được lưu giữ trong Thư mục file l Kích thước có thể đạt tới Megabytes l Thường được lữu trữ trên thiết bị nhớ ngoài l Được đưa từng phần vào bộ nhớ khi cần thiết Thư mục file
2d1f518956cdc4b3cf6a9447714cfcd0:7,2d1f518956cdc4b3cf6a9447714cfcd0,7,8,,,233,Chương 4: Quản lý hệ thống file 1. Hệ thống file 1.1 Khái niệm file Các thao tác cơ bản l Tạo file (Create) l Ghi file (Write) l Đọc file (Read) l Thay đổi vị trí trong file(Seek) l Xóa file (Delete) l Thu gọn file (Truncate) l . . .
2d1f518956cdc4b3cf6a9447714cfcd0:8,2d1f518956cdc4b3cf6a9447714cfcd0,8,9,,,387,"Thư mục file hello.c vi trí hello.c Create(SoNT.dat) SoNT.dat vi trí 19/04/2011 Chương 4: Quản lý hệ thống file 1. Hệ thống file 1.1 Khái niệm file Các thao tác cơ bản : Tạo file l Tìm vùng tự do trong không gian lưu trữ của hệ thống file l Cung cấp vùng trống như thế nào? l Tạo một phần tử mới trong thư mục file Không gian lưu trữ l Lưu tên file, vị trí của file và các thông tin khác"
2d1f518956cdc4b3cf6a9447714cfcd0:9,2d1f518956cdc4b3cf6a9447714cfcd0,9,10,,,511,"Thư mục file hello.c vi trí hello.c Write(SoNT.dat, 17) SoNT.dat vi trí 19/04/2011 Chương 4: Quản lý hệ thống file 1. Hệ thống file 1.1 Khái niệm file Các thao tác cơ bản : Ghi file l Lời gọi hệ thống Write() yêu cầu tên file và dữ liệu được ghi l Dùng tên file, tìm kiếm file trong thư mục file l Dựa vào trường vị trí, tìm vị trí của file trên thiết bị lưu trữ l Hệ thống lưu con trỏ ghi (write pointer) để chỉ ra vị trí ghi l Con trỏ ghi thay đổi sau mỗi thao tác ghi Không gian lưu trữ Kiemtra.pdf 235 17 wp"
2d1f518956cdc4b3cf6a9447714cfcd0:10,2d1f518956cdc4b3cf6a9447714cfcd0,10,11,,,534,"Thư mục file hello.c vi trí Write(SoNT.dat, 17) SoNT.dat vi trí 19/04/2011 Chương 4: Quản lý hệ thống file 1. Hệ thống file 1.1 Khái niệm file Các thao tác cơ bản : Ghi file l Lời gọi hệ thống Write() yêu cầu tên file và dữ liệu được ghi l Dùng tên file, tìm kiếm file trong thư mục file l Dựa vào trường vị trí, tìm vị trí của file trên thiết bị lưu trữ l Hệ thống lưu con trỏ ghi (write pointer) để chỉ ra vị trí ghi l Con trỏ ghi thay đổi sau mỗi thao tác ghi Không gian lưu trữ Kiemtra.pdf 235 17 wp Write(SoNT.dat, 19) 19 hello.c"
2d1f518956cdc4b3cf6a9447714cfcd0:11,2d1f518956cdc4b3cf6a9447714cfcd0,11,12,,,557,"Thư mục file hello.c vi trí Write(SoNT.dat, 17) SoNT.dat vi trí 19/04/2011 Chương 4: Quản lý hệ thống file 1. Hệ thống file 1.1 Khái niệm file Các thao tác cơ bản : Ghi file l Lời gọi hệ thống Write() yêu cầu tên file và dữ liệu được ghi l Dùng tên file, tìm kiếm file trong thư mục file l Dựa vào trường vị trí, tìm vị trí của file trên thiết bị lưu trữ l Hệ thống lưu con trỏ ghi (write pointer) để chỉ ra vị trí ghi l Con trỏ ghi thay đổi sau mỗi thao tác ghi Không gian lưu trữ Kiemtra.pdf 235 17 wp Write(SoNT.dat, 19) 19 Write(SoNT.dat, 23) 23 hello.c"
2d1f518956cdc4b3cf6a9447714cfcd0:12,2d1f518956cdc4b3cf6a9447714cfcd0,12,13,,,580,"Thư mục file hello.c vi trí Write(SoNT.dat, 17) SoNT.dat vi trí 19/04/2011 Chương 4: Quản lý hệ thống file 1. Hệ thống file 1.1 Khái niệm file Các thao tác cơ bản : Ghi file l Lời gọi hệ thống Write() yêu cầu tên file và dữ liệu được ghi l Dùng tên file, tìm kiếm file trong thư mục file l Dựa vào trường vị trí, tìm vị trí của file trên thiết bị lưu trữ l Hệ thống lưu con trỏ ghi (write pointer) để chỉ ra vị trí ghi l Con trỏ ghi thay đổi sau mỗi thao tác ghi Không gian lưu trữ Kiemtra.pdf 235 17 wp Write(SoNT.dat, 19) 19 Write(SoNT.dat, 23) 23 Write(SoNT.dat, 29) 29 hello.c"
2d1f518956cdc4b3cf6a9447714cfcd0:13,2d1f518956cdc4b3cf6a9447714cfcd0,13,14,,,534,"Thư mục file hello.c vi trí Buf =Read(SoNT.dat) SoNT.dat vi trí 19/04/2011 Chương 4: Quản lý hệ thống file 1. Hệ thống file 1.1 Khái niệm file Các thao tác cơ bản : Đọc file l Lời gọi hệ thống Read() yêu cầu tên file và vùng đệm ghi KQ l Dùng tên file, tìm kiếm file trong thư mục file l Dựa vào trường vị trí, tìm vị trí của file trên thiết bị lưu trữ l Hệ thống lưu con trỏ đọc (read pointer) chỉ ra vị trí được đọc l Con trỏ đọc thay đổi sau mỗi thao tác đọc dữ liệu Không gian lưu trữ Kiemtra.pdf 235 17 rp 19 23 29 Buf:17 hello.c"
2d1f518956cdc4b3cf6a9447714cfcd0:14,2d1f518956cdc4b3cf6a9447714cfcd0,14,15,,,534,"Thư mục file hello.c vi trí Buf =Read(SoNT.dat) SoNT.dat vi trí 19/04/2011 Chương 4: Quản lý hệ thống file 1. Hệ thống file 1.1 Khái niệm file Các thao tác cơ bản : Đọc file l Lời gọi hệ thống Read() yêu cầu tên file và vùng đệm ghi KQ l Dùng tên file, tìm kiếm file trong thư mục file l Dựa vào trường vị trí, tìm vị trí của file trên thiết bị lưu trữ l Hệ thống lưu con trỏ đọc (read pointer) chỉ ra vị trí được đọc l Con trỏ đọc thay đổi sau mỗi thao tác đọc dữ liệu Không gian lưu trữ Kiemtra.pdf 235 17 rp 19 23 29 Buf:19 hello.c"
2d1f518956cdc4b3cf6a9447714cfcd0:15,2d1f518956cdc4b3cf6a9447714cfcd0,15,16,,,534,"Thư mục file hello.c vi trí Buf =Read(SoNT.dat) SoNT.dat vi trí 19/04/2011 Chương 4: Quản lý hệ thống file 1. Hệ thống file 1.1 Khái niệm file Các thao tác cơ bản : Đọc file l Lời gọi hệ thống Read() yêu cầu tên file và vùng đệm ghi KQ l Dùng tên file, tìm kiếm file trong thư mục file l Dựa vào trường vị trí, tìm vị trí của file trên thiết bị lưu trữ l Hệ thống lưu con trỏ đọc (read pointer) chỉ ra vị trí được đọc l Con trỏ đọc thay đổi sau mỗi thao tác đọc dữ liệu Không gian lưu trữ Kiemtra.pdf 235 17 rp 19 23 29 Buf:23 hello.c"
2d1f518956cdc4b3cf6a9447714cfcd0:16,2d1f518956cdc4b3cf6a9447714cfcd0,16,17,,,594,"Thư mục file hello.c vi trí Buf =Read(SoNT.dat) SoNT.dat vi trí 19/04/2011 Chương 4: Quản lý hệ thống file 1. Hệ thống file 1.1 Khái niệm file Các thao tác cơ bản : Đọc file l Lời gọi hệ thống Read() yêu cầu tên file và vùng đệm ghi KQ l Dùng tên file, tìm kiếm file trong thư mục file l Dựa vào trường vị trí, tìm vị trí của file trên thiết bị lưu trữ l Hệ thống lưu con trỏ đọc (read pointer) chỉ ra vị trí được đọc l Con trỏ đọc thay đổi sau mỗi thao tác đọc dữ liệu Không gian lưu trữ Kiemtra.pdf 235 17 rp 19 23 29 Buf:29 l Dùng một con trỏ cho cả thao tác đọc và ghi: con trỏ file hello.c"
2d1f518956cdc4b3cf6a9447714cfcd0:17,2d1f518956cdc4b3cf6a9447714cfcd0,17,18,,,458,"Thư mục file hello.c vi trí Delete(SoNT.dat) SoNT.dat vi trí 19/04/2011 Chương 4: Quản lý hệ thống file 1. Hệ thống file 1.1 Khái niệm file Các thao tác cơ bản : Xóa file l Dùng tên file, tìm kiếm file trong thư mục file l Vùng nhớ được xác định bởi 2 trường vị trí và kích thước được giải phóng để có thể sử dụng lại bởi các file khác l Xóa phần tử tương ứng trong thư mục file l Xóa logic / xóa vật lý Không gian lưu trữ Kiemtra.pdf 235 17 19 23 29 hello.c"
2d1f518956cdc4b3cf6a9447714cfcd0:18,2d1f518956cdc4b3cf6a9447714cfcd0,18,19,,,505,Chương 4: Quản lý hệ thống file 1. Hệ thống file 1.1 Khái niệm file Các thao tác cơ bản : Thay đổi vị trí trong file và thu gọn file l Thay đổi vị trí trong file l Duyệt thư mục để tìm phần tử tương ứng l Con trỏ file được thay bằng giá trị thích hợp l Thao tác này không yêu cầu một hoạt động vào/ra l Thu gọn file l Được sử dụng khi người sử dụng muốn xóa nội dung file nhưng vẫn giữ nguyên các thuộc tính l Tìm kiếm file trong thư mục file l Đặt kích thước file về 0 l Giải phóng vùng nhớ dành cho file
2d1f518956cdc4b3cf6a9447714cfcd0:19,2d1f518956cdc4b3cf6a9447714cfcd0,19,20,,,387,"Chương 4: Quản lý hệ thống file 1. Hệ thống file 1.1 Khái niệm file Các thao tác cơ bản : Một số thao tác khác l Ngoài các thao tác cơ bản, còn tồn tại nhiều thao tác khác l Thêm dữ liệu vào cuối file (append) l Lấy/đặt thông tin thuộc tính file l Đổi tên file l Có thể được đảm bảo thông qua các thao tác cơ bản. Ví dụ copy file l Tạo file mới l Đọc dữ liệu từ file cũ l Ghi ra file mới"
2d1f518956cdc4b3cf6a9447714cfcd0:20,2d1f518956cdc4b3cf6a9447714cfcd0,20,21,,,955,"Chương 4: Quản lý hệ thống file 1. Hệ thống file 1.1 Khái niệm file Các thao tác cơ bản: Đóng mở file l Các thao tác file phải duyệt thư mục file ⇒Lãng phí thời gian l Để giải quyết, các tiến trình phải thực hiện mở file (open) trước khi thao tác với file l Thao tác mở file: tìm kiếm file trong thư mục file l Chép phần tử tương ứng vào bảng file mở l Chứa thông tin về các file đang được mở l Trả lại con trỏ của phần tử tương ứng trong bản file mở l Khi có yêu cầu, HĐH tìm kiếm trong bảng file mở l Dùng con trỏ trả về của thao tác mở file l Khi không sử dụng file nữa cần phải đóng (close) file. l HĐH sẽ loại bỏ phần tử tương ứng trong bảng file mở l Thao tác đóng/mỏ file trong môi trường đa người dùng l Dùng 2 loại bảng file mở: Cho từng tiến trình và cho hệ thống l Ghi lại số tiến trình đang mở file (File Open Counter) l Tăng/Giảm bộ đếm khi có tiến trình mở/đóng file l Xóa p/tử tương ứng trong bảng file mở mức hệ thống khi bộ đếm bằng không"
2d1f518956cdc4b3cf6a9447714cfcd0:21,2d1f518956cdc4b3cf6a9447714cfcd0,21,22,,,103,lKhái niệm file lCấu trúc thư mục Chương 4: Quản lý hệ thống file 1. Hệ thống file 1.2 Cấu trúc thư mục
2d1f518956cdc4b3cf6a9447714cfcd0:22,2d1f518956cdc4b3cf6a9447714cfcd0,22,23,,,246,"Chương 4: Quản lý hệ thống file 1. Hệ thống file 1.2 Cấu trúc thư mục Các phân vùng (Partition) l Đĩa được chia thành nhiều phân vùng Partitions, Minidisks, Volumes l Mỗi phân vùng được xử lý như vùng lưu trữ phân biệt l Có thể chứa một HĐH riêng"
2d1f518956cdc4b3cf6a9447714cfcd0:23,2d1f518956cdc4b3cf6a9447714cfcd0,23,24,,,273,Chương 4: Quản lý hệ thống file 1. Hệ thống file 1.2 Cấu trúc thư mục Các phân vùng (Partition) Kết hợp một vài đĩa thành một cấu trúc logic lớn l Người dùng chỉ quan tâm tới cấu trúc file và thư mục logic l Không quan tâm tới cách phân phối vật lý không gian đĩa cho files
2d1f518956cdc4b3cf6a9447714cfcd0:24,2d1f518956cdc4b3cf6a9447714cfcd0,24,25,,,870,"Chương 4: Quản lý hệ thống file 1. Hệ thống file 1.2 Cấu trúc thư mục Các thao tác với thư mục l Mỗi một phân khu lưu các thông tin về file trong nó l Các thông tin file được lưu trữ trong thư mục thiết bị - thư mục l Thư mục là bảng chuyển cho phép ánh xạ từ một tên (file) thành một phần tử trong thư mục l Thư mục có thể được cài đặt bằng nhiều cách khác nhau l Yêu cầu các thao tác chèn, tạo mới, xóa, duyệt danh sách l Các thao tác l Tìm kiếm file: Tìm phần tử ứng với một file xác định l Tạo file: Tạo file mới cần tạo phần tử trong thư mục l Xóa file: Khi xóa file, xóa phần tử tương ứng trong thư mục l Liệt kê thư mục: Liệt kê files và nội dung phần tử tương ứng trong thư mục l Đổi tên file: Thay đổi tên file, vị trí trong cấu trúc thư mục l Duyệt hệ thống file: Truy nhập tất cả thư mục và nội dung tất cả các files trong thư mục (backup dữ liệu lên băng từ)"
2d1f518956cdc4b3cf6a9447714cfcd0:25,2d1f518956cdc4b3cf6a9447714cfcd0,25,26,,,242,"Chương 4: Quản lý hệ thống file 1. Hệ thống file 1.2 Cấu trúc thư mục Thư mục một mức l Cấu trúc đơn giản nhất, các file nằm trong cùng một thư mục l Số người dùng và số file lớn, khả năng trùng tên file cao l Mỗi người dùng một thư mục riêng"
2d1f518956cdc4b3cf6a9447714cfcd0:26,2d1f518956cdc4b3cf6a9447714cfcd0,26,27,,,467,"Thư mục một mức Chương 4: Quản lý hệ thống file 1. Hệ thống file 1.2 Cấu trúc thư mục l Mỗi người sử dụng có một thư mục riêng, khi làm việc với file chỉ duyệt thư mục riêng l Khi log in, hệ thống sẽ kiểm tra và cho phép người sử dụng làm việc với thư mục riêng l Khi thêm một người dùng l Hệ thống tạo phần tử mới trong Master file directory l Tạo ra User file directory l Giả quyết v/đề trùng tên; Hiệu quả khi người dùng độc lập l Khó khăn khi muốn dùng chung file"
2d1f518956cdc4b3cf6a9447714cfcd0:27,2d1f518956cdc4b3cf6a9447714cfcd0,27,28,,,314,Thư mục cấu trúc cây Chương 4: Quản lý hệ thống file 1. Hệ thống file 1.2 Cấu trúc thư mục l Tồn tại một đường dẫn (tương đối/tuyệt đối) đến một file l Thư mục con là file được xử lý đặc biệt (bit đánh dấu) l Các thao tác tạo/xóa/duyệt... t/hiện trên thư mục hiện thời l Xóa thư mục con ⇒Xóa hết các cây con của nó
2d1f518956cdc4b3cf6a9447714cfcd0:28,2d1f518956cdc4b3cf6a9447714cfcd0,28,29,,,266,Thư mục dùng chung Chương 4: Quản lý hệ thống file 1. Hệ thống file 1.2 Cấu trúc thư mục l Người dùng có thể link đến một file của người dùng khác l Khi duyệt thư mục (backup) file có thể duyệt nhiều lần l Xóa file: liên kết/ nội dung (người tạo file /liên kết cuối)
2d1f518956cdc4b3cf6a9447714cfcd0:29,2d1f518956cdc4b3cf6a9447714cfcd0,29,30,,,113,①Hệ thống file ②Cài đặt hệ thống file ③Tổ chức thông tin trên đĩa từ ④Hệ thống FAT Chương 4 Quản lý hệ thống file
2d1f518956cdc4b3cf6a9447714cfcd0:30,2d1f518956cdc4b3cf6a9447714cfcd0,30,31,,,161,lCài đặt thư mục lCác phương pháp phân phối vùng lưu trữ lQuản lý vùng lưu trữ tự do Chương 4: Quản lý hệ thống file 2. Cài đặt hệ thống file 2.1 Cài đặt thư mục
2d1f518956cdc4b3cf6a9447714cfcd0:31,2d1f518956cdc4b3cf6a9447714cfcd0,31,32,,,548,Phương pháp Chương 4: Quản lý hệ thống file 2. Cài đặt hệ thống file 2.1 Cài đặt thư mục ① Danh sách tuyến tính với con trỏ tới các khối dữ liệu l Đơn giản cho lập trình l Tốn thời gian khi thực hiện các thao tác với thư mục l Phải duyệt toàn bộ danh sách ⇐Dùng cây nhị phân? ② Bảng băm - Bảng băm với danh sách tuyến tính l Giảm thời gian duyệt thư mục l Đòi hỏi có một hàm băm hiệu quả l Vấn đề đụng độ ←hàm băm trả về cùng một kết quả với 2 tên file khác nhau l Vấn đề kích thước cố định →Tăng kích thước phải tính toán lại những phần đã tồn tại
2d1f518956cdc4b3cf6a9447714cfcd0:32,2d1f518956cdc4b3cf6a9447714cfcd0,32,33,,,97,Danh sách tuyến tính Chương 4: Quản lý hệ thống file 2. Cài đặt hệ thống file 2.1 Cài đặt thư mục
2d1f518956cdc4b3cf6a9447714cfcd0:33,2d1f518956cdc4b3cf6a9447714cfcd0,33,34,,,85,Bảng băm Chương 4: Quản lý hệ thống file 2. Cài đặt hệ thống file 2.1 Cài đặt thư mục
2d1f518956cdc4b3cf6a9447714cfcd0:34,2d1f518956cdc4b3cf6a9447714cfcd0,34,35,,,85,Bảng băm Chương 4: Quản lý hệ thống file 2. Cài đặt hệ thống file 2.1 Cài đặt thư mục
2d1f518956cdc4b3cf6a9447714cfcd0:35,2d1f518956cdc4b3cf6a9447714cfcd0,35,36,,,161,lCài đặt thư mục lCác phương pháp phân phối vùng lưu trữ lQuản lý vùng lưu trữ tự do Chương 4: Quản lý hệ thống file 2. Cài đặt hệ thống file 2.1 Cài đặt thư mục
2d1f518956cdc4b3cf6a9447714cfcd0:36,2d1f518956cdc4b3cf6a9447714cfcd0,36,37,,,366,Mục đích l Tăng hiệu năng truy nhập tuần tự l Dễ dàng truy nhập ngẫu nhiên tới file l Dễ dàng quản lý file Phương pháp l Phân phối liên tục (Continuous Allocation) l Phân phối liên kết (Linked List Allocation) l Phân phối chỉmục (Indexed Allocation) Các phương pháp Chương 4: Quản lý hệ thống file 2. Cài đặt hệ thống file 2. 2 Các phương pháp phân phối vùng lưu trữ
2d1f518956cdc4b3cf6a9447714cfcd0:37,2d1f518956cdc4b3cf6a9447714cfcd0,37,38,,,179,Phân phối liên tục Chương 4: Quản lý hệ thống file 2. Cài đặt hệ thống file 2. 2 Các phương pháp phân phối vùng lưu trữ Nguyên tắc: File được phân phối các khối nhớ liên tiếp nhau
2d1f518956cdc4b3cf6a9447714cfcd0:38,2d1f518956cdc4b3cf6a9447714cfcd0,38,39,,,179,Phân phối liên tục Chương 4: Quản lý hệ thống file 2. Cài đặt hệ thống file 2. 2 Các phương pháp phân phối vùng lưu trữ Nguyên tắc: File được phân phối các khối nhớ liên tiếp nhau
2d1f518956cdc4b3cf6a9447714cfcd0:39,2d1f518956cdc4b3cf6a9447714cfcd0,39,40,,,179,Phân phối liên tục Chương 4: Quản lý hệ thống file 2. Cài đặt hệ thống file 2. 2 Các phương pháp phân phối vùng lưu trữ Nguyên tắc: File được phân phối các khối nhớ liên tiếp nhau
2d1f518956cdc4b3cf6a9447714cfcd0:40,2d1f518956cdc4b3cf6a9447714cfcd0,40,41,,,179,Phân phối liên tục Chương 4: Quản lý hệ thống file 2. Cài đặt hệ thống file 2. 2 Các phương pháp phân phối vùng lưu trữ Nguyên tắc: File được phân phối các khối nhớ liên tiếp nhau
2d1f518956cdc4b3cf6a9447714cfcd0:41,2d1f518956cdc4b3cf6a9447714cfcd0,41,42,,,585,"Phân phối liên tục Chương 4: Quản lý hệ thống file 2. Cài đặt hệ thống file 2. 2 Các phương pháp phân phối vùng lưu trữ l File có độ dài n và bắt đầu ở khối b sẽ chiếm các khối b, b + 1, . . . , b + n − 1 l Hai khối b và b + 1 liên tiếp nhau ⇒Không phải dịch chuyển đầu từ khi đọc (trừ sector cuối) ⇒Tốc độ truy nhập nhanh l Cho phép truy nhập trực tiếp khối i của file ⇒truy nhập khối b + i − 1 trên thiết bị lưu trữ l Lựa chọn vùng trống khi có yêu cầu lưu trữ? l Các chiến lược First-Fit /Worst Fit /Best Fit l Hiện tượng phân đoạn ngoài l Khó khăn khi muốn tăng kích thước của file"
2d1f518956cdc4b3cf6a9447714cfcd0:42,2d1f518956cdc4b3cf6a9447714cfcd0,42,43,,,229,"Phân phối liên kết Chương 4: Quản lý hệ thống file 2. Cài đặt hệ thống file 2. 2 Các phương pháp phân phối vùng lưu trữ Nguyên tắc: File được phân phối các khối nhớ không liên tục. Cuối mỗi khối là con trỏ, trỏ tới khối tiếp theo"
2d1f518956cdc4b3cf6a9447714cfcd0:43,2d1f518956cdc4b3cf6a9447714cfcd0,43,44,,,229,"Phân phối liên kết Chương 4: Quản lý hệ thống file 2. Cài đặt hệ thống file 2. 2 Các phương pháp phân phối vùng lưu trữ Nguyên tắc: File được phân phối các khối nhớ không liên tục. Cuối mỗi khối là con trỏ, trỏ tới khối tiếp theo"
2d1f518956cdc4b3cf6a9447714cfcd0:44,2d1f518956cdc4b3cf6a9447714cfcd0,44,45,,,229,"Phân phối liên kết Chương 4: Quản lý hệ thống file 2. Cài đặt hệ thống file 2. 2 Các phương pháp phân phối vùng lưu trữ Nguyên tắc: File được phân phối các khối nhớ không liên tục. Cuối mỗi khối là con trỏ, trỏ tới khối tiếp theo"
2d1f518956cdc4b3cf6a9447714cfcd0:45,2d1f518956cdc4b3cf6a9447714cfcd0,45,46,,,229,"Phân phối liên kết Chương 4: Quản lý hệ thống file 2. Cài đặt hệ thống file 2. 2 Các phương pháp phân phối vùng lưu trữ Nguyên tắc: File được phân phối các khối nhớ không liên tục. Cuối mỗi khối là con trỏ, trỏ tới khối tiếp theo"
2d1f518956cdc4b3cf6a9447714cfcd0:46,2d1f518956cdc4b3cf6a9447714cfcd0,46,47,,,229,"Phân phối liên kết Chương 4: Quản lý hệ thống file 2. Cài đặt hệ thống file 2. 2 Các phương pháp phân phối vùng lưu trữ Nguyên tắc: File được phân phối các khối nhớ không liên tục. Cuối mỗi khối là con trỏ, trỏ tới khối tiếp theo"
2d1f518956cdc4b3cf6a9447714cfcd0:47,2d1f518956cdc4b3cf6a9447714cfcd0,47,48,,,229,"Phân phối liên kết Chương 4: Quản lý hệ thống file 2. Cài đặt hệ thống file 2. 2 Các phương pháp phân phối vùng lưu trữ Nguyên tắc: File được phân phối các khối nhớ không liên tục. Cuối mỗi khối là con trỏ, trỏ tới khối tiếp theo"
2d1f518956cdc4b3cf6a9447714cfcd0:48,2d1f518956cdc4b3cf6a9447714cfcd0,48,49,,,265,"Phân phối liên kết Chương 4: Quản lý hệ thống file 2. Cài đặt hệ thống file 2. 2 Các phương pháp phân phối vùng lưu trữ Nguyên tắc: File được phân phối các khối nhớ không liên tục. Cuối mỗi khối là con trỏ, trỏ tới khối tiếp theo File def gồm 5 khối: 5, 6, 8, 9, 11"
2d1f518956cdc4b3cf6a9447714cfcd0:49,2d1f518956cdc4b3cf6a9447714cfcd0,49,50,,,872,"Phân phối liên kết Chương 4: Quản lý hệ thống file 2. Cài đặt hệ thống file 2. 2 Các phương pháp phân phối vùng lưu trữ l Chỉ áp dụng hiệu quả cho các file truy nhập tuần tự l Để truy nhập khối thứ n, phải duyệt qua n − 1 khối trước đó l Các khối không liên tục, phải định vị lại đầu từ l Tốc độ truy nhập chậm l Các khối trong file được liên kết bởi con trỏ. Nếu con trỏ lỗi? l Bị mất dư liệu do mất liên kết tới khối l Liên kết tới khối không có dữ liệu hoặc khối của file khác l Giải quyết: Sử dụng nhiều con trỏ trong mỗi khối ⇒Tốn nhớ l Áp dụng: FAT l Được sử dụng như danh sách liên kết l Gồm nhiều phần tử, mỗi phần tử ứng với một khối l Mỗi phần tử trong FAT, chứa khối tiếp theo của file l Khối cuối cùng có giá trị đặc biệt (FFFF) l Khối bị hỏng có giá trị (FFF7) l Khối chưa sử dụng có giá trị (0) l Trường vị trí trong bản ghi file, chứa khối đầu tiên của file"
2d1f518956cdc4b3cf6a9447714cfcd0:50,2d1f518956cdc4b3cf6a9447714cfcd0,50,51,,,220,Phân phối chỉ mục Chương 4: Quản lý hệ thống file 2. Cài đặt hệ thống file 2. 2 Các phương pháp phân phối vùng lưu trữ Nguyên tắc: Mỗi file có một khối chỉ mục chính (index block) chứa danh sách các khối dữ liệu của file
2d1f518956cdc4b3cf6a9447714cfcd0:51,2d1f518956cdc4b3cf6a9447714cfcd0,51,52,,,220,Phân phối chỉ mục Chương 4: Quản lý hệ thống file 2. Cài đặt hệ thống file 2. 2 Các phương pháp phân phối vùng lưu trữ Nguyên tắc: Mỗi file có một khối chỉ mục chính (index block) chứa danh sách các khối dữ liệu của file
2d1f518956cdc4b3cf6a9447714cfcd0:52,2d1f518956cdc4b3cf6a9447714cfcd0,52,53,,,220,Phân phối chỉ mục Chương 4: Quản lý hệ thống file 2. Cài đặt hệ thống file 2. 2 Các phương pháp phân phối vùng lưu trữ Nguyên tắc: Mỗi file có một khối chỉ mục chính (index block) chứa danh sách các khối dữ liệu của file
2d1f518956cdc4b3cf6a9447714cfcd0:53,2d1f518956cdc4b3cf6a9447714cfcd0,53,54,,,220,Phân phối chỉ mục Chương 4: Quản lý hệ thống file 2. Cài đặt hệ thống file 2. 2 Các phương pháp phân phối vùng lưu trữ Nguyên tắc: Mỗi file có một khối chỉ mục chính (index block) chứa danh sách các khối dữ liệu của file
2d1f518956cdc4b3cf6a9447714cfcd0:54,2d1f518956cdc4b3cf6a9447714cfcd0,54,55,,,220,Phân phối chỉ mục Chương 4: Quản lý hệ thống file 2. Cài đặt hệ thống file 2. 2 Các phương pháp phân phối vùng lưu trữ Nguyên tắc: Mỗi file có một khối chỉ mục chính (index block) chứa danh sách các khối dữ liệu của file
2d1f518956cdc4b3cf6a9447714cfcd0:55,2d1f518956cdc4b3cf6a9447714cfcd0,55,56,,,220,Phân phối chỉ mục Chương 4: Quản lý hệ thống file 2. Cài đặt hệ thống file 2. 2 Các phương pháp phân phối vùng lưu trữ Nguyên tắc: Mỗi file có một khối chỉ mục chính (index block) chứa danh sách các khối dữ liệu của file
2d1f518956cdc4b3cf6a9447714cfcd0:56,2d1f518956cdc4b3cf6a9447714cfcd0,56,57,,,848,"Phân phối chỉ mục Chương 4: Quản lý hệ thống file 2. Cài đặt hệ thống file 2. 2 Các phương pháp phân phối vùng lưu trữ l Phần tử thứ i của khối chỉ mục trỏ tới khối thứ i của file l Đọc khối i dùng con trỏ được khi tại p/tử i của khối chỉ mục l Tạo file, các phần tử của khối chỉ mục có giá trị null (-1) l Cần thêm khối i, địa chỉ khối được cấp, được đưa vào p/tử i l Nhận xét l Không gây hiện tượng phân đoạn ngoài l Cho phép truy nhập trực tiếp l Cần khối chỉ mục: file có k/thước nhỏ, vẫn cần 2 khối l Khối cho dữ liệu l Khối chi khối chỉ mục (chỉ dùng 1 phần tử) Giải quyết: Giảm kích thước khối ⇒Giảm phí tổn bộ nhớ ⇒Vấn đề về kích thước file có thể lưu trữ. l Sơ đồ liên kết l Liên kết các khối chỉ mục lại l P/tử cuối của khối chỉ mục trỏ tới khối chỉ mục khác nếu cần l Index nhiều mức l Dùng một khối chỉ mục trỏ tới các khối chỉ mục khác"
2d1f518956cdc4b3cf6a9447714cfcd0:57,2d1f518956cdc4b3cf6a9447714cfcd0,57,58,,,335,Sơ đồ kết hợp (UNIX) Chương 4: Quản lý hệ thống file 2. Cài đặt hệ thống file 2. 2 Các phương pháp phân phối vùng lưu trữ l 12 direct block trỏ tới data block l Single indirect block chứa địa chỉ khối direct block l Double indirect block chứa địa chỉ khối Single indirect block l Triple indirect block chứa địa chỉ khối Double indirect
2d1f518956cdc4b3cf6a9447714cfcd0:58,2d1f518956cdc4b3cf6a9447714cfcd0,58,59,,,172,lCài đặt thư mục lCác phương pháp phân phối vùng lưu trữ lQuản lý vùng lưu trữ tự do Chương 4: Quản lý hệ thống file 2. Cài đặt hệ thống file 2.3 Quản lý vùng lưu trữ tự do
2d1f518956cdc4b3cf6a9447714cfcd0:59,2d1f518956cdc4b3cf6a9447714cfcd0,59,60,,,836,"Phương pháp Chương 4: Quản lý hệ thống file 2. Cài đặt hệ thống file 2. 2 Các phương pháp phân phối vùng lưu trữ l Bit vector l Mỗi block thể hiện bởi 1 bit (1: free; 0: allocated) l Dễ dàng tìm ra n khối nhớ liên tục l Cần có lệnh cho phép làm việc với bit l Danh sách liên kết (link list) l Lưu giữ con trỏ tới khối đĩa trống đầu tiên l Khối nhớ này chứa con trỏ trở tới khối đĩa trống tiếp theo l Không hiệu quả khi duyệt danh sách l Nhóm (Grouping) l Lưu trữ địa chỉ n khối tự do trong khối tự do đầu tiên l n − 1 khối đầu tự do, khối n chứa đ/chỉ của n khối tự do tiếp l Ưu điểm: Tìm vùng nhớ tự do nhanh chóng l Bộ đếm (Counting) l Do các khối nhớ liên tục được c/cấp và g/phóng đồng thời l Nguyên tắc: Lưu địa chỉ khối nhớ tự do đầu tiên và kích thước vùng nhớ liên tục trong DS quản lý vùng trống l Hiệu quả khi bộ đếm lớn hơn 1"
2d1f518956cdc4b3cf6a9447714cfcd0:60,2d1f518956cdc4b3cf6a9447714cfcd0,60,61,,,113,①Hệ thống file ②Cài đặt hệ thống file ③Tổ chức thông tin trên đĩa từ ④Hệ thống FAT Chương 4 Quản lý hệ thống file
2d1f518956cdc4b3cf6a9447714cfcd0:61,2d1f518956cdc4b3cf6a9447714cfcd0,61,62,,,141,lCấu trúc vật lý của đĩa lCấu trúc logic của đĩa Chương 4: Quản lý hệ thống file 3. Tổ chức thông tin trên đĩa từ 3.1 Cấu trúc vật lý của đĩa
2d1f518956cdc4b3cf6a9447714cfcd0:62,2d1f518956cdc4b3cf6a9447714cfcd0,62,63,,,115,"44 / 107 Chương 4: Quản lý hệ thống file 3. Tổ chức thông tin trên đĩa từ 3.1 Cấu trúc vật lý của đĩa Đĩa mềm 5 ! """
2d1f518956cdc4b3cf6a9447714cfcd0:63,2d1f518956cdc4b3cf6a9447714cfcd0,63,64,,,115,45 / 107 Chương 4: Quản lý hệ thống file 3. Tổ chức thông tin trên đĩa từ 3.1 Cấu trúc vật lý của đĩa Đĩa mềm 3 ! #
2d1f518956cdc4b3cf6a9447714cfcd0:64,2d1f518956cdc4b3cf6a9447714cfcd0,64,65,,,355,"Mặt 0 Rãnh Sector Chương 4: Quản lý hệ thống file 3. Tổ chức thông tin trên đĩa từ 3.1 Cấu trúc vật lý của đĩa Cấu trúc vật lý đĩa mềm l Rãnh đĩa (Track): Các vòng tròn đồng tâm l Được đánh số 0, 1,. . . từ ngoài vào trong l Mặt đĩa. Mỗi mặt đĩa được đọc bởi một đầu đọc (Header) l Các đầu từ được đánh số 0, 1 l Cung từ (Sector) l Được đánh số 1, 2,. . ."
2d1f518956cdc4b3cf6a9447714cfcd0:65,2d1f518956cdc4b3cf6a9447714cfcd0,65,66,,,400,"Chương 4: Quản lý hệ thống file 3. Tổ chức thông tin trên đĩa từ 3.1 Cấu trúc vật lý của đĩa Định vị thông tin trên đĩa mềm l Sector đơn vị thông tin hệ thống dùng làm việc với đĩa l Sector xác định qua tọa độ 3 chiều: Header, Track, Sector l Ví dụ: Boot Sector của đĩa mềm: Sector <0, 0, 1> l Sector được xác định qua số hiệu sector (tọa độ 1 chiều) l Vị trí tương đối so với sector đầu tiên của đĩa"
2d1f518956cdc4b3cf6a9447714cfcd0:66,2d1f518956cdc4b3cf6a9447714cfcd0,66,67,,,422,"Chương 4: Quản lý hệ thống file 3. Tổ chức thông tin trên đĩa từ 3.1 Cấu trúc vật lý của đĩa Định vị thông tin trên đĩa mềm l Sector đơn vị thông tin hệ thống dùng làm việc với đĩa l Sector xác định qua tọa độ 3 chiều: Header, Track, Sector l Ví dụ: Boot Sector của đĩa mềm: Sector <0, 0, 1> l Sector được xác định qua số hiệu sector (tọa độ 1 chiều) l Vị trí tương đối so với sector đầu tiên của đĩa Sector < 0, 0, 1 >→#0"
2d1f518956cdc4b3cf6a9447714cfcd0:67,2d1f518956cdc4b3cf6a9447714cfcd0,67,68,,,422,"Chương 4: Quản lý hệ thống file 3. Tổ chức thông tin trên đĩa từ 3.1 Cấu trúc vật lý của đĩa Định vị thông tin trên đĩa mềm l Sector đơn vị thông tin hệ thống dùng làm việc với đĩa l Sector xác định qua tọa độ 3 chiều: Header, Track, Sector l Ví dụ: Boot Sector của đĩa mềm: Sector <0, 0, 1> l Sector được xác định qua số hiệu sector (tọa độ 1 chiều) l Vị trí tương đối so với sector đầu tiên của đĩa Sector < 0, 0, 2 >→#1"
2d1f518956cdc4b3cf6a9447714cfcd0:68,2d1f518956cdc4b3cf6a9447714cfcd0,68,69,,,422,"Chương 4: Quản lý hệ thống file 3. Tổ chức thông tin trên đĩa từ 3.1 Cấu trúc vật lý của đĩa Định vị thông tin trên đĩa mềm l Sector đơn vị thông tin hệ thống dùng làm việc với đĩa l Sector xác định qua tọa độ 3 chiều: Header, Track, Sector l Ví dụ: Boot Sector của đĩa mềm: Sector <0, 0, 1> l Sector được xác định qua số hiệu sector (tọa độ 1 chiều) l Vị trí tương đối so với sector đầu tiên của đĩa Sector < 0, 0, 3 >→#2"
2d1f518956cdc4b3cf6a9447714cfcd0:69,2d1f518956cdc4b3cf6a9447714cfcd0,69,70,,,422,"Chương 4: Quản lý hệ thống file 3. Tổ chức thông tin trên đĩa từ 3.1 Cấu trúc vật lý của đĩa Định vị thông tin trên đĩa mềm l Sector đơn vị thông tin hệ thống dùng làm việc với đĩa l Sector xác định qua tọa độ 3 chiều: Header, Track, Sector l Ví dụ: Boot Sector của đĩa mềm: Sector <0, 0, 1> l Sector được xác định qua số hiệu sector (tọa độ 1 chiều) l Vị trí tương đối so với sector đầu tiên của đĩa Sector < 0, 0, 4 >→#3"
2d1f518956cdc4b3cf6a9447714cfcd0:70,2d1f518956cdc4b3cf6a9447714cfcd0,70,71,,,422,"Chương 4: Quản lý hệ thống file 3. Tổ chức thông tin trên đĩa từ 3.1 Cấu trúc vật lý của đĩa Định vị thông tin trên đĩa mềm l Sector đơn vị thông tin hệ thống dùng làm việc với đĩa l Sector xác định qua tọa độ 3 chiều: Header, Track, Sector l Ví dụ: Boot Sector của đĩa mềm: Sector <0, 0, 1> l Sector được xác định qua số hiệu sector (tọa độ 1 chiều) l Vị trí tương đối so với sector đầu tiên của đĩa Sector < 0, 0, 5 >→#4"
2d1f518956cdc4b3cf6a9447714cfcd0:71,2d1f518956cdc4b3cf6a9447714cfcd0,71,72,,,422,"Chương 4: Quản lý hệ thống file 3. Tổ chức thông tin trên đĩa từ 3.1 Cấu trúc vật lý của đĩa Định vị thông tin trên đĩa mềm l Sector đơn vị thông tin hệ thống dùng làm việc với đĩa l Sector xác định qua tọa độ 3 chiều: Header, Track, Sector l Ví dụ: Boot Sector của đĩa mềm: Sector <0, 0, 1> l Sector được xác định qua số hiệu sector (tọa độ 1 chiều) l Vị trí tương đối so với sector đầu tiên của đĩa Sector < 0, 0, 6 >→#5"
2d1f518956cdc4b3cf6a9447714cfcd0:72,2d1f518956cdc4b3cf6a9447714cfcd0,72,73,,,422,"Chương 4: Quản lý hệ thống file 3. Tổ chức thông tin trên đĩa từ 3.1 Cấu trúc vật lý của đĩa Định vị thông tin trên đĩa mềm l Sector đơn vị thông tin hệ thống dùng làm việc với đĩa l Sector xác định qua tọa độ 3 chiều: Header, Track, Sector l Ví dụ: Boot Sector của đĩa mềm: Sector <0, 0, 1> l Sector được xác định qua số hiệu sector (tọa độ 1 chiều) l Vị trí tương đối so với sector đầu tiên của đĩa Sector < 0, 0, 7 >→#6"
2d1f518956cdc4b3cf6a9447714cfcd0:73,2d1f518956cdc4b3cf6a9447714cfcd0,73,74,,,422,"Chương 4: Quản lý hệ thống file 3. Tổ chức thông tin trên đĩa từ 3.1 Cấu trúc vật lý của đĩa Định vị thông tin trên đĩa mềm l Sector đơn vị thông tin hệ thống dùng làm việc với đĩa l Sector xác định qua tọa độ 3 chiều: Header, Track, Sector l Ví dụ: Boot Sector của đĩa mềm: Sector <0, 0, 1> l Sector được xác định qua số hiệu sector (tọa độ 1 chiều) l Vị trí tương đối so với sector đầu tiên của đĩa Sector < 0, 0, 8 >→#7"
2d1f518956cdc4b3cf6a9447714cfcd0:74,2d1f518956cdc4b3cf6a9447714cfcd0,74,75,,,420,"Chương 4: Quản lý hệ thống file 3. Tổ chức thông tin trên đĩa từ 3.1 Cấu trúc vật lý của đĩa Định vị thông tin trên đĩa mềm l Sector đơn vị thông tin hệ thống dùng làm việc với đĩa l Sector xác định qua tọa độ 3 chiều: Header, Track, Sector l Ví dụ: Boot Sector của đĩa mềm: Sector <0, 0, 1> l Sector được xác định qua số hiệu sector (tọa độ 1 chiều) l Vị trí tương đối so với sector đầu tiên của đĩa Sector < 1, 0,1>→#8"
2d1f518956cdc4b3cf6a9447714cfcd0:75,2d1f518956cdc4b3cf6a9447714cfcd0,75,76,,,420,"Chương 4: Quản lý hệ thống file 3. Tổ chức thông tin trên đĩa từ 3.1 Cấu trúc vật lý của đĩa Định vị thông tin trên đĩa mềm l Sector đơn vị thông tin hệ thống dùng làm việc với đĩa l Sector xác định qua tọa độ 3 chiều: Header, Track, Sector l Ví dụ: Boot Sector của đĩa mềm: Sector <0, 0, 1> l Sector được xác định qua số hiệu sector (tọa độ 1 chiều) l Vị trí tương đối so với sector đầu tiên của đĩa Sector < 1, 0,2>→#9"
2d1f518956cdc4b3cf6a9447714cfcd0:76,2d1f518956cdc4b3cf6a9447714cfcd0,76,77,,,421,"Chương 4: Quản lý hệ thống file 3. Tổ chức thông tin trên đĩa từ 3.1 Cấu trúc vật lý của đĩa Định vị thông tin trên đĩa mềm l Sector đơn vị thông tin hệ thống dùng làm việc với đĩa l Sector xác định qua tọa độ 3 chiều: Header, Track, Sector l Ví dụ: Boot Sector của đĩa mềm: Sector <0, 0, 1> l Sector được xác định qua số hiệu sector (tọa độ 1 chiều) l Vị trí tương đối so với sector đầu tiên của đĩa Sector < 1, 0,3>→#10"
2d1f518956cdc4b3cf6a9447714cfcd0:77,2d1f518956cdc4b3cf6a9447714cfcd0,77,78,,,421,"Chương 4: Quản lý hệ thống file 3. Tổ chức thông tin trên đĩa từ 3.1 Cấu trúc vật lý của đĩa Định vị thông tin trên đĩa mềm l Sector đơn vị thông tin hệ thống dùng làm việc với đĩa l Sector xác định qua tọa độ 3 chiều: Header, Track, Sector l Ví dụ: Boot Sector của đĩa mềm: Sector <0, 0, 1> l Sector được xác định qua số hiệu sector (tọa độ 1 chiều) l Vị trí tương đối so với sector đầu tiên của đĩa Sector < 1, 0,8>→#15"
2d1f518956cdc4b3cf6a9447714cfcd0:78,2d1f518956cdc4b3cf6a9447714cfcd0,78,79,,,421,"Chương 4: Quản lý hệ thống file 3. Tổ chức thông tin trên đĩa từ 3.1 Cấu trúc vật lý của đĩa Định vị thông tin trên đĩa mềm l Sector đơn vị thông tin hệ thống dùng làm việc với đĩa l Sector xác định qua tọa độ 3 chiều: Header, Track, Sector l Ví dụ: Boot Sector của đĩa mềm: Sector <0, 0, 1> l Sector được xác định qua số hiệu sector (tọa độ 1 chiều) l Vị trí tương đối so với sector đầu tiên của đĩa Sector < 0, 1,1>→#16"
2d1f518956cdc4b3cf6a9447714cfcd0:79,2d1f518956cdc4b3cf6a9447714cfcd0,79,80,,,487,"Chương 4: Quản lý hệ thống file 3. Tổ chức thông tin trên đĩa từ 3.1 Cấu trúc vật lý của đĩa Định vị thông tin trên đĩa mềm l Sector đơn vị thông tin hệ thống dùng làm việc với đĩa l Sector xác định qua tọa độ 3 chiều: Header, Track, Sector l Ví dụ: Boot Sector của đĩa mềm: Sector <0, 0, 1> l Sector được xác định qua số hiệu sector (tọa độ 1 chiều) l Vị trí tương đối so với sector đầu tiên của đĩa #0 #1 #2 <0,0,1> <0,0,2> <0,0,3> #8 #9 <1,0,1> <1,0,2> Mô hình thiết bị lưu trữ (Disk)"
2d1f518956cdc4b3cf6a9447714cfcd0:80,2d1f518956cdc4b3cf6a9447714cfcd0,80,81,,,101,Chương 4: Quản lý hệ thống file 3. Tổ chức thông tin trên đĩa từ 3.1 Cấu trúc vật lý của đĩa Đĩa cứng
2d1f518956cdc4b3cf6a9447714cfcd0:81,2d1f518956cdc4b3cf6a9447714cfcd0,81,82,,,110,49 / 107 Chương 4: Quản lý hệ thống file 3. Tổ chức thông tin trên đĩa từ 3.1 Cấu trúc vật lý của đĩa Đĩa cứng
2d1f518956cdc4b3cf6a9447714cfcd0:82,2d1f518956cdc4b3cf6a9447714cfcd0,82,83,,,433,"Chương 4: Quản lý hệ thống file 3. Tổ chức thông tin trên đĩa từ 3.1 Cấu trúc vật lý của đĩa Cấu trúc vật lý đĩa cứng Cấu trúc l Gồm nhiều mặt đĩa, được đánh số từ 0,1 l Các rãnh cùng bán kính tạo nên cylinder, được đánh số từ 0, 1,.. l Các sector trên mỗi mặt của mỗi cylinder, được đánh số từ 1,2,... Định vị thông tin l Tọa độ 3 chiều (H, C, S) l Tọa độ 1 chiều: Số hiệu sector l Nguyên tắc như với đĩa mềm: Sector→Header→Cylinder"
2d1f518956cdc4b3cf6a9447714cfcd0:83,2d1f518956cdc4b3cf6a9447714cfcd0,83,84,,,586,"Chương 4: Quản lý hệ thống file 3. Tổ chức thông tin trên đĩa từ 3.1 Cấu trúc vật lý của đĩa Truy nhập sector trên đĩa l Sector: đơn vị thông tin máy tính dùng để làm việc với đĩa từ l Có thể truy nhập (đọc/ghi/format/...) tới từng sector l Truy nhập sử dụng ngắt BIOS 13h (chức năng 2, 3, 5,...) l Không phụ thuộc hệ điều hành l Sector được xác định theo địa chỉ <H,C,S> l Truy nhập sử dụng lời gọi hệ thống l Ngắt của hệ điều hành l Ví dụ: MSDOS cung cấp ngắt 25h/26h cho phép đọc/ghi các sector theo địa chỉ tuyến tính l Sử dụng hàm WIN32 API l CreateFile()/ReadFile()/WriteFile()..."
2d1f518956cdc4b3cf6a9447714cfcd0:84,2d1f518956cdc4b3cf6a9447714cfcd0,84,85,,,667,"Chương 4: Quản lý hệ thống file 3. Tổ chức thông tin trên đĩa từ 3.1 Cấu trúc vật lý của đĩa Sử dụng ngắt 13h Thanh ghi Ý nghĩa AH 2h:Đọc sector; 3h: Ghi Sector AL Số sector cần đọc Các sector phải trên cùng một mặt, một rãnh DH Số hiệu mặt đĩa DL Số hiệu ổ đĩa. 0h:A; 80h: Đĩa cứng thứ nhất; 81h Đĩa cứng thứ 2 CH Số hiệu Track/Cylinder (Sử dụng 10 bit, trong đó lấy 2 bit cao của CL) CL Số hiệu sector (chỉ sử dụng 6 bit thấp) ES:BX Trỏ tới vùng đệm, nơi sẽ chứa dữ liệu đọc đươc (khi AH=2h) hoặc dữ liệu ghi ra đĩa (Khi AH=3h) CarryFlag CF=0 không có lỗi; CL chứa số sector đọc được CF=1 Có lỗi, AH chứa mã lỗi WinXP hạn chế sử dụng ngắt 13h để truy nhập trực tiếp"
2d1f518956cdc4b3cf6a9447714cfcd0:85,2d1f518956cdc4b3cf6a9447714cfcd0,85,86,,,488,"Chương 4: Quản lý hệ thống file 3. Tổ chức thông tin trên đĩa từ 3.1 Cấu trúc vật lý của đĩa Sử dụng ngắt 13h (Ví dụ) #include <stdio.h> #include <dos.h> int main(int argc, char *argv[]){ union REGS regs; struct SREGS sregs; int Buf[512]; int i; regs.h.ah = 0x02; regs.h.al = 0x01; regs.h.dh = 0x00; regs.h.dl = 0x80; regs.h.ch = 0x00; regs.h.cl = 0x01; regs.x.bx = FP_OFF(Buf); sregs.es = FP_SEG(Buf); int86x(0x13,&regs,&regs,&sregs); for(i=0;i<512;i++) printf(""%4X"",Buf[i]); return 0; }"
2d1f518956cdc4b3cf6a9447714cfcd0:86,2d1f518956cdc4b3cf6a9447714cfcd0,86,87,,,842,"Chương 4: Quản lý hệ thống file 3. Tổ chức thông tin trên đĩa từ 3.1 Cấu trúc vật lý của đĩa Sử dụng WIN32 API l HANDLE CreateFile(. . . ): Mở file/thiết bị vào ra l LPCTSTR lpFileName, ⇒Tên file/thiết bị vào ra l ” ""\\?\\\\\.\\C : ” Phân vùng / Ổ đĩa C l ”\\\\.\\PhysicalDrive0” Ổ đĩa cứng thứ nhất l DWORD dwDesiredAccess,⇒Thao tác với thiết bị l DWORD dwShareMode,⇒Cho phép dùng chung l LPSECURITY_ATTRIBUTES lpSecurityAttributes (NULL), l DWORD dwCreationDisposition,⇒Hành động thực hiện l DWORD dwFlagsAndAttributes, ⇒Thuộc tính l HANDLE hTemplateFile (NULL) l BOOL ReadFile(. . .) l HANDLE hFile,⇒File muốn đọc l LPVOID lpBuffer, ⇒Vùng đệm chứa dữ liệu l DWORD nNumberOfBytesToRead,⇒, số byte cần đọc l LPDWORD lpNumberOfBytesRead,⇒số byte đọc được l LPOVERLAPPED lpOverlapped (NULL) l BOOL WriteFile(. . .) ⇒Tham số tương tự ReadFile()"
2d1f518956cdc4b3cf6a9447714cfcd0:87,2d1f518956cdc4b3cf6a9447714cfcd0,87,88,,,537,"#include <windows.h> #include <stdio.h> int main(int argc, char *argv[]){ HANDLE hDisk; BYTE Buf[512]; int byteread,i; hDisk=CreateFile(""\\\\.\\PhysicalDrive0"",GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING,0,NULL); i f (hDisk==INVALID_HANDLE_VALUE) printf(""Loi thiet bi""); else { ReadFile(hDisk,Buf,512,&byteread,NULL); for(i=0;i<512;i++) printf(""%4X"",Buf[i]); CloseHandle(hDisk); } return 0; } Chương 4: Quản lý hệ thống file 3. Tổ chức thông tin trên đĩa từ 3.1 Cấu trúc vật lý của đĩa Sử dụng WIN32 API (Ví dụ)"
2d1f518956cdc4b3cf6a9447714cfcd0:88,2d1f518956cdc4b3cf6a9447714cfcd0,88,89,,,110,Chương 4: Quản lý hệ thống file 3. Tổ chức thông tin trên đĩa từ 3.1 Cấu trúc vật lý của đĩa Kết quả thực hiện
2d1f518956cdc4b3cf6a9447714cfcd0:89,2d1f518956cdc4b3cf6a9447714cfcd0,89,90,,,141,lCấu trúc vật lý của đĩa lCấu trúc logic của đĩa Chương 4: Quản lý hệ thống file 3. Tổ chức thông tin trên đĩa từ 3. 2.Cấu trúc logic của đĩa
2d1f518956cdc4b3cf6a9447714cfcd0:90,2d1f518956cdc4b3cf6a9447714cfcd0,90,91,,,683,"MBR Sector ẩn Phân vùng1 Phân vùng2 Chương 4: Quản lý hệ thống file 3. Tổ chức thông tin trên đĩa từ 3.2.Cấu trúc logic của đĩa Cấu trúc logic l Đĩa mềm: Mỗi hệ điều hành có một chiến lược quản lý riêng l Đĩa cứng (Có dung lượng lớn) l Được chia thành nhiều phân vùng (Partitions, Volumes,..) l Mỗi vùng là tập hợp các Cylinder liên tiếp nhau l Người dùng ấn định kích thước (Ví dụ dùng: fdisk) l Mỗi phân vùng có thể được quản lý bởi một HĐH riêng l HĐH format phân vùng theo định dạng được sử dụng l Tồn tại nhiều hệ thống khác nhau: FAT, NTFS, EXT3,... l Trước tất cả các phân vùng là các sector bị che l Master Boot Record (MBR): Sector đầu tiên của đĩa Sector ẩn với phân vùng 2"
2d1f518956cdc4b3cf6a9447714cfcd0:91,2d1f518956cdc4b3cf6a9447714cfcd0,91,92,,,576,"Chương 4: Quản lý hệ thống file 3. Tổ chức thông tin trên đĩa từ 3.2.Cấu trúc logic của đĩa Master Boor Record 1. Chương trình nhận biết l Đọc bảng phân chương để biết l Vị trí các phân vùng l Phân vùng tích cực (chứa HĐH) l Đọc và thực hiện sector đầu tiên của phân vùng tích cực 2. Bảng phân chương (64bytes) l Gồm 4 phần tử, mỗi phần tử 16 bytes l Mỗi phần tử chứa thông tin một vùng Vị trí, kích thước, hệ thống chiếm giữ 3. Chữ ký hệ thống (luôn là 55AA) l Sector quan trọng nhất của đĩa l Sector đầu tiên trên đĩa (Số hiệu 0 hoặc địa chỉ <0, 0, 1>) l Cấu trúc gồm 3 phần"
2d1f518956cdc4b3cf6a9447714cfcd0:92,2d1f518956cdc4b3cf6a9447714cfcd0,92,93,,,591,"Stt Ofs Size Ý nghĩa 1 0 1B Phân vùng tích cực? 80h nếu đúng; 0: Data Địa chỉđầu 2 1 1B Sốhiệu mặt đĩa đầu của phân vùng 3 2 1W Sốhiêu sector và cylinder đầu của phân vùng 4 4 1B Mã nhận diện hệ thốn. 05/0F: Partition mởrộng 06:Big Dos; 07:NTFS; 0B: FAT32,.. đ/c cuối 5 5 1B Sốhiệu đầu đọc cuối 6 6 1W Sốhiệu sector và cylinder cuối của phân vùng. (Sốhiệu sector chỉ dùng 6 bit thấp) 7 8 1DW Đia chỉđầu, tính theo sốhiệu sector 8 12 1DW Sốsector trong phân vùng Chương 4: Quản lý hệ thống file 3. Tổ chức thông tin trên đĩa từ 3.2.Cấu trúc logic của đĩa Cấu trúc một phần tử bảng phân chương"
2d1f518956cdc4b3cf6a9447714cfcd0:93,2d1f518956cdc4b3cf6a9447714cfcd0,93,94,,,502,00 01 01 00 07 FE 3F F8 3F 00 00 00 7A 09 3D 00 80 00 01 F9 0B FE BF 30 B9 09 3D 00 38 7B 4C 00 00 00 81 EB 0F FE FF FF 2B 1D B7 00 72 13 7A 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 55 AA Giải mã Boot Vi trí đầu Vi trí cuối #sector Sốsector Hdr Cyl Sec HdR Cyl Sec No 1 0 1 254 248 63 63 4000122 Yes 0 249 1 254 560 63 4000185 5012280 No 0 747 1 254 1023 63 12000555 8000370 - 0 0 0 0 0 0 0 0 Chương 4: Quản lý hệ thống file 3. Tổ chức thông tin trên đĩa từ 3.2.Cấu trúc logic của đĩa Ví dụ 1
2d1f518956cdc4b3cf6a9447714cfcd0:94,2d1f518956cdc4b3cf6a9447714cfcd0,94,95,,,108,62 / 107 Chương 4: Quản lý hệ thống file 3. Tổ chức thông tin trên đĩa từ 3.2.Cấu trúc logic của đĩa Ví dụ 2
2d1f518956cdc4b3cf6a9447714cfcd0:95,2d1f518956cdc4b3cf6a9447714cfcd0,95,96,,,592,"MBR MBR l Khi trường nhận diện có giá trị 05 hoặc 0F, partition tương ứng là partition mở rộng l Partition mở rộng được tổ chức như một đĩa cứng vật lý l Sector đầu tiên là MBR, chứa thông tin về các phân vùng trong partition mở rộng này l Các phần tử trong partition mở rộng có thể là partition rộng l Cho phép tạo hơn 4 ổ đĩa logic 80 07 00 0B 00 0F Sys#Sector Act Size 00 0B 00 05 Sys#Sector Act Size Chương 4: Quản lý hệ thống file 3. Tổ chức thông tin trên đĩa từ 3.2.Cấu trúc logic của đĩa Bảng phân chương mở rộng Bảng phân chương mở rộng Bảng phân chương Phân vùng 1 Phân vùng mở rộng"
2d1f518956cdc4b3cf6a9447714cfcd0:96,2d1f518956cdc4b3cf6a9447714cfcd0,96,97,,,136,64 / 107 Chương 4: Quản lý hệ thống file 3. Tổ chức thông tin trên đĩa từ 3.2.Cấu trúc logic của đĩa Ví dụ về bảng phân chương mở rộng 1
2d1f518956cdc4b3cf6a9447714cfcd0:97,2d1f518956cdc4b3cf6a9447714cfcd0,97,98,,,136,65 / 107 Chương 4: Quản lý hệ thống file 3. Tổ chức thông tin trên đĩa từ 3.2.Cấu trúc logic của đĩa Ví dụ về bảng phân chương mở rộng 2
2d1f518956cdc4b3cf6a9447714cfcd0:98,2d1f518956cdc4b3cf6a9447714cfcd0,98,99,,,136,66 / 107 Chương 4: Quản lý hệ thống file 3. Tổ chức thông tin trên đĩa từ 3.2.Cấu trúc logic của đĩa Ví dụ về bảng phân chương mở rộng 3
2d1f518956cdc4b3cf6a9447714cfcd0:99,2d1f518956cdc4b3cf6a9447714cfcd0,99,100,,,113,①Hệ thống file ②Cài đặt hệ thống file ③Tổ chức thông tin trên đĩa từ ④Hệ thống FAT Chương 4 Quản lý hệ thống file
2d1f518956cdc4b3cf6a9447714cfcd0:100,2d1f518956cdc4b3cf6a9447714cfcd0,100,101,,,568,"Chương 4: Quản lý hệ thống file 4. Hệ thống FAT Các hệ thống file Tồn tại nhiều hệ thống file khác nhau l Hệ thống FAT l FAT 12/ FAT16 dùng cho MSDOS l FAT32 dùng từ WIN98 l 12/16/32: Số bit dùng để định danh cluster l Hệ thống NTFS l Sử dụng trong WINNT, WIN2000 l Dùng 64 bit để xác định một cluster l Ưu việt hơn FAT trong bảo mật, mã hóa, nén dữ liệu,... l Hệ thống EXT3 l Sử dụng trong Linux l Hệ thống CDFS l Hệ thống quản lý file trong CDROM l Hạn chế về độ sâu cây thư mục và kích thước tên l Hệ thốngs UDF l Phát triển từ CDFS cho DVD-ROM, hỗ trợ tên file dài"
2d1f518956cdc4b3cf6a9447714cfcd0:101,2d1f518956cdc4b3cf6a9447714cfcd0,101,102,,,110,Chương 4: Quản lý hệ thống file 4. Hệ thống FAT l Boot sector l Bảng FAT (File Allocation Table) l Thư mục gốc
2d1f518956cdc4b3cf6a9447714cfcd0:102,2d1f518956cdc4b3cf6a9447714cfcd0,102,103,,,365,Chương 4: Quản lý hệ thống file 4. Hệ thống FAT Cấu trúc phân vùng cho FAT FAT12/16 l Số cluster lớn nhất FAT12: 212 − 18; FAT16 : 216 − 18 l K/thước max: FAT12: 32MB; FAT16: 2GB/4GB (32K/64K Cluster) FAT32 l Chỉ dùng 28 bit ⇒Số cluster lớn nhất 228 − 18 l K/thước max: 2TB/8GB/16TB (8KB/32KB/64KB Cluster) Cấu trúc logic của hệ thống FAT Vùng hệ thống Vùng dữ liệu
2d1f518956cdc4b3cf6a9447714cfcd0:103,2d1f518956cdc4b3cf6a9447714cfcd0,103,104,,,287,Jmp xx Bảng Tham số Chương trình mồi 55AA Chương 4: Quản lý hệ thống file 4. Hệ thống FAT 4.1 Boot sector Cấu trúc l Sector đầu tiên của phân vùng l Cấu trúc gồm 3 phần l Bảng tham số đĩa (BPB: Bios Parameter Block) l Chương trình mồi (Boot strap loader) l Chữ ký hệ thống (luôn là 55AA)
2d1f518956cdc4b3cf6a9447714cfcd0:104,2d1f518956cdc4b3cf6a9447714cfcd0,104,105,,,795,"Chương 4: Quản lý hệ thống file 4. Hệ thống FAT 4.1 Boot sector Cấu trúc bảng tham số đĩa - Phần chung Stt Ofs Kt Giá trị mẫu Ý nghĩa 1 0 3B EB 3C 90 Nhảy đến đầu chương trình mồi 2 3 8B MSDOS5.0 Tên hệ thống file đã format đĩa 3 11 1W 00 02 K/thước 1 sector, thường là 512 4 13 1B 40 Số sector cho một cluster (32K-Cluster) 5 14 1W 01 00 Số scts đứng trước FAT/Số scts để dành 6 16 1B 02 Số bảng FAT 7 17 1W 00 02 Số phần tử của ROOT. FAT32: 00 00 8 19 1W 00 00 Tổng số sector trên đĩa (< 32M) hoặc 0000 9 21 1B F8 Khuôn dạng đĩa (F8:HD, F0: Đĩa1.44M) 10 22 1W D1 09 Số sector cho một bảng FAT(209) 11 24 1W 3F 00 Số sector cho một rãnh (63) 12 26 1W 40 00 Số đầu đọc ghi (64) 13 28 1DW 3F 00 00 00 Số sector ẩn- Sectors trước volume (63) 14 32 1DW 41 0C 34 00 Tổng số sector trên đĩa (3411009)"
2d1f518956cdc4b3cf6a9447714cfcd0:105,2d1f518956cdc4b3cf6a9447714cfcd0,105,106,,,133,Ví dụ: 73 / 107 Chương 4: Quản lý hệ thống file 4. Hệ thống FAT 4.1 Boot sector Cấu trúc bảng tham số đĩa - Phần dành cho FAT12/FAT16
2d1f518956cdc4b3cf6a9447714cfcd0:106,2d1f518956cdc4b3cf6a9447714cfcd0,106,107,,,104,Chương 4: Quản lý hệ thống file 4. Hệ thống FAT 4.1 Boot sector Ví dụ giải mã bảng tham số đĩa của FAT16
2d1f518956cdc4b3cf6a9447714cfcd0:107,2d1f518956cdc4b3cf6a9447714cfcd0,107,108,,,147,Chương 4: Quản lý hệ thống file 4. Hệ thống FAT 4.1 Boot sector Ví dụ giải mã bảng tham số đĩa của FAT16 3 Bytes đầu: Nhảy đến đầu chương trình mồi
2d1f518956cdc4b3cf6a9447714cfcd0:108,2d1f518956cdc4b3cf6a9447714cfcd0,108,109,,,111,Jmp+3C Chương 4: Quản lý hệ thống file 4. Hệ thống FAT 4.1 Boot sector Ví dụ giải mã bảng tham số đĩa của FAT16
2d1f518956cdc4b3cf6a9447714cfcd0:109,2d1f518956cdc4b3cf6a9447714cfcd0,109,110,,,161,OEName: MSDOS5.0 Chương 4: Quản lý hệ thống file 4. Hệ thống FAT 4.1 Boot sector Ví dụ giải mã bảng tham số đĩa của FAT16 8 Bytes Tên hệ thống file đã format đĩa
2d1f518956cdc4b3cf6a9447714cfcd0:110,2d1f518956cdc4b3cf6a9447714cfcd0,110,111,,,151,Kích thước sector: 512 Chương 4: Quản lý hệ thống file 4. Hệ thống FAT 4.1 Boot sector Ví dụ giải mã bảng tham số đĩa của FAT16 1 Word K/thước 1 sector
2d1f518956cdc4b3cf6a9447714cfcd0:111,2d1f518956cdc4b3cf6a9447714cfcd0,111,112,,,153,2 sector cho 1 cluster Chương 4: Quản lý hệ thống file 4. Hệ thống FAT 4.1 Boot sector Ví dụ giải mã bảng tham số đĩa của FAT16 Số sector cho một cluster
2d1f518956cdc4b3cf6a9447714cfcd0:112,2d1f518956cdc4b3cf6a9447714cfcd0,112,113,,,170,Chương 4: Quản lý hệ thống file 4. Hệ thống FAT 4.1 Boot sector Ví dụ giải mã bảng tham số đĩa của FAT16 Có 6 sector đứng trước bảng FAT thứ nhất Số sector đứng trước FAT
2d1f518956cdc4b3cf6a9447714cfcd0:113,2d1f518956cdc4b3cf6a9447714cfcd0,113,114,,,117,Có 2 bảngFAT Chương 4: Quản lý hệ thống file 4. Hệ thống FAT 4.1 Boot sector Ví dụ giải mã bảng tham số đĩa của FAT16
2d1f518956cdc4b3cf6a9447714cfcd0:114,2d1f518956cdc4b3cf6a9447714cfcd0,114,115,,,164,Chương 4: Quản lý hệ thống file 4. Hệ thống FAT 4.1 Boot sector Ví dụ giải mã bảng tham số đĩa của FAT16 Số phần tử của ROOT Có tối đa 512 phần tử trong thư mục gốc
2d1f518956cdc4b3cf6a9447714cfcd0:115,2d1f518956cdc4b3cf6a9447714cfcd0,115,116,,,144,Đĩa lớn hơn32MB Chương 4: Quản lý hệ thống file 4. Hệ thống FAT 4.1 Boot sector Ví dụ giải mã bảng tham số đĩa của FAT16 Tổng số sector trên đĩa
2d1f518956cdc4b3cf6a9447714cfcd0:116,2d1f518956cdc4b3cf6a9447714cfcd0,116,117,,,136,Chương 4: Quản lý hệ thống file 4. Hệ thống FAT 4.1 Boot sector Ví dụ giải mã bảng tham số đĩa của FAT16 Mã nhận diện khuôn dạng đĩa: F8
2d1f518956cdc4b3cf6a9447714cfcd0:117,2d1f518956cdc4b3cf6a9447714cfcd0,117,118,,,135,Chương 4: Quản lý hệ thống file 4. Hệ thống FAT 4.1 Boot sector Ví dụ giải mã bảng tham số đĩa của FAT16 Số sector cho một bảng FAT:245
2d1f518956cdc4b3cf6a9447714cfcd0:118,2d1f518956cdc4b3cf6a9447714cfcd0,118,119,,,129,Sốsector cho một rãnh:63 Chương 4: Quản lý hệ thống file 4. Hệ thống FAT 4.1 Boot sector Ví dụ giải mã bảng tham số đĩa của FAT16
2d1f518956cdc4b3cf6a9447714cfcd0:119,2d1f518956cdc4b3cf6a9447714cfcd0,119,120,,,123,Sốđầu đọc ghi: 255 Chương 4: Quản lý hệ thống file 4. Hệ thống FAT 4.1 Boot sector Ví dụ giải mã bảng tham số đĩa của FAT16
2d1f518956cdc4b3cf6a9447714cfcd0:120,2d1f518956cdc4b3cf6a9447714cfcd0,120,121,,,120,Sốsector ẩn: 63 Chương 4: Quản lý hệ thống file 4. Hệ thống FAT 4.1 Boot sector Ví dụ giải mã bảng tham số đĩa của FAT16
2d1f518956cdc4b3cf6a9447714cfcd0:121,2d1f518956cdc4b3cf6a9447714cfcd0,121,122,,,144,Tổng sốsector của Volume: 125889(≈64MB) Chương 4: Quản lý hệ thống file 4. Hệ thống FAT 4.1 Boot sector Ví dụ giải mã bảng tham số đĩa của FAT16
2d1f518956cdc4b3cf6a9447714cfcd0:122,2d1f518956cdc4b3cf6a9447714cfcd0,122,123,,,132,Chương 4: Quản lý hệ thống file 4. Hệ thống FAT 4.1 Boot sector Ví dụ giải mã bảng tham số đĩa của FAT16 Số hiệu ổ đĩa vật lý: 00 00
2d1f518956cdc4b3cf6a9447714cfcd0:123,2d1f518956cdc4b3cf6a9447714cfcd0,123,124,,,128,Chương 4: Quản lý hệ thống file 4. Hệ thống FAT 4.1 Boot sector Ví dụ giải mã bảng tham số đĩa của FAT16 Bootsector mở rộng: 29h
2d1f518956cdc4b3cf6a9447714cfcd0:124,2d1f518956cdc4b3cf6a9447714cfcd0,124,125,,,136,Volume serial number: 70D4-EAA6 Chương 4: Quản lý hệ thống file 4. Hệ thống FAT 4.1 Boot sector Ví dụ giải mã bảng tham số đĩa của FAT16
2d1f518956cdc4b3cf6a9447714cfcd0:125,2d1f518956cdc4b3cf6a9447714cfcd0,125,126,,,122,Nhãn đĩa: NO NAME Chương 4: Quản lý hệ thống file 4. Hệ thống FAT 4.1 Boot sector Ví dụ giải mã bảng tham số đĩa của FAT16
2d1f518956cdc4b3cf6a9447714cfcd0:126,2d1f518956cdc4b3cf6a9447714cfcd0,126,127,,,120,Kiểu FAT: FAT16 Chương 4: Quản lý hệ thống file 4. Hệ thống FAT 4.1 Boot sector Ví dụ giải mã bảng tham số đĩa của FAT16
2d1f518956cdc4b3cf6a9447714cfcd0:127,2d1f518956cdc4b3cf6a9447714cfcd0,127,128,,,133,Bắt đầu của chương trình mồi Chương 4: Quản lý hệ thống file 4. Hệ thống FAT 4.1 Boot sector Ví dụ giải mã bảng tham số đĩa của FAT16
2d1f518956cdc4b3cf6a9447714cfcd0:128,2d1f518956cdc4b3cf6a9447714cfcd0,128,129,,,779,"Stt Ofs Kt Giá tri mẫu Ý nghĩa 15 36 1DW C9 03 00 00 Tổng sốsector cho bảng FAT 16 40 1W 00 00 Flags: #FAT chính(Không dùng ) 17 42 1W 00 00 Version: Phiên bản FAT32 (Không dùng ) 18 44 1DW 02 00 00 00 Sốhiệu cluster bắt đầu của ROOT 19 48 1W 01 00 #sector chứa File System information 20 50 1W 06 00 Sốhiệu sector dùng backup Bootsector 21 52 12B 00 . . . 00 Đểdành 22 64 1B 00 Sốhiệu ổđĩa vật lý 0: ổA; 80h: ổC 23 65 1B 00 Đểdành/Byte cao cho trường #Driver 24 66 1B 29 Boot sector mởrộng. Luôn có giá trị29h 25 67 1DW 62 0E 18 66 Volumn Serial number 26 71 11B NO NAME Volumn Label: Nhãn đĩa (Ko s/dụng ) 27 82 8B FAT32 Đểdành, thường là đoạn text miêu tả dạng FAT Chương 4: Quản lý hệ thống file 4. Hệ thống FAT 4.1 Boot sector Cấu trúc bảng tham số đĩa - Phần dành cho FAT32"
2d1f518956cdc4b3cf6a9447714cfcd0:129,2d1f518956cdc4b3cf6a9447714cfcd0,129,130,,,118,76 / 107 Chương 4: Quản lý hệ thống file 4. Hệ thống FAT 4.1 Boot sector Ví dụ Boot sector của một hệ thống dùng FAT32
2d1f518956cdc4b3cf6a9447714cfcd0:130,2d1f518956cdc4b3cf6a9447714cfcd0,130,131,,,121,77 / 107 Chương 4: Quản lý hệ thống file 4. Hệ thống FAT 4.1 Boot sector Kết quả giải mã hệ thống FAT32 bằng chương trình
2d1f518956cdc4b3cf6a9447714cfcd0:131,2d1f518956cdc4b3cf6a9447714cfcd0,131,132,,,624,"Stt Ofs Size Ý nghĩa 1 0 1DW Chữký thứnhất của FSInfo sector. Giá trịcác byte theo thứtự: 52h 52h 61h 41h 2 4 480B Không rõ, thường chứa giá trị00 3 484 1DW Chữký của File System Information Sector. Giá trịcác byte theo thứtự: 72h 72h 41h 61h 4 488 1DW Sốcluster tựdo. -1 nếu không xác định 5 492 1DW Sốhiệu của cluster vừa mới được cung cấp 6 496 12B Đểdành 7 508 2B Không xác định, thường bằng 0 8 510 2B Chữký Bootsector. Có giá trị55 AA Chương 4: Quản lý hệ thống file 4. Hệ thống FAT 4.1 Boot sector File System Information Sector l Thường là Sector thứ 2 của Volume l Ngay sau Boot sector (Sector số hiệu 1) l Cấu trúc"
2d1f518956cdc4b3cf6a9447714cfcd0:132,2d1f518956cdc4b3cf6a9447714cfcd0,132,133,,,120,Chương 4: Quản lý hệ thống file 4. Hệ thống FAT 4.1 Boot sector File system information sector của một volume dùng FAT32
2d1f518956cdc4b3cf6a9447714cfcd0:133,2d1f518956cdc4b3cf6a9447714cfcd0,133,134,,,120,Chương 4: Quản lý hệ thống file 4. Hệ thống FAT 4.1 Boot sector File system information sector của một volume dùng FAT32
2d1f518956cdc4b3cf6a9447714cfcd0:134,2d1f518956cdc4b3cf6a9447714cfcd0,134,135,,,725,Stt Ofs Kt Giá tri mẫu Ý nghĩa Nhảy đến đầu chương trình mồi Tên hệth6ng file đã format đĩa Bytes perSector Sectors per Cluster (4K-Cluster ) Reserved sectors. Allwayszero Allways 0 (FAT: Số bảng FAT) Allways 0 (FAT: Sốp/tửcủa ROOT) Not used by NTFS (FAT:K/thước đĩa) Media Type Allway 0 (FAT:Sectors cho FAT) Sector per Track (63 ) Number of Head (255 ) Hidden sectors (63) 1 0 3B EB 52 90 2 3 8B NTFS 3 11 1W 00 02 4 13 1B 08 5 14 1W 00 00 6 16 1B 00 7 17 1W 00 00 8 19 1W 00 00 9 21 1B F8 10 22 1W 00 00 11 24 1W 3F 00 12 26 1W FF 00 13 28 1DW 3F 00 0000 14 32 1DW 00 00 0000 Chương 4: Quản lý hệ thống file 4. Hệ thống FAT 4.1 Boot sector Cấu trúc bảng tham số đĩa cho hệ thống NTFS 1 Not used by NTFS (FAT: ∑sectors %% )
2d1f518956cdc4b3cf6a9447714cfcd0:135,2d1f518956cdc4b3cf6a9447714cfcd0,135,136,,,686,Stt Ofs Kt Giá tri mẫu Ý nghĩa 15 36 1DW 80 00 80 00 Not used by NTFS(FAT:Tổng sốsec- tors cho FAT) 16 40 1LCN 2B 92 00 02 Total sectors (LCN:LONGLONG ) 00 00 00 00 (33591851 ) 17 48 1LCN 00 00 0C 00 Logical cluster number for MFT 00 00 00 00 (786432) 18 56 1LCN 22 09 20 00 Logical #cluster for MFT mirroring 00 00 00 00 (2099490 ) 19 64 1DW F6 00 00 00 Clusters per file record segment (246) 20 68 1DW 01 00 00 00 Clusters per index block (1) 21 72 1LCN A6 CA D7 C6 Volume serial number 00 D8 6C 24 246C-D800-C6D7-CAA6 22 80 1DW 00 00 00 00 Checksum 23 84 - Bootstrap loader Chương 4: Quản lý hệ thống file 4. Hệ thống FAT 4.1 Boot sector Cấu trúc bảng tham số đĩa cho hệ thống NTFS 2
2d1f518956cdc4b3cf6a9447714cfcd0:136,2d1f518956cdc4b3cf6a9447714cfcd0,136,137,,,107,82 / 107 Chương 4: Quản lý hệ thống file 4. Hệ thống FAT 4.1 Boot sector Boot sectors của một đĩa dùng NTFS
2d1f518956cdc4b3cf6a9447714cfcd0:137,2d1f518956cdc4b3cf6a9447714cfcd0,137,138,,,111,83 / 107 Chương 4: Quản lý hệ thống file 4. Hệ thống FAT 4.1 Boot sector Giải mã bảng tham số của đĩa dùng NTFS
2d1f518956cdc4b3cf6a9447714cfcd0:138,2d1f518956cdc4b3cf6a9447714cfcd0,138,139,,,111,83 / 107 Chương 4: Quản lý hệ thống file 4. Hệ thống FAT 4.1 Boot sector Giải mã bảng tham số của đĩa dùng NTFS
2d1f518956cdc4b3cf6a9447714cfcd0:139,2d1f518956cdc4b3cf6a9447714cfcd0,139,140,,,111,83 / 107 Chương 4: Quản lý hệ thống file 4. Hệ thống FAT 4.1 Boot sector Giải mã bảng tham số của đĩa dùng NTFS
2d1f518956cdc4b3cf6a9447714cfcd0:140,2d1f518956cdc4b3cf6a9447714cfcd0,140,141,,,111,83 / 107 Chương 4: Quản lý hệ thống file 4. Hệ thống FAT 4.1 Boot sector Giải mã bảng tham số của đĩa dùng NTFS
2d1f518956cdc4b3cf6a9447714cfcd0:141,2d1f518956cdc4b3cf6a9447714cfcd0,141,142,,,111,83 / 107 Chương 4: Quản lý hệ thống file 4. Hệ thống FAT 4.1 Boot sector Giải mã bảng tham số của đĩa dùng NTFS
2d1f518956cdc4b3cf6a9447714cfcd0:142,2d1f518956cdc4b3cf6a9447714cfcd0,142,143,,,111,83 / 107 Chương 4: Quản lý hệ thống file 4. Hệ thống FAT 4.1 Boot sector Giải mã bảng tham số của đĩa dùng NTFS
2d1f518956cdc4b3cf6a9447714cfcd0:143,2d1f518956cdc4b3cf6a9447714cfcd0,143,144,,,111,83 / 107 Chương 4: Quản lý hệ thống file 4. Hệ thống FAT 4.1 Boot sector Giải mã bảng tham số của đĩa dùng NTFS
2d1f518956cdc4b3cf6a9447714cfcd0:144,2d1f518956cdc4b3cf6a9447714cfcd0,144,145,,,111,83 / 107 Chương 4: Quản lý hệ thống file 4. Hệ thống FAT 4.1 Boot sector Giải mã bảng tham số của đĩa dùng NTFS
2d1f518956cdc4b3cf6a9447714cfcd0:145,2d1f518956cdc4b3cf6a9447714cfcd0,145,146,,,111,83 / 107 Chương 4: Quản lý hệ thống file 4. Hệ thống FAT 4.1 Boot sector Giải mã bảng tham số của đĩa dùng NTFS
2d1f518956cdc4b3cf6a9447714cfcd0:146,2d1f518956cdc4b3cf6a9447714cfcd0,146,147,,,111,83 / 107 Chương 4: Quản lý hệ thống file 4. Hệ thống FAT 4.1 Boot sector Giải mã bảng tham số của đĩa dùng NTFS
2d1f518956cdc4b3cf6a9447714cfcd0:147,2d1f518956cdc4b3cf6a9447714cfcd0,147,148,,,111,83 / 107 Chương 4: Quản lý hệ thống file 4. Hệ thống FAT 4.1 Boot sector Giải mã bảng tham số của đĩa dùng NTFS
2d1f518956cdc4b3cf6a9447714cfcd0:148,2d1f518956cdc4b3cf6a9447714cfcd0,148,149,,,111,83 / 107 Chương 4: Quản lý hệ thống file 4. Hệ thống FAT 4.1 Boot sector Giải mã bảng tham số của đĩa dùng NTFS
2d1f518956cdc4b3cf6a9447714cfcd0:149,2d1f518956cdc4b3cf6a9447714cfcd0,149,150,,,111,83 / 107 Chương 4: Quản lý hệ thống file 4. Hệ thống FAT 4.1 Boot sector Giải mã bảng tham số của đĩa dùng NTFS
2d1f518956cdc4b3cf6a9447714cfcd0:150,2d1f518956cdc4b3cf6a9447714cfcd0,150,151,,,111,83 / 107 Chương 4: Quản lý hệ thống file 4. Hệ thống FAT 4.1 Boot sector Giải mã bảng tham số của đĩa dùng NTFS
2d1f518956cdc4b3cf6a9447714cfcd0:151,2d1f518956cdc4b3cf6a9447714cfcd0,151,152,,,111,83 / 107 Chương 4: Quản lý hệ thống file 4. Hệ thống FAT 4.1 Boot sector Giải mã bảng tham số của đĩa dùng NTFS
2d1f518956cdc4b3cf6a9447714cfcd0:152,2d1f518956cdc4b3cf6a9447714cfcd0,152,153,,,111,83 / 107 Chương 4: Quản lý hệ thống file 4. Hệ thống FAT 4.1 Boot sector Giải mã bảng tham số của đĩa dùng NTFS
2d1f518956cdc4b3cf6a9447714cfcd0:153,2d1f518956cdc4b3cf6a9447714cfcd0,153,154,,,110,Chương 4: Quản lý hệ thống file 4. Hệ thống FAT l Boot sector l Bảng FAT (File Allocation Table) l Thư mục gốc
2d1f518956cdc4b3cf6a9447714cfcd0:154,2d1f518956cdc4b3cf6a9447714cfcd0,154,155,,,260,FAT được sử dụng để quản lý các khối nhớ (blocks/clusters) trong vùng dữ liệu của bộ nhớ lưu trữ l Khối nhớ đang sử dụng l Phân phối cho từng file/thư mục l Khối nhớ tự do l Khối nhớ bị hỏng Chương 4: Quản lý hệ thống file 4. Hệ thống FAT 4.2 Bảng FAT Mục đích
2d1f518956cdc4b3cf6a9447714cfcd0:155,2d1f518956cdc4b3cf6a9447714cfcd0,155,156,,,360,"DATA #2 #3 #4 #5 #6 #7 #8 #9 Chương 4: Quản lý hệ thống file 4. Hệ thống FAT 4.2 Bảng FAT Phương pháp FAT gồm nhiều phần tử l Mỗi phần tử có thể 12bit, 16bit, 32bit l Mỗi phần tử ứng với 1 khối (cluster) trên vùng dữ liệu l 2 phần tử đầu (0,1) có ý nghĩa đặc biệt l Khuôn dạng đĩa, Bit shutdown, Bit diskerrror l Phần tử thứ 2 ứng với cluster đầu của phần Data"
2d1f518956cdc4b3cf6a9447714cfcd0:156,2d1f518956cdc4b3cf6a9447714cfcd0,156,157,,,637,"FAT[(32)16]12 Ý nghĩa [(0000)0]000h Cluster tương ứng tựdo [(0000)0]001h Giá trịkhông sửdụng [(0000)0]002h →[(0FFF)F]FEFh Cluster đang được sử dụng. Giá trị đóng vai trò con trỏ, trỏtới cluster tiếp theo củafile [(0FFF)F]FF0h Các giá trịđểdành, chưa được sửdụng →[(0FFF)F]FF6h [(0FFF)F]FF7h Đánh dấu cluster tương ứng bị hỏng [(0FFF)F]FF8h→ →[(0FFF)F]FFFh Cluster đang đc sửdụng và là cluster cuối cùng của file (EOC:End Of Cluster chain). Thực tế thường dùng giá trị[(0FFF)F]FFFh Chương 4: Quản lý hệ thống file 4. Hệ thống FAT 4.2 Bảng FAT Cài đặt Mỗi phần tử của bảng FAT mang một giá trị đặc trưng cho tính chất của cluster tương ứng"
2d1f518956cdc4b3cf6a9447714cfcd0:157,2d1f518956cdc4b3cf6a9447714cfcd0,157,158,,,321,Root entry #12 #13 #14 #15 #16 #17 #18 #19 #20 #21 ABC TXT A Time Date 008 Size FAT 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 Special values 03 04 05 FFF 00 00 09 10 12 FF7 15 00 00 16 FFF 00 21 FFF #2 #3 #4 #5 #6 #7 #8 #9 #10 #11 Chương 4: Quản lý hệ thống file 4. Hệ thống FAT 4.2 Bảng FAT Liên kết các cluster DATA
2d1f518956cdc4b3cf6a9447714cfcd0:158,2d1f518956cdc4b3cf6a9447714cfcd0,158,159,,,321,Root entry values Special 03 04 05 FFF 00 00 09 10 12 FF7 15 00 00 16 FFF 00 21 FFF DATA #2 #3 #4 #5 #6 #7 #8 #9 #10 #11 #12 #13 #14 #15 #16 #17 #18 #19 #20 #21 Chương 4: Quản lý hệ thống file 4. Hệ thống FAT 4.2 Bảng FAT Liên kết các cluster ABC TXT A Time Date 008 Size FAT 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19
2d1f518956cdc4b3cf6a9447714cfcd0:159,2d1f518956cdc4b3cf6a9447714cfcd0,159,160,,,320,Root entry values Special 03 04 05 FFF 00 00 09 10 12 FF7 15 00 00 16 FFF 00 21FFF DATA #2 #3 #4 #5 #6 #7 #8 #9 #10 #11 #12 #13 #14 #15 #16 #17 #18 #19 #20 #21 Chương 4: Quản lý hệ thống file 4. Hệ thống FAT 4.2 Bảng FAT Liên kết các cluster ABC TXT A Time Date 008 Size FAT 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19
2d1f518956cdc4b3cf6a9447714cfcd0:160,2d1f518956cdc4b3cf6a9447714cfcd0,160,161,,,320,Root entry values Special 03 04 05 FFF 00 00 09 10 12 FF7 15 00 00 16 FFF 00 21FFF DATA #2 #3 #4 #5 #6 #7 #8 #9 #10 #11 #12 #13 #14 #15 #16 #17 #18 #19 #20 #21 Chương 4: Quản lý hệ thống file 4. Hệ thống FAT 4.2 Bảng FAT Liên kết các cluster ABC TXT A Time Date 008 Size FAT 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19
2d1f518956cdc4b3cf6a9447714cfcd0:161,2d1f518956cdc4b3cf6a9447714cfcd0,161,162,,,321,Root entry values Special 03 04 05 FFF 00 00 09 10 12 FF7 15 00 00 16 FFF 00 21 FFF DATA #2 #3 #4 #5 #6 #7 #8 #9 #10 #11 #12 #13 #14 #15 #16 #17 #18 #19 #20 #21 Chương 4: Quản lý hệ thống file 4. Hệ thống FAT 4.2 Bảng FAT Liên kết các cluster ABC TXT A Time Date 008 Size FAT 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19
2d1f518956cdc4b3cf6a9447714cfcd0:162,2d1f518956cdc4b3cf6a9447714cfcd0,162,163,,,620,"Chương 4: Quản lý hệ thống file 4. Hệ thống FAT 4.2 Bảng FAT Ví dụ: Đọc một sector của FAT32 #include <windows.h> #include <stdio.h> int main(int argc, char *argv[]){ HANDLE hDisk; BYTE Buf[512]; DWORD FAT[128]; WORD FATAddr; DWORD byteread, i; hDisk = CreateFile(""\\\\.\\F:"", GENERIC_READ, FILE_SHARE_READ|FILE_SHARE_WRITE, NULL, OPEN_EXISTING,0,NULL); ReadFile(hDisk,Buf,512,&byteread,NULL); memcpy(&FATAddr,&Buf[14],2);//Offset 14 Sector truoc FAT SetFilePointer(hDisk,FATAddr * 512, NULL,FILE_BEGIN); ReadFile(hDisk,FAT,512,&byteread,NULL); for(i=0;i<128;i++) printf("" %08X "",FAT[i]); CloseHandle(hDisk); return 0; }"
2d1f518956cdc4b3cf6a9447714cfcd0:163,2d1f518956cdc4b3cf6a9447714cfcd0,163,164,,,118,A Root entry 90 / 107 Chương 4: Quản lý hệ thống file 4. Hệ thống FAT 4.2 Bảng FAT Ví dụ: Sector đầu của một FAT32 FAT
2d1f518956cdc4b3cf6a9447714cfcd0:164,2d1f518956cdc4b3cf6a9447714cfcd0,164,165,,,110,Chương 4: Quản lý hệ thống file 4. Hệ thống FAT l Boot sector l Bảng FAT (File Allocation Table) l Thư mục gốc
2d1f518956cdc4b3cf6a9447714cfcd0:165,2d1f518956cdc4b3cf6a9447714cfcd0,165,166,,,544,Chương 4: Quản lý hệ thống file 4. Hệ thống FAT 4.3 Thư mục gốc Cấu trúc thư mục gốc l Bảng gồm các bản ghi file l Mỗi bản ghi có kích thước 32 bytes l Chứa các thông tin liên quan tới một file/thư mục/ nhãn đĩa l Hệ thống FAT12/FAT16 l Thư mục gốc nằm ngay sau các bảng FAT l Kích thước = Số phần tử tối đa trong thư mục gốc * 32 l Hệ thống FAT32 l Vị trí được xác định dựa vào BPB l Trường 18: Số hiệu cluster đầu của ROOT l Kích thước không xác định l Hỗ trợ tên file dài (LFN: Long File Name) l Một file có thể sử dụng nhiều hơn một phần tử
2d1f518956cdc4b3cf6a9447714cfcd0:166,2d1f518956cdc4b3cf6a9447714cfcd0,166,167,,,675,"Stt Ofs Size Ý nghĩa 1 0 8B Tên file 2 8 3B Phần mởrộng 3 11 1B Thuộc tính của file 4 12 10B Không dùng với FAT12/FAT16. Sửdụng với FAT32 4.1 12 1B Đểdành 4.2 13 1B Thời điểm tạo file, theo đơn vị10ms 4.3 14 1W Thời điểm tạo file (giờ- phút - giây ) 4.4 16 1W Ngày tạo file (tạo bởi ứng dụng hoặc bởi copy sang) 4.5 18 1W Ngày truy nhập cu6i 4.6 20 1W Sốhiệu cluster bắt đầu của file(FAT32: Phần cao) 5 22 1W Thời gian cập nhật cuối cùng 6 24 1W Ngày cập nhật cuối (không y/cầu sau ngày tạo file) 7 26 1W Sốhiệu cluster bắt đầu của file (FAT32: Phần thấp) 8 28 1DW Kích thước tính bằng byte Chương 4: Quản lý hệ thống file 4. Hệ thống FAT 4.3 Thư mục gốc Cấu trúc một phần tử"
2d1f518956cdc4b3cf6a9447714cfcd0:167,2d1f518956cdc4b3cf6a9447714cfcd0,167,168,,,959,"Chương 4: Quản lý hệ thống file 4. Hệ thống FAT 4.3 Thư mục gốc Cấu trúc một phần tử :Tên file l Chuỗi ASCII chứa tên file. Các ký tự là chữ in l Không chấp nhận khoảng trống ở giữa l Các câu lệnh copy, del,... không nhận biết tên có dấu trắng l Nếu ít hơn 8 ký tự, được chèn các ký tự trống cho đủ 8 l Ký tự đầu có thể mang ý nghĩa đặc biệt l 00h: Phần tử đầu tiên của phần chưa dùng đến l E5h (ký tự ""δ""): File tương ứng với phần tử này đã bị xóa. l 2Eh (ký tự "". ""): Đây là thư mục con l Trường số hiệu cluster bắt đầu chỉ đến chính nó l Cấu trúc như thư mục con giống như thư mục gốc: gồm các phần tử 32bytes l 2Eh2Eh (ký tự ""..""): Đây là thư mục cha của thư mục hiện tại l Trường số hiệu cluster bắt đầu chỉ đến thư mục cha l Nếu cha là gốc, #cluster bắt đầu bằng zero (FAT12/16) l Thư mục con nằm trên phần Data, được quản lý như một file ⇒ File của các bản ghi file l FAT12/16: Thư mục gốc ở vị trí xác định; FAT32: Thư mục gốc cũng nằm trong phần data"
2d1f518956cdc4b3cf6a9447714cfcd0:168,2d1f518956cdc4b3cf6a9447714cfcd0,168,169,,,260,Name DATA A Clst V 00 Sub-1 D File-A A Sub-2 D ROOT D ... File-F A D Sub-11 D File-B A Sub-directory F F F F .Sub-directory F D D .. File-E A F . D .. D File-C A A File-D Sub-directory Chương 4: Quản lý hệ thống file 4. Hệ thống FAT 4.3 Thư mục gốc Thư mục con
2d1f518956cdc4b3cf6a9447714cfcd0:169,2d1f518956cdc4b3cf6a9447714cfcd0,169,170,,,320,Name DATA A Clst V 00 Sub-1 D File-A A Sub-2 D ROOT . D .. D F ry File-F A Sub-directo Sub-11 D File-B A Sub-directory . D .. D File-E A F F . D .. D File-C A F F F DATA Sub-1 File-F Sub-11 File-C File-D File-B File-A Sub-2 File-E Chương 4: Quản lý hệ thống file 4. Hệ thống FAT 4.3 Thư mục gốc Thư mục con Sub-directory
2d1f518956cdc4b3cf6a9447714cfcd0:170,2d1f518956cdc4b3cf6a9447714cfcd0,170,171,,,309,Ví dụ: Byte thuộc tính 0Fh: 0 0 0 0 1 1 1 1 ⇒Có các thuộc tính Volume label+System+Hidden+Readonly Ghi chú: Giá tri byte thuộc tính 0x0F không sửdụng trong MS-DOS ⇒Dùng đểđánh dấu là phần tửLong File Name Chương 4: Quản lý hệ thống file 4. Hệ thống FAT 4.3 Thư mục gốc Cấu trúc một phần tử : Trường thuộc tính
2d1f518956cdc4b3cf6a9447714cfcd0:171,2d1f518956cdc4b3cf6a9447714cfcd0,171,172,,,162,0 1 1 1 1 1 0 0 0 1 0 1 0 1 1 0 Ví dụ: 15 giờ34 phút 45 giây Chương 4: Quản lý hệ thống file 4. Hệ thống FAT 4.3 Thư mục gốc Cấu trúc một phần tử Có giá trị :7C56
2d1f518956cdc4b3cf6a9447714cfcd0:172,2d1f518956cdc4b3cf6a9447714cfcd0,172,173,,,146,Ví dụ: 17 tháng 5 năm2011 Có giá trị:3EB1 Chương 4: Quản lý hệ thống file 4. Hệ thống FAT 4.3 Thư mục gốc Cấu trúc một phần tử : Trường ngày tháng
2d1f518956cdc4b3cf6a9447714cfcd0:173,2d1f518956cdc4b3cf6a9447714cfcd0,173,174,,,495,"... Phần tửLFN 3 Phần tửLFN 2 Phần tửLFN 1 Phần tử8.3 (ttt∼n.xxx) Ofs Kt Ý nghĩa 0 1B Trưong thứtự. 1 5W 5 ký tựunicode đầu tiên 11 1B Thuộc tính. Đánh dấu là phần tử LFN. Luôn có giá trị0Fh 12 1B Đểdành (00) 13 1B Checksum: Cho phép kiểm tra tên file dài có ứng với tên file 8.3? 14 6W Các ký tựunicode 6,7,8,9,10,11 26 1W Sốhiệu cluster. Không dùng (0000) 28 1W Ký tựunicode 12 30 1W Ký tựunicode 13 Chương 4: Quản lý hệ thống file 4. Hệ thống FAT 4.3 Thư mục gốc Hệ thống Long File Name (LFN)"
2d1f518956cdc4b3cf6a9447714cfcd0:174,2d1f518956cdc4b3cf6a9447714cfcd0,174,175,,,616,"Entry Ord Attr Data LFN 3 0x43 0x0F ame.docx LFN 2 0x02 0x0F y long file n LFN 1 0x01 0x0F This is a ver 8.3 Name THISIS∼1.DOC Chương 4: Quản lý hệ thống file 4. Hệ thống FAT 4.3 Thư mục gốc Hệ thống Long File Name: Trường thứ tự l Cho biết trật tự các phần tử LFN l Mỗi phần tử LFN chứa 13 ký tự Unicode l Phần tử đầu tiên có giá trị trường thứ tự bằng 1 l Phần tử cuối sẽ dùng bít số 6 để đánh dấu l Chỉ dùng tối đa 20 phần tử l Sau ký tự cuối cùng là 0x00 0x00. l Các ký tự không sử dụng có giá trị 0xFF 0xFF l Bít số 7 (0x80) cho biết phần tử tương ứng đã bị xóa l Ví dụ file ""This is a very long file name.docx"""
2d1f518956cdc4b3cf6a9447714cfcd0:175,2d1f518956cdc4b3cf6a9447714cfcd0,175,176,,,90,Chương 4: Quản lý hệ thống file 4. Hệ thống FAT 4.3 Thư mục gốc Ví dụ: Một sector của ROOT
2d1f518956cdc4b3cf6a9447714cfcd0:176,2d1f518956cdc4b3cf6a9447714cfcd0,176,177,,,88,Chương 4: Quản lý hệ thống file 4. Hệ thống FAT 4.3 Thư mục gốc Ví dụ: Nội dụng của ROOT
2d1f518956cdc4b3cf6a9447714cfcd0:177,2d1f518956cdc4b3cf6a9447714cfcd0,177,178,,,76,Chương 4: Quản lý hệ thống file 4. Hệ thống FAT 4.3 Thư mục gốc Giải mã ROOT
2d1f518956cdc4b3cf6a9447714cfcd0:178,2d1f518956cdc4b3cf6a9447714cfcd0,178,179,,,114,DATA Nhãn đĩa #Cluster : 0 Size : 0 Chương 4: Quản lý hệ thống file 4. Hệ thống FAT 4.3 Thư mục gốc Giải mã ROOT 1
2d1f518956cdc4b3cf6a9447714cfcd0:179,2d1f518956cdc4b3cf6a9447714cfcd0,179,180,,,127,DATA Nhãn đĩa #Cluster : 0 Size : 0 File đã bi xóa Chương 4: Quản lý hệ thống file 4. Hệ thống FAT 4.3 Thư mục gốc Giải mã ROOT
2d1f518956cdc4b3cf6a9447714cfcd0:180,2d1f518956cdc4b3cf6a9447714cfcd0,180,181,,,93,File ReadMBR.C Chương 4: Quản lý hệ thống file 4. Hệ thống FAT 4.3 Thư mục gốc Giải mã ROOT 2
2d1f518956cdc4b3cf6a9447714cfcd0:181,2d1f518956cdc4b3cf6a9447714cfcd0,181,182,,,111,File ReadMBR.C Tên file: READMBR Chương 4: Quản lý hệ thống file 4. Hệ thống FAT 4.3 Thư mục gốc Giải mã ROOT 2
2d1f518956cdc4b3cf6a9447714cfcd0:182,2d1f518956cdc4b3cf6a9447714cfcd0,182,183,,,120,File ReadMBR.C Tên file: READMBR Mởrộng:C Chương 4: Quản lý hệ thống file 4. Hệ thống FAT 4.3 Thư mục gốc Giải mã ROOT 2
2d1f518956cdc4b3cf6a9447714cfcd0:183,2d1f518956cdc4b3cf6a9447714cfcd0,183,184,,,128,File ReadMBR.C Tên file: READMBR Mởrộng:C Lưu trữ Chương 4: Quản lý hệ thống file 4. Hệ thống FAT 4.3 Thư mục gốc Giải mã ROOT 2
2d1f518956cdc4b3cf6a9447714cfcd0:184,2d1f518956cdc4b3cf6a9447714cfcd0,184,185,,,134,File ReadMBR.C Tên file: READMBR Mởrộng:C Lưu trữ 600ms Chương 4: Quản lý hệ thống file 4. Hệ thống FAT 4.3 Thư mục gốc Giải mã ROOT 2
2d1f518956cdc4b3cf6a9447714cfcd0:185,2d1f518956cdc4b3cf6a9447714cfcd0,185,186,,,156,File ReadMBR.C Tên file: READMBR Mởrộng:C Lưu trữ 600ms Create time 11h28m12s Chương 4: Quản lý hệ thống file 4. Hệ thống FAT 4.3 Thư mục gốc Giải mã ROOT 2
2d1f518956cdc4b3cf6a9447714cfcd0:186,2d1f518956cdc4b3cf6a9447714cfcd0,186,187,,,179,File ReadMBR.C Tên file: READMBR Create date 05/05/2011 Chương 4: Quản lý hệ thống file 4. Hệ thống FAT 4.3 Thư mục gốc Giải mã ROOT 2 Mởrộng:C Lưu trữ 600ms Create time 11h28m12s
2d1f518956cdc4b3cf6a9447714cfcd0:187,2d1f518956cdc4b3cf6a9447714cfcd0,187,188,,,202,File ReadMBR.C Tên file: READMBR Create date 05/05/2011 Last access 05/05/2011 Chương 4: Quản lý hệ thống file 4. Hệ thống FAT 4.3 Thư mục gốc Giải mã ROOT 2 Mởrộng:C Lưu trữ 600ms Create time 11h28m12s
2d1f518956cdc4b3cf6a9447714cfcd0:188,2d1f518956cdc4b3cf6a9447714cfcd0,188,189,,,226,File ReadMBR.C Tên file: READMBR Create date 05/05/2011 Last access 05/05/2011 Modified time 15h14m30s Chương 4: Quản lý hệ thống file 4. Hệ thống FAT 4.3 Thư mục gốc Giải mã ROOT 2 Mởrộng:C Lưu trữ 600ms Create time 11h28m12s
2d1f518956cdc4b3cf6a9447714cfcd0:189,2d1f518956cdc4b3cf6a9447714cfcd0,189,190,,,251,File ReadMBR.C Tên file: READMBR Create date 05/05/2011 Last access 05/05/2011 Modified time 15h14m30s Modified date 04/05/2011 Chương 4: Quản lý hệ thống file 4. Hệ thống FAT 4.3 Thư mục gốc Giải mã ROOT 2 Mởrộng:C Lưu trữ 600ms Create time 11h28m12s
2d1f518956cdc4b3cf6a9447714cfcd0:190,2d1f518956cdc4b3cf6a9447714cfcd0,190,191,,,271,File ReadMBR.C Tên file: READMBR Create date 05/05/2011 Last access 05/05/2011 Modified time 15h14m30s Modified date 04/05/2011 First cluster 11840 Chương 4: Quản lý hệ thống file 4. Hệ thống FAT 4.3 Thư mục gốc Giải mã ROOT 2 Mởrộng:C Lưu trữ 600ms Create time 11h28m12s
2d1f518956cdc4b3cf6a9447714cfcd0:191,2d1f518956cdc4b3cf6a9447714cfcd0,191,192,,,287,File ReadMBR.C Tên file: READMBR Create date 05/05/2011 Last access 05/05/2011 Modified time 15h14m30s Modified date 04/05/2011 First cluster 11840 File size :2749 Chương 4: Quản lý hệ thống file 4. Hệ thống FAT 4.3 Thư mục gốc Giải mã ROOT 2 Mởrộng:C Lưu trữ 600ms Create time 11h28m12s
2d1f518956cdc4b3cf6a9447714cfcd0:192,2d1f518956cdc4b3cf6a9447714cfcd0,192,193,,,78,Chương 4: Quản lý hệ thống file 4. Hệ thống FAT 4.3 Thư mục gốc Giải mã ROOT 3
2d1f518956cdc4b3cf6a9447714cfcd0:193,2d1f518956cdc4b3cf6a9447714cfcd0,193,194,,,217,Phần tửLFN# 1(ReadBiosSecto) Phần tửLFN#2 - LFN cuối (r.c ) Ký tựsau ký tựcuối (0x0000) Phần tử8.3thường READBI∼1.C Chương 4: Quản lý hệ thống file 4. Hệ thống FAT 4.3 Thư mục gốc Giải mã ROOT 3 File: ReadBiosSector.c
2d1f518956cdc4b3cf6a9447714cfcd0:194,2d1f518956cdc4b3cf6a9447714cfcd0,194,195,,,367,4 Chương 4: Quản lý hệ thống file Kết luận ① Hệ thống file ① Khái niệm file ② Cấu trúc thư mục ② Cài đặt hệ thống file ① Cài đặt thư mục ② Các phương pháp phân phối vùng lưu trữ ③ Quản lý vùng lưu trữ tự do ③ Tổ chức thông tin trên đĩa từ ① Cấu trúc vật lý của đĩa ② Cấu trúc logic của đĩa ④ Hệ thống FAT ① Boot sector ② Bảng FAT (File Allocation Table) ③ Thư mục gốc
74040f5628748874779838fa7a292b09:0,74040f5628748874779838fa7a292b09,0,1,,,143,Hệ Điều Hành (Nguyên lý các hệ điều hành) Đỗ Quốc Huy huydq@soict.hust.edu.vn Bộ môn Khoa Học Máy Tính Viện Công Nghệ Thông Tin và Truyền Thông
74040f5628748874779838fa7a292b09:1,74040f5628748874779838fa7a292b09,1,2,,,251,①Khái niệm Hệ điều hành ②Lịch sử phát triển Hệ điều hành ③Định nghĩa và phân loại Hệ điều hành ④Tính chất cơ bản của Hệ điều hành ⑤Các khái niệm trong Hệ điều hành ⑥Cấu trúc Hệ điều hành ⑦Vấn đề xây dựng Hệ điều hành Chương 1 Tổng quan về Hệ Điều Hành
74040f5628748874779838fa7a292b09:2,74040f5628748874779838fa7a292b09,2,3,,,251,①Khái niệm Hệ điều hành ②Lịch sử phát triển Hệ điều hành ③Định nghĩa và phân loại Hệ điều hành ④Tính chất cơ bản của Hệ điều hành ⑤Các khái niệm trong hệ điều hành ⑥Cấu trúc hệ điều hành ⑦Vấn đề xây dựng Hệ điều hành Chương 1 Tổng quan về Hệ Điều Hành
74040f5628748874779838fa7a292b09:3,74040f5628748874779838fa7a292b09,3,4,,,150,Chương 1 Tổng quan về Hệ Điều Hành 1. Khái niệm Hệ điều hành ①Khái niệm Hệ điều hành lCấu trúc phân lớp của hệ thống tính toán lChức năng hệ điều hành
74040f5628748874779838fa7a292b09:4,74040f5628748874779838fa7a292b09,4,5,,,149,Chương 1 Tổng quan về Hệ Điều Hành 1. Khái niệm Hệ điều hành 1.1. Cấu trúc phân lớp của hệ thống tính toán lSơ đồ kiến trúc của một hệ thống máy tính
74040f5628748874779838fa7a292b09:5,74040f5628748874779838fa7a292b09,5,6,,,379,"Chương 1 Tổng quan về Hệ Điều Hành 1. Khái niệm Hệ điều hành 1.1. Cấu trúc phân lớp của hệ thống tính toán lSơ đồ kiến trúc của một hệ thống máy tính l Một/ nhiều CPUs, các thiết bị điều khiển được liên kết bằng một hệ thống bus chung để truy nhập tới bộ nhớ chia sẻ l Các thiết bị điều khiển và CPU thực hiện đồng thời, cạnh tranh với nhau Bộ vào ra Bộ nhớ Đường Truyền Bộ xử lý"
74040f5628748874779838fa7a292b09:6,74040f5628748874779838fa7a292b09,6,7,,,168,Chương 1 Tổng quan về Hệ Điều Hành 1. Khái niệm Hệ điều hành 1.1. Cấu trúc phân lớp của hệ thống tính toán l Các thành phần của một hệ thống máy tính(Silberschatz 2002)
74040f5628748874779838fa7a292b09:7,74040f5628748874779838fa7a292b09,7,8,,,166,Chương 1 Tổng quan về Hệ Điều Hành 1. Khái niệm Hệ điều hành 1.1. Cấu trúc phân lớp của hệ thống tính toán l Các thành phần của một hệ thống máy tính (Tanenbaum 2001)
74040f5628748874779838fa7a292b09:8,74040f5628748874779838fa7a292b09,8,9,,,618,"Chương 1 Tổng quan về Hệ Điều Hành 1. Khái niệm Hệ điều hành 1.1. Cấu trúc phân lớp của hệ thống tính toán l Các thành phần của một hệ thống máy tính l Phần cứng (Hardware) Cung cấp các tài nguyên tính toán cơ bản (CPU, bộ nhớ, thiết bị vào ra) l Hệ điều hành (Operating system) điều khiển và phối hợp việc sử dụng phần cứng cho những ứng dụng khác nhau của nhiều người sử dụng khác nhau l Chương trình ứng dụng(Application programs) (chương trình dịch, hệ cơ sở dữ liệu, game,...) sử dụng tài nguyên của máy tính để giải quyết các yêu cầu của người sử dụng l Người dùng (Users) Người sử dụng máy móc hay máy tính khác"
74040f5628748874779838fa7a292b09:9,74040f5628748874779838fa7a292b09,9,10,,,533,"Chương 1 Tổng quan về Hệ Điều Hành 1. Khái niệm Hệ điều hành 1.1. Cấu trúc phân lớp của hệ thống tính toán l Mục tiêu l Hệ điều hành (Operating system) nằm giữa phần cứng của hệ thống và các chương trình ứng dụng l Mục tiêu: Cung cấp một môi trường để người sử dụng có thể thực hiện các chương trình ứng dụng và làm cho máy tính dễ sử dụng hơn, thuận lợi hơn và hiệu quả hơn. l Chuẩn hóa giao diện người dùng đối với các hệ thống phần cứng khác nhau l Sử dụng hiệu quả tài nguyên phần cứng và khai thác tối đa hiệu suất của phần cứng"
74040f5628748874779838fa7a292b09:10,74040f5628748874779838fa7a292b09,10,11,,,150,Chương 1 Tổng quan về Hệ Điều Hành 1. Khái niệm Hệ điều hành ①Khái niệm Hệ điều hành lCấu trúc phân lớp của hệ thống tính toán lChức năng hệ điều hành
74040f5628748874779838fa7a292b09:11,74040f5628748874779838fa7a292b09,11,12,,,150,Chương 1 Tổng quan về Hệ Điều Hành 1. Khái niệm Hệ điều hành 1.2. Chức năng của hệ điều hành ①Giả lập một máy tính ảo ②Quản lý tài nguyên của hệ thống
74040f5628748874779838fa7a292b09:12,74040f5628748874779838fa7a292b09,12,13,,,858,"Chương 1 Tổng quan về Hệ Điều Hành 1. Khái niệm Hệ điều hành 1.2. Chức năng của hệ điều hành Giả lập một máy tính ảo Giúp ẩn dấu chi tiết phải thực hiện và khai thác các chức năng của phần cứng máy tính dễ dàng và hiệu quả hơn. l Đơn giản hóa vấn đề lập trình l Không phải làm việc với các dãy nhị phân l Mỗi tiến trình nghĩ nó sở hữu toàn bộ bộ nhớ, thời gian CPU, thiết bị... l Giúp giao tiếp với thiết bị dễ dàng hơn so với phần cứng thuần túy. Ethernet card: Trao đổi tin cậy, theo thứ tự (TCP/IP) l Mở rộng hệ thống →hệ thống dường như có những đặc trưng mong muốn (bộ nhớ ảo, máy in ảo..) l Các tiến trình không ảnh hưởng trực tiếp đến tiến trình khác →lỗi ở một tiến trình không làm hỏng toàn bộ hệ thống l Hữu ích cho phát triển hệ điều hành l Nếu HĐH thử nghiệm bị lỗi, chỉ giới hạn trong máy ảo l Trợ giúp kểm tra các chương trình trên các HĐH khác"
74040f5628748874779838fa7a292b09:13,74040f5628748874779838fa7a292b09,13,14,,,116,Chương 1 Tổng quan về Hệ Điều Hành 1. Khái niệm Hệ điều hành 1.2. Chức năng của hệ điều hành Giả lập một máy tính ảo
74040f5628748874779838fa7a292b09:14,74040f5628748874779838fa7a292b09,14,15,,,747,"Chương 1 Tổng quan về Hệ Điều Hành 1. Khái niệm Hệ điều hành 1.2. Chức năng của hệ điều hành Quản lý tài nguyên của hệ thống l Tài nguyên hệ thống (Vi xử lý, bộ nhớ, thiết bị vào ra, file...) được chương trình sử dụng để thực hiện công việc xác định l Các chương trình đòi hỏi tài nguyên về mặt thời gian (sử dụng) và không gian (nhớ) l Hệ điều hành phải quản lý tài nguyên để hoạt động của máy tính một cách hiệu quả nhất l Phân phối các tài nguyên cho các chương trình khi cần thiết l Giải quyết tranh chấp l Quyết định thứ tự cấp phát tài nguyên cho những yêu cầu l Ví dụ: quản lý tài nguyên bộ nhớ (hữu hạn) l Nhiều chương trình cùng có thể được thực hiện l Tránh truy cập bất hợp lệ l Phải đảm bảo toàn vẹn dữ liệu (dùng chung vùng nhớ: file)"
74040f5628748874779838fa7a292b09:15,74040f5628748874779838fa7a292b09,15,16,,,251,①Khái niệm Hệ điều hành ②Lịch sử phát triển Hệ điều hành ③Các khái niệm trong hệ điều hành ④Định nghĩa và phân loại Hệ điều hành ⑤Tính chất cơ bản của Hệ điều hành ⑥Cấu trúc hệ điều hành ⑦Vấn đề xây dựng Hệ điều hành Chương 1 Tổng quan về Hệ Điều Hành
74040f5628748874779838fa7a292b09:16,74040f5628748874779838fa7a292b09,16,17,,,183,Chương 1 Tổng quan về Hệ Điều Hành 2. Lịch sử phát triển của Hệ điều hành Lịch sử phát triển Hệ điều hành lLịch sử phát triển của máy tính điện tử lLịch sử phát triển của hệ điều hành
74040f5628748874779838fa7a292b09:17,74040f5628748874779838fa7a292b09,17,18,,,552,"Chương 1 Tổng quan về Hệ Điều Hành 2.Lịch sử Hệ điều hành 2.1. Lịch sử phát triển của máy tính điện tử Lịch sử phát triển của máy tính điện tử l 1936 - A. Turing & Church đưa ra mô hình tính toán hình thức và chứng minh sự tồn tại của máy tính vạn năng: Máy Turing lmô hình về thiết bị xử lý các ký tự, tuy đơn giản, nhưng có thể thực hiện được tất cả các thuật toán máy tính lMáy Turing có khả năng mô phỏng lại hoạt động của tất cả các máy Turing khác -> máy Turing vạn năng lTuring được coi là cha đẻ của ngành khoa học máy tính và trí tuệ nhân tạo."
74040f5628748874779838fa7a292b09:18,74040f5628748874779838fa7a292b09,18,19,,,314,Chương 1 Tổng quan về Hệ Điều Hành 2.Lịch sử Hệ điều hành 2.1. Lịch sử phát triển của máy tính điện tử Lịch sử phát triển của máy tính điện tử l 1941- Konrad Zuse (Đức) Xây dựng máy tính Rơle: Máy tính nhị phân lập trình được dựa trên công nghệ cơ điện. lZ3: sử dụng hệ nhị phân lCó bộ nhớ và điều khiển riêng biệt
74040f5628748874779838fa7a292b09:19,74040f5628748874779838fa7a292b09,19,20,,,349,Chương 1 Tổng quan về Hệ Điều Hành 2.Lịch sử Hệ điều hành 2.1. Lịch sử phát triển của máy tính điện tử Lịch sử phát triển của máy tính điện tử l 1946 Máy ENIAC dựa trên đèn điện tử có tốc độ nhanh và độ tin cậy thấp hơn Rơle Sơ đồ Von Neumann ra đời trong giai đoạn này l 18000 ống chân không l 70000 cái điện trở l 5 triệu mối nối hàn bằng kim loại
74040f5628748874779838fa7a292b09:20,74040f5628748874779838fa7a292b09,20,21,,,249,Chương 1 Tổng quan về Hệ Điều Hành 2.Lịch sử Hệ điều hành 2.1. Lịch sử phát triển của máy tính điện tử Lịch sử phát triển của máy tính điện tử l 1950-1958 Dùng đèn điện tử thu nhỏ l 1959-1963 Dùng chất bán dẫn l 1964-1974 Dùng mạch tích hợp thay thế
74040f5628748874779838fa7a292b09:21,74040f5628748874779838fa7a292b09,21,22,,,416,"Chương 1 Tổng quan về Hệ Điều Hành 2.Lịch sử Hệ điều hành 2.1. Lịch sử phát triển của máy tính điện tử Lịch sử phát triển của máy tính điện tử l 1974-1990 Mạch tích hợp cỡ lớn: Kỹ thuật này cho phép sản xuất CPU, bộ nhớ chính hoặc các thiết bị tương tự trong một mạch tích hợp ->phát sinh ra một lớp máy tính rẻ và các bộ xử lý song song gồm nhiều CPUs l 1990-nay Mạch tích hợp cỡ rất lớn và mạch tích hợp thông minh"
74040f5628748874779838fa7a292b09:22,74040f5628748874779838fa7a292b09,22,23,,,183,Chương 1 Tổng quan về Hệ Điều Hành 2. Lịch sử phát triển của Hệ điều hành Lịch sử phát triển Hệ điều hành lLịch sử phát triển của máy tính điện tử lLịch sử phát triển của hệ điều hành
74040f5628748874779838fa7a292b09:23,74040f5628748874779838fa7a292b09,23,24,,,291,"* 1948-1970 : Phần cứng đắt; nhân công rẻ * 1970-1981 : Phần cứng rẻ; nhân công đắt * 1981- : Phần cứng rất rẻ, nhân công rất đắt * 1981- : Các hệ thống phân tán * 1995- : Các thiết bị di động Chương 1 Tổng quan về Hệ Điều Hành 2.Lịch sử Hệ điều hành 2.2. Lịch sử phát triển của Hệ điều hành"
74040f5628748874779838fa7a292b09:24,74040f5628748874779838fa7a292b09,24,25,,,797,"* 1948-1970 : * Máy tính 1-5 M$ : Tài sản quốc gia và sử dụng chủ yếu trong quân sự ⇒Cần tối ưu hóa để sử dụng hiệu quả phần cứng * Thiếu sự tương tác giữa người dùng và máy. * Không phân biệt người sử dụng; người lập trình, thao tác viên Một người dùng tại một thời điểm * Người sử dụng sẽ viết chương trình; gồm nhiều bìa đục lỗ * Tấm bìa đầu tiên là chương trình mồi (bootstraps loader) được đọc vào bộ nhớ và thực hiện * Lệnh trong chương trình mồi đọc vào bộ nhớ và thực hiện các lệnh nằm trên các tấm bìa sau vào bộ nhớ và thực hiện (chương trình ứng dụng) * Xem xét các đèn hiệu (kết quả ), thực hiện gỡ rối * Khó gỡ rối * Lãng phí thời gian máy * Giải pháp: Xử lý theo lô (batch processing) Chương 1 Tổng quan về Hệ Điều Hành 2.Lịch sử Hệ điều hành 2.2. Lịch sử phát triển của Hệ điều hành"
74040f5628748874779838fa7a292b09:25,74040f5628748874779838fa7a292b09,25,26,,,112,* 1948-1970 : Chương 1 Tổng quan về Hệ Điều Hành 2.Lịch sử Hệ điều hành 2.2. Lịch sử phát triển của Hệ điều hành
74040f5628748874779838fa7a292b09:26,74040f5628748874779838fa7a292b09,26,27,,,550,* Xử lý theo lô và có thao tác viên chuyên nghiệp * Người lập trình đưa chương trình cho các thao tác viên * Thao tác viên kết hợp các chương trình thành một gói (batch) * Máy tính đọc và thực hiện lần lượt từng chương trình * Thao tác viên lấy kết quả được in ra và gửi lại người lập trình Chương 1 Tổng quan về Hệ Điều Hành 2.Lịch sử Hệ điều hành 2.2. Lịch sử phát triển của Hệ điều hành l Giảm thời gian đợi giữa các công việc l Vấn đề thắt nút trong thao tác vào/ra l Máy tính ngày càng nhanh l Thiết bị đọc bìa chậm ⇒CPU phải chờ đợi đọc/ghi bìa
74040f5628748874779838fa7a292b09:27,74040f5628748874779838fa7a292b09,27,28,,,544,* Thay thế thiết bị đọc bìa đục lỗ bằng thiết bị băng từ ⇒Máy tính ngoại vi độc lập làm nhiệm vụ đọc ghi dữ liệu * Thiết bị ngoại vi được thiết kế để có thể truy nhập bộ nhớ trực tiếp (DMA: Direct Memory Access) bởi sử dụng cơ chế ngắt và kênh vào ra. * HĐH yêu cầu thiết bị vào/ra thực hiện rồi tiếp tục thực hiện công việc. * HĐH sẽ nhận tín hiệu ngắt khi các thiết bị vào ra thực hiện xong yêu cầu * ⇒Cho phép overlap giữa tính toán và vào ra Chương 1 Tổng quan về Hệ Điều Hành 2.Lịch sử Hệ điều hành 2.2. Lịch sử phát triển của Hệ điều hành
74040f5628748874779838fa7a292b09:28,74040f5628748874779838fa7a292b09,28,29,,,548,l l Lập trình lại CPU để dễ dàng hoán đổi giữa các chương trình l Phần cứng: bộ nhớ có kích thước lớn và rẻ hơn. Một vài chương trình thực hiện đồng thời : Đa chương trình l Có thể overlap nhiều hơn thời gian của CPU và thiết bị vào ra l Đòi hỏi bảo vệ bộ nhớ giữa các chương trình và giữ cho lỗi trong một chương trình không ảnh hưởng tới toàn hệ thống l Vấn đề: Hệ điều hành phải quản lý tất cả tương tác ⇒vượt khỏi tầm kiểm soát (OS360: 1000 lỗi) Chương 1 Tổng quan về Hệ Điều Hành 2.Lịch sử Hệ điều hành 2.2. Lịch sử phát triển của Hệ điều hành
74040f5628748874779838fa7a292b09:29,74040f5628748874779838fa7a292b09,29,30,,,718,"* 1970-1981 : l Các máy tính có giá 10.000$ ⇒được dùng rộng rãi cho nhiều loại việc l Công nghệ HDH đã ổn định. l Sử dụng thiết bị đầu cuối giá rẻ (1000$) cho phép nhiều người dùng cùng tương tác với hệ thống tại một thời điểm l Người sử dụng thực hiện nhiều loại công việc (soạn thảo, chat, gỡ rối chương trình,..) ⇒cần khai thác hệ thống hiệu quả Ví dụ máy PC: 10M phép tính/giây; Tốc độ gõ phím 0.2s/1 ký tự => Mất 2M lệnh trong một lần gõ phím ⇒Hệ điều hành phân chia thời gian l Vấn đề thời gian đáp ứng của hệ thống l Mạng máy tính ra đời (ARPANet : 1968) Truyền thông giữa các máy Bảo vệ chống lại những tấn công Chương 1 Tổng quan về Hệ Điều Hành 2.Lịch sử Hệ điều hành 2.2. Lịch sử phát triển của Hệ điều hành"
74040f5628748874779838fa7a292b09:30,74040f5628748874779838fa7a292b09,30,31,,,666,"* 1981-1995 : l Máy tính có giá trị 1000$; nhân công 100K $/năm ⇒Máy tính được sử dụng rộng rãi để việc hiệu quả hơn l Tính toán cá nhân l Máy tính rẻ, cung cấp cho mỗi người (PC: Máy tính cá nhân). l Hệ điều hành trên máy tính cá nhân l Tài nguyên phần cứng bị giới hạn (Thời gian đầu : 1980s) l HDH trở thành thư viện của các thủ tục cung cấp sẵn l Một chương trình tại một thời điểm (DOS) l Máy tính cá nhân trở nên mạnh l HDH gặp phải những vấn để phức tạp của một HDH lớn như đa nhiệm, bảo vệ bộ nhớ... (WINXP) l Giao diện người sử dung theo đồ họa (MAC, WIN,..) Chương 1 Tổng quan về Hệ Điều Hành 2.Lịch sử Hệ điều hành 2.2. Lịch sử phát triển của Hệ điều hành"
74040f5628748874779838fa7a292b09:31,74040f5628748874779838fa7a292b09,31,32,,,146,* DOS User interface Chương 1 Tổng quan về Hệ Điều Hành 2.Lịch sử Hệ điều hành 2.2. Lịch sử phát triển của Hệ điều hành * Macintosh User interface
74040f5628748874779838fa7a292b09:32,74040f5628748874779838fa7a292b09,32,33,,,98,Chương 1 Tổng quan về Hệ Điều Hành 2.Lịch sử Hệ điều hành 2.2. Lịch sử phát triển của Hệ điều hành
74040f5628748874779838fa7a292b09:33,74040f5628748874779838fa7a292b09,33,34,,,458,"* Các hệ thống phân tán l Giai đoạn phát triển của hệ điều hành mạng và HĐH phân tán Chương 1 Tổng quan về Hệ Điều Hành 2.Lịch sử Hệ điều hành 2.2. Lịch sử phát triển của Hệ điều hành l Các mạng cục bộ l Các máy tính cùng chia xẻ tài nguyên: máy in, File servers,.. l Mô hình Client / Server l Dịch vụ l Tính toán , Lưu trữ l Dịch vụ được cung cấp bởi Internet. l Vấn đề l Độ trễ truyền thông; băng thông, độ tin cậy,.. l Virus (love letter virus 05/2000),.."
74040f5628748874779838fa7a292b09:34,74040f5628748874779838fa7a292b09,34,35,,,200,Chương 1 Tổng quan về Hệ Điều Hành 2.Lịch sử Hệ điều hành 2.2. Lịch sử phát triển của Hệ điều hành -Hơn 45 triệu máy tính bị nhiễm -Ăn cắp thông tin -Tự gửi email từ danh sách liên lạc -Tải các trojan
74040f5628748874779838fa7a292b09:35,74040f5628748874779838fa7a292b09,35,36,,,575,"* Các thiết bị di động trở nên phổ biến * Điện thoại, Laptop, PDA . . . * Nhỏ, khả chuyển và rẻ →Nhiều máy tính/người * Bị giới hạn về khả năng: tốc độ, bộ nhớ,.. * Mạng diện rộng, mạng không dây * Máy tính truyền thống bị phân thành nhiều phần (bàn phím, chuột không dây, lưu trữ từ xa) * Hệ thống ngang hàng (peer-to-peer) * Nhiều thiết bị có cùng vai trò làm việc cùng nhau * Các thành phần của ""hệ điều hành"" trải rộng toàn cầu * Điện toán đám mây * Cloud operating system Chương 1 Tổng quan về Hệ Điều Hành 2.Lịch sử Hệ điều hành 2.2. Lịch sử phát triển của Hệ điều hành"
74040f5628748874779838fa7a292b09:36,74040f5628748874779838fa7a292b09,36,37,,,262,* Kết luận l Sự ra đời và phát triển của hệ điều hành gắn liền với sự phát triển của máy tính l Sự phát triển của hệ điều hành kéo theo sự phát triển của máy tính. Chương 1 Tổng quan về Hệ Điều Hành 2.Lịch sử Hệ điều hành 2.2. Lịch sử phát triển của Hệ điều hành
74040f5628748874779838fa7a292b09:37,74040f5628748874779838fa7a292b09,37,38,,,251,①Khái niệm Hệ điều hành ②Lịch sử phát triển Hệ điều hành ③Định nghĩa và phân loại Hệ điều hành ④Tính chất cơ bản của Hệ điều hành ⑤Các khái niệm trong hệ điều hành ⑥Cấu trúc hệ điều hành ⑦Vấn đề xây dựng Hệ điều hành Chương 1 Tổng quan về Hệ Điều Hành
74040f5628748874779838fa7a292b09:38,74040f5628748874779838fa7a292b09,38,39,,,134,Chương 1 Tổng quan về Hệ Điều Hành 3. Định nghĩa và phân loại Hệ điều hành Định nghĩa và phân loại Hệ điều hành lĐịnh nghĩa lPhân loại
74040f5628748874779838fa7a292b09:39,74040f5628748874779838fa7a292b09,39,40,,,834,"Chương 1 Tổng quan về Hệ Điều Hành 3. Định nghĩa và phân loại Hệ điều hành 3.1. Định nghĩa Góc độ quan sát l Các đối tượng khác nhau có yêu cầu khác nhau về HĐH l Nhiều góc độ quan sát đánh giá ⇒nhiều định nghĩa Người sử dụng Là hệ thống chương trình phục vụ khai thác hệ thống tính toán một cách thuận lợi Người quản lý Là hệ thống chương trình phục vụ quản lý chặt chẽ và sử dụng tối ưu các tài nguyên của hệ thống tính toán Quan điểm kỹ thuật Là một hệ thống chương trình trang bị cho một máy tính cụ thể để tạo ra một máy tính logic mới với tài nguyên mới và khả năng mới Quan điểm hệ thống Là một hệ thống mô hình hoá, mô phỏng hoạt động của máy tính, của người sử dụng và của các thao tác viên, hoạt động trong chế độ đối thoại nhằm tạo môi trường khai thác thuận lợi hệ thống máy tính và quản lý tối ưu tài nguyên của hệ thống."
74040f5628748874779838fa7a292b09:40,74040f5628748874779838fa7a292b09,40,41,,,430,"Chương 1 Tổng quan về Hệ Điều Hành 3. Định nghĩa và phân loại Hệ điều hành 3.1. Định nghĩa Quan điểm hệ thống Mô phỏng 3 thành phần ⇒đòi hỏi 3 loại ngôn ngữ l Ngôn ngữ máy l Là ngôn ngữ thực hiện duy nhất của hệ thống l Mọi ngôn ngữ khác phải dịch ra ngôn ngữ máy l Ngôn ngữ vận hành của hệ thống l Câu lệnh của HĐH (DOS: Dir, Del..; Unix: ls, rm,..) l Dịch bởi Shell l Ngôn ngữ thuật toán l Ngôn ngữ lập trình l Chương trình dịch"
74040f5628748874779838fa7a292b09:41,74040f5628748874779838fa7a292b09,41,42,,,134,Chương 1 Tổng quan về Hệ Điều Hành 3. Định nghĩa và phân loại Hệ điều hành Định nghĩa và phân loại Hệ điều hành lĐịnh nghĩa lPhân loại
74040f5628748874779838fa7a292b09:42,74040f5628748874779838fa7a292b09,42,43,,,276,Chương 1 Tổng quan về Hệ Điều Hành 3. Định nghĩa và phân loại Hệ điều hành 3.2. Phân loại l Hệ thống xử lý theo lô đơn chương trình l Hệ thống xử lý theo lô đa chương trình l Hệ thống phân chia thời gian l Hệ thống song song l Hệ thống phân tán l Hệ thống xử lý thời gian thực
74040f5628748874779838fa7a292b09:43,74040f5628748874779838fa7a292b09,43,44,,,561,"Chương 1 Tổng quan về Hệ Điều Hành 3. Định nghĩa và phân loại Hệ điều hành 3.2. Phân loại Hệ thống xử lý theo lô đơn chương trình l Thực hiện các chương trình lần lượt theo những chỉ thị đã được xác định trước. l Khi một chương trình kết thúc, hệ thống tự động thực hiện chương trình tiếp theo mà không cần sự can thiệp từ bên ngoài l Phải tồn tại bộ giám sát thực hiện dãy các công việc và bộ giám sát phải thường trú trong hệ thống l Đòi hỏi tổ chức hàng đợi công việc l Vấn đề: khi chương trình truy nhập thiết bị vào/ra; processor rơi vào trạng thái chờ đợi"
74040f5628748874779838fa7a292b09:44,74040f5628748874779838fa7a292b09,44,45,,,749,"Chương 1 Tổng quan về Hệ Điều Hành 3. Định nghĩa và phân loại Hệ điều hành 3.2. Phân loại Hệ thống xử lý theo lô đa chương trình l Cho phép thực hiện nhiều chương trình đồng thời l Nạp một phần mã và dữ liệu của các chương trình/tiến trình vào bộ nhớ (phần còn lại sẽ được nạp tại thời điểm thích hợp). Chương trình sẵn sàng được thực hiện l Thực hiện chương trình như hệ thống đơn chương trình l Nếu chương trình thực hiện vào ra, processor được chuyên giao cho chương trình đang sẵn sàng khác l Tiết kiệm bộ nhớ (không cần nạp toàn bộ chương trình vào bộ nhớ) l Hạn chế thời gian rỗi của processor l Chi phí cao cho điều phối processor. Chương trình nào tiếp theo sẽ được sử dụng processor? l Giải quyết vấn đề chia sẻ bộ nhớ giữa các chương trình"
74040f5628748874779838fa7a292b09:45,74040f5628748874779838fa7a292b09,45,46,,,556,"Chương 1 Tổng quan về Hệ Điều Hành 3. Định nghĩa và phân loại Hệ điều hành 3.2. Phân loại Hệ thống phân chia thời gian l Chia sẻ thời gian của processor cho các chương trình/tiến trình đang sẵn sàng thực hiện l Nguyên tắc giống như hệ thống xử lý theo lô đa chương trình (nạp một phần của các chương trình) l Processor được phân phối lại phụ thuộc chủ yếu vào sự điều phối của hệ điều hành ⇒Điều phối như thế nào? ⇒Chương 2 l Thời gian hoán đổi giữa các tiến trình nhỏ, các chương trình cảm giac song song l Thường được gọi: Hệ điều hành đa nhiệm (Windows)"
74040f5628748874779838fa7a292b09:46,74040f5628748874779838fa7a292b09,46,47,,,597,"Chương 1 Tổng quan về Hệ Điều Hành 3. Định nghĩa và phân loại Hệ điều hành 3.2. Phân loại Hệ thống song song l Xây dựng cho các hệ thống có nhiều bộ vi xử lý l Nhiều VXL, công việc thực hiện nhanh chóng hơn l Độ tin cậy cao: hỏng một VXL không ảnh hưởng đến hệ thống l Ưu thế hơn hệ thống nhiều máy có một VXL vì cùng chia xẻ bộ nhớ, thiết bị ngoại vi.. l Đa xử lý đối xứng (SMP: symmetric) l Mỗi bộ xử lý chạy một tiến trình/tiểu trình l Các VXL giao tiếp với nhau thông qua một bộ nhớ dùng chung l Cơ chế chịu lỗi và khả năng cân bằng tải tối ưu l Vấn đề: Đồng bộ giữa các VXL l Ví dụ: HĐH WinNT"
74040f5628748874779838fa7a292b09:47,74040f5628748874779838fa7a292b09,47,48,,,419,Chương 1 Tổng quan về Hệ Điều Hành 3. Định nghĩa và phân loại Hệ điều hành 3.2. Phân loại Hệ thống song song l Đa xử lý không đối xứng (ASMP: asymmetric) l Một bộ xử lý chính kiểm soát toàn bộ hệ thống l Các bộ xử lý khác thực hiện theo lệnh của bộ xử lý chính hoặc theo những chỉ thị đã được định nghĩa trước l Mô hình này theo dạng quan hệ chủ tớ: Bộ xử lý chính sẽ lập lịch cho các bộ xử lý khác l VD: IBM System/360
74040f5628748874779838fa7a292b09:48,74040f5628748874779838fa7a292b09,48,49,,,626,"Chương 1 Tổng quan về Hệ Điều Hành 3. Định nghĩa và phân loại Hệ điều hành 3.2. Phân loại Hệ thống phân tán l Mỗi bộ xử lý có bộ nhớ cục bộ riêng, và trao đổi với nhau thông qua các đường truyền thông l Các VXL thường khác nhau về kích thước và chức năng (Máy cá nhân, máy trạm, máy mini,..) l Hệ thống phân tán được sử dụng để l Chia xẻ tài nguyên : cung cấp cơ chế để chia xẻ tập tin, in ấn tại một vị trí xa... l Tăng tốc độ tính toán: Một thao tác tính toán được chia làm nhiều phần nhỏ được thực hiện một lúc trên nhiều vị trí khác nhau. l An toàn: Một vị trí trong hệ thống bị hỏng, các vị trí khác vẫn tiếp tục làm việc"
74040f5628748874779838fa7a292b09:49,74040f5628748874779838fa7a292b09,49,50,,,410,Chương 1 Tổng quan về Hệ Điều Hành 3. Định nghĩa và phân loại Hệ điều hành 3.2. Phân loại Hệ thống xử lý thời gian thực l Được sử dụng chủ yếu trong lĩnh vực điều khiển. l Giải quyết bài toán không muộn hơn một thời điểm nào đó l Mỗi bài toán có một hạn định (deadline) l Hệ thống phải cho kết quả chính xác trong khoảng thời gian xác định l Hệ điều hành này đòi hỏi sự phối hợp cao giữa phần mềm và phần cứng.
74040f5628748874779838fa7a292b09:50,74040f5628748874779838fa7a292b09,50,51,,,251,①Khái niệm Hệ điều hành ②Lịch sử phát triển Hệ điều hành ③Định nghĩa và phân loại Hệ điều hành ④Tính chất cơ bản của Hệ điều hành ⑤Các khái niệm trong hệ điều hành ⑥Cấu trúc hệ điều hành ⑦Vấn đề xây dựng Hệ điều hành Chương 1 Tổng quan về Hệ Điều Hành
74040f5628748874779838fa7a292b09:51,74040f5628748874779838fa7a292b09,51,52,,,178,Chương 1 Tổng quan về Hệ Điều Hành 4. Tính chất cơ bản của Hệ điều hành Tính chất cơ bản của Hệ điều hành lĐộ tin cậy cao lAn toàn lHiệu quả lTổng quát theo thời gian lThuận tiện
74040f5628748874779838fa7a292b09:52,74040f5628748874779838fa7a292b09,52,53,,,315,"Chương 1 Tổng quan về Hệ Điều Hành 4. Tính chất cơ bản của Hệ điều hành Độ tin cậy cao lMọi hoạt động, thông báo của HĐH phải chuẩn xác lCung cấp thông tin chỉ khi chắc chắn đúng lKhi gặp lỗi: thông báo và ngừng xử lý hoặc trao quyền quyết định cho người dùng lCần có hỗ trợ từ thiết bị lVí dụ: C:/>COPY C:/F.TXT A:"
74040f5628748874779838fa7a292b09:53,74040f5628748874779838fa7a292b09,53,54,,,393,"Chương 1 Tổng quan về Hệ Điều Hành 4. Tính chất cơ bản của Hệ điều hành Độ tin cậy cao lVí dụ: C:/>COPY C:/F.TXT A: lKiểm tra cú pháp của lệnh copy lKiểm tra I/Ocard (động cơ, khả năng truy nhập ổ) lKiểm tra sự tồn tại của file F.TXT trên C lKiểm tra ổ đĩa A lKiểm tra tồn tại file F.TXT trên A Có đủ chỗ trống trên A lĐĩa bị bảo vệ chống ghi lKiểm tra thông tin ghi vào (nếu có yêu cầu) l...."
74040f5628748874779838fa7a292b09:54,74040f5628748874779838fa7a292b09,54,55,,,178,Chương 1 Tổng quan về Hệ Điều Hành 4. Tính chất cơ bản của Hệ điều hành Tính chất cơ bản của Hệ điều hành lĐộ tin cậy cao lAn toàn lHiệu quả lTổng quát theo thời gian lThuận tiện
74040f5628748874779838fa7a292b09:55,74040f5628748874779838fa7a292b09,55,56,,,352,Chương 1 Tổng quan về Hệ Điều Hành 4. Tính chất cơ bản của Hệ điều hành An toàn lDữ liệu và chương trình phải được bảo vệ lKhông bị thay đổi ngoài ý muốn và trong mọi chế độ làm việc lHạn chế truy nhập bất hợp pháp lCác tài nguyên khác nhau có yêu cầu bảo vệ khác nhau lBảo vệ nhiều mức với nhiều công cụ khác nhau lQuan trọng với hệ điều hành đa nhiệm
74040f5628748874779838fa7a292b09:56,74040f5628748874779838fa7a292b09,56,57,,,178,Chương 1 Tổng quan về Hệ Điều Hành 4. Tính chất cơ bản của Hệ điều hành Tính chất cơ bản của Hệ điều hành lĐộ tin cậy cao lAn toàn lHiệu quả lTổng quát theo thời gian lThuận tiện
74040f5628748874779838fa7a292b09:57,74040f5628748874779838fa7a292b09,57,58,,,310,Chương 1 Tổng quan về Hệ Điều Hành 4. Tính chất cơ bản của Hệ điều hành Hiệu quả lCác tài nguyên phải được khai thác triệt để; lTài nguyên hạn chế vẫn giải quyết được những yêu cầu phức tạp. lHệ thống cần phải duy trì được tính đồng bộ; lCác thiết bị tốc độ chậm không ảnh hưởng tới hoạt động của toàn hệ thống
74040f5628748874779838fa7a292b09:58,74040f5628748874779838fa7a292b09,58,59,,,178,Chương 1 Tổng quan về Hệ Điều Hành 4. Tính chất cơ bản của Hệ điều hành Tính chất cơ bản của Hệ điều hành lĐộ tin cậy cao lAn toàn lHiệu quả lTổng quát theo thời gian lThuận tiện
74040f5628748874779838fa7a292b09:59,74040f5628748874779838fa7a292b09,59,60,,,388,"Chương 1 Tổng quan về Hệ Điều Hành 4. Tính chất cơ bản của Hệ điều hành Tổng quát lHệ thống phải có tính kế thừa. lCác thao tác, thông báo không được thay đổi lNếu thay đổi: thông báo và hướng dẫn cụ thể (chkdsk/scandisk) lĐảm bảo tính kế thừa duy trì và phát triển người sử dụng lHệ thống cần phải có khả năng thích nghi với những thay đổi có thể xảy ra l Ví dụ: Vấn đề Y2K; FAT 12/16/32"
74040f5628748874779838fa7a292b09:60,74040f5628748874779838fa7a292b09,60,61,,,178,Chương 1 Tổng quan về Hệ Điều Hành 4. Tính chất cơ bản của Hệ điều hành Tính chất cơ bản của Hệ điều hành lĐộ tin cậy cao lAn toàn lHiệu quả lTổng quát theo thời gian lThuận tiện
74040f5628748874779838fa7a292b09:61,74040f5628748874779838fa7a292b09,61,62,,,160,Chương 1 Tổng quan về Hệ Điều Hành 4. Tính chất cơ bản của Hệ điều hành Thuận tiện lDễ sử dụng lNhiều mức với hiệu quả khác nhau lCó hệ thống trợ giúp phong phú
74040f5628748874779838fa7a292b09:62,74040f5628748874779838fa7a292b09,62,63,,,251,①Khái niệm Hệ điều hành ②Lịch sử phát triển Hệ điều hành ③Định nghĩa và phân loại Hệ điều hành ④Tính chất cơ bản của Hệ điều hành ⑤Các khái niệm trong hệ điều hành ⑥Cấu trúc hệ điều hành ⑦Vấn đề xây dựng Hệ điều hành Chương 1 Tổng quan về Hệ Điều Hành
74040f5628748874779838fa7a292b09:63,74040f5628748874779838fa7a292b09,63,64,,,201,Chương 1 Tổng quan về Hệ Điều Hành 5. Các khái niệm trong Hệ điều hành Các khái niệm trong Hệ điều hành lTiến trình và luồng lTài nguyên hệ thống lBộ xử lý lệnh (Shell) lLời gọi hệ thống (System calls)
74040f5628748874779838fa7a292b09:64,74040f5628748874779838fa7a292b09,64,65,,,504,"Chương 1 Tổng quan về Hệ Điều Hành 5. Các khái niệm trong Hệ điều hành 5.1. Tiến trình và luồng Tiến trình l Tiến trình (tt): một chương trình đang thực hiện lMã lệnh chương trình có thể thực thi lDữ liệu của chương trình lNgăn xếp, con trỏ ngăn xếp, các thanh ghi lCác thông tin cần thiết cho việc thực thi chương trình l Tiến trình >< chương trình l Chương trình: thực thể thụ động, chứa đựng các chỉ thị điều khiển máy tính thực hiện một nhiệm vụ nào đó l Tiến trình: trạng thái động của chương trình."
74040f5628748874779838fa7a292b09:65,74040f5628748874779838fa7a292b09,65,66,,,521,"Chương 1 Tổng quan về Hệ Điều Hành 5. Các khái niệm trong Hệ điều hành 5.1. Tiến trình và luồng Hệ thống đa tiến trình phân chia thời gian: lHĐH theo chu kỳ :dừng một tiến trình để bắt đầu một tt khác lCần lưu thông tin các tt ⇒Bảng tiến trình (process table) lMột tiến trình có thể khởi tạo tiến trình khác lShell của HĐH kích hoạt một tiến trình thực hiện lệnh; thực hiện xong, hủy tiến trình mới được kích hoạt lCác tiến trình có thể trao đổi thông tin với nhau l Một tiến trình có thế bao gồm nhiều luồng (tiểu trình)"
74040f5628748874779838fa7a292b09:66,74040f5628748874779838fa7a292b09,66,67,,,447,"Chương 1 Tổng quan về Hệ Điều Hành 5. Các khái niệm trong Hệ điều hành 5.1. Tiến trình và luồng Luồng (Tiểu trình - Thread) lLuồng: chuỗi (luồng) lệnh được thực hiện trong tiến trình lMã thực thi, dữ liệu lCon trỏ lệnh, ngăn xếp, tập thanh ghi riêng lTiến trình chỉ chứa một luồng (Heavyweight Process) lTiến trình gồm nhiều luồng (Lightweight process) lMô hình đa luồng (Multi_Threading): lCác luồng h/động song song, chia sẻ biến toàn cục của tt"
74040f5628748874779838fa7a292b09:67,74040f5628748874779838fa7a292b09,67,68,,,70,Chương 1 Tổng quan về Hệ Điều Hành 5. Các khái niệm trong Hệ điều hành
74040f5628748874779838fa7a292b09:68,74040f5628748874779838fa7a292b09,68,69,,,201,Chương 1 Tổng quan về Hệ Điều Hành 5. Các khái niệm trong Hệ điều hành Các khái niệm trong Hệ điều hành lTiến trình và luồng lTài nguyên hệ thống lBộ xử lý lệnh (Shell) lLời gọi hệ thống (System calls)
74040f5628748874779838fa7a292b09:69,74040f5628748874779838fa7a292b09,69,70,,,928,"Chương 1 Tổng quan về Hệ Điều Hành 5. Các khái niệm trong Hệ điều hành 5.2 Tài nguyên hệ thống Định nghĩa l Tài nguyên hệ thống là tất cả những gì cần thiết để cho một tiến trình có thể thực hiện được l Không gian: không gian lưu trữ của hệ thống l Thời gian: Thời gian thực hiện lệnh/truy xuất dữ liệu l Tài nguyên hệ thống l Bộ nhớ l Đặc trưng: dung lượng và thời gian truy cập trực tiếp, tuần tự l Phân cấp: bộ nhớ thực hiện/trong; mở rộng; ngoài l Phân biệt các khái niệm: bộ nhớ (vùng vật lý chứa dữ liệu) và truy cập tới bộ nhớ(quá trình tìm đến dữ liệu trên bộ nhớ) l Processor (VXL) l Quan trọng nhất của hệ thống l Được truy cập ở mức câu lệnh l Quan tâm đến thời gian xử lý. l Hệ thống nhiềuVXL thời gian của từng VXL được quản lý và phân phối độc lập l Thiết bị ngoại vi l Tiếp nhận, kết xuất thông tin (thiết bị vào ra) l Gắn với hệ thống bởi các thiết bị điều khiển l Xét chung thiết bị ngoại vi-thiết bị điều khiển"
74040f5628748874779838fa7a292b09:70,74040f5628748874779838fa7a292b09,70,71,,,627,Chương 1 Tổng quan về Hệ Điều Hành 5. Các khái niệm trong Hệ điều hành 5.2 Tài nguyên hệ thống Phân loại tài nguyên l Kiểu tài nguyên lTài nguyên vật lý: Các thiết bị vật lý lTài nguyên logic: biến nhớ; thiết bị ảo l Khả năng sử dụng chung lTài nguyên dùng chung được: tại một thời điểm nó có thể cấp phát cho nhiều tiến trình khác nhau. Ví dụ: Bộ nhớ lTài nguyên không dùng chung được nhưng phân chia được: Các tiến trình sử dụng tài nguyên theo nguyên tắc lần lượt Ví dụ: processor lTài nguyên không dùng chung được và không phân chia được : tại một thời điểm nó chỉ có thể cấp phát cho một tiến trình duy nhất. Ví dụ: Máy in
74040f5628748874779838fa7a292b09:71,74040f5628748874779838fa7a292b09,71,72,,,380,Chương 1 Tổng quan về Hệ Điều Hành 5. Các khái niệm trong Hệ điều hành 5.2 Tài nguyên hệ thống Tài nguyên ảo l Là loại tài nguyên cung cấp cho chương trình người sử dụng dưới dạng đã được biến đổi l Chỉ xuất hiện khi hệ thống cần tới nó hoặc khi hệ thống tạo ra nó l Tự động mất đi khi hệ thống kết thúc hay chính xác hơn là khi tiến trình gắn với nó đã kết thúc. Ví dụ: Máy in ảo
74040f5628748874779838fa7a292b09:72,74040f5628748874779838fa7a292b09,72,73,,,201,Chương 1 Tổng quan về Hệ Điều Hành 5. Các khái niệm trong Hệ điều hành Các khái niệm trong Hệ điều hành lTiến trình và luồng lTài nguyên hệ thống lBộ xử lý lệnh (Shell) lLời gọi hệ thống (System calls)
74040f5628748874779838fa7a292b09:73,74040f5628748874779838fa7a292b09,73,74,,,545,"Chương 1 Tổng quan về Hệ Điều Hành 5. Các khái niệm trong Hệ điều hành 5.3 Bộ xử lý lệnh l Tiến trình đặc biệt: nơi giao tiếp giữa người dùng và hệ điều hành l Nhiệm vụ lNhận lệnh của người sử dụng lPhân tích lệnh lPhát sinh tiến trình mới để thực hiện yêu cầu của lệnh l Nhận lệnh thông qua cơ chế dòng lệnh l Môi trường đơn nhiệm (MS-DOS): lShell sẽ chờ cho tới khi tiến trình này kết thúc mới có thể nhận lệnh mới l Trong môi trường đa nhiệm (UNIX, WINXP,. . .) Sau khi khởi tạo và đưa tiến trình mới vào hoạt động, Shell có thể nhận lệnh mới"
74040f5628748874779838fa7a292b09:74,74040f5628748874779838fa7a292b09,74,75,,,88,Chương 1 Tổng quan về Hệ Điều Hành 5. Các khái niệm trong Hệ điều hành 5.3 Bộ xử lý lệnh
74040f5628748874779838fa7a292b09:75,74040f5628748874779838fa7a292b09,75,76,,,201,Chương 1 Tổng quan về Hệ Điều Hành 5. Các khái niệm trong Hệ điều hành Các khái niệm trong Hệ điều hành lTiến trình và luồng lTài nguyên hệ thống lBộ xử lý lệnh (Shell) lLời gọi hệ thống (System calls)
74040f5628748874779838fa7a292b09:76,74040f5628748874779838fa7a292b09,76,77,,,777,"Chương 1 Tổng quan về Hệ Điều Hành 5. Các khái niệm trong Hệ điều hành 5.4 Lời gọi hệ thống l Tạo môi trường giao tiếp giữa chương trình của người sử dụng và hệ điều hành l Chương trình dùng các lời gọi hệ thống để yêu cầu các dịch vụ từ hệ điều hành l Tạo, xóa, sử dụng các dối tượng phần mềm khác nhau được vận hành bởi hệ điều hành l Mỗi lời gọi hệ thống ứng với một thư viện các chương trình con l Lời gọi hệ thống được thực hiện dưới dạng l Các câu lệnh trong các ngôn ngữ lập trình cấp thấp l Lệnh gọi ngắt trong hợp ngữ (Int) l Thủ tục gọi hàm API trong windows l Tham số cho các dịch vụ và kết quả trả về được đặt tại các vùng nhớ đặc biệt l Ví dụ, khi gọi ngắt, mã chức năng được đặt trong thanh ghi AH l Int 05 : in màn hình ; Int 13/AH=03h - DISK - WRITE DISK SECTOR"
74040f5628748874779838fa7a292b09:77,74040f5628748874779838fa7a292b09,77,78,,,97,Chương 1 Tổng quan về Hệ Điều Hành 5. Các khái niệm trong Hệ điều hành 5.4 Lời gọi hệ thống Ví dụ
74040f5628748874779838fa7a292b09:78,74040f5628748874779838fa7a292b09,78,79,,,251,①Khái niệm Hệ điều hành ②Lịch sử phát triển Hệ điều hành ③Định nghĩa và phân loại Hệ điều hành ④Tính chất cơ bản của Hệ điều hành ⑤Các khái niệm trong hệ điều hành ⑥Cấu trúc hệ điều hành ⑦Vấn đề xây dựng Hệ điều hành Chương 1 Tổng quan về Hệ Điều Hành
74040f5628748874779838fa7a292b09:79,74040f5628748874779838fa7a292b09,79,80,,,151,Chương 1 Tổng quan về Hệ Điều Hành 6. Cấu trúc Hệ điều hành lCác thành phần của hệ thống lDịch vụ Hệ điều hành lLời gọi hệ thống lCác cấu trúc hệ thống
74040f5628748874779838fa7a292b09:80,74040f5628748874779838fa7a292b09,80,81,,,269,Chương 1 Tổng quan về Hệ Điều Hành 6. Cấu trúc Hệ điều hành 6.1 Các thành phần của hệ thống lQuản lý tiến trình lQuản lý bộ nhớ chính lQuản lý hệ thống vào ra lQuản lý file lQuản lý bộ nhớ lưu trữ lHệ thống trao đổi dữ liệu (mạng) lHệ thống bảo vệ lGiao diện người dùng
74040f5628748874779838fa7a292b09:81,74040f5628748874779838fa7a292b09,81,82,,,756,"Chương 1 Tổng quan về Hệ Điều Hành 6. Các khái niệm trong Hệ điều hành 6.1 Các thành phần của hệ thống l Tiến trình: Chương trình đang thực hiện l Tiến trình sử dụng tài nguyên của hệ thống để hoàn thành công việc l Tài nguyên được cấp khi tiến trình được khởi tạo hay khi đang thi hành l Tiến trình kết thúc, tài nguyên được trả về l Hệ thống có thể tồn tại nhiều tiến trình tại một thời điểm l Tiến trình hệ thống l Tiến trình người sử dụng l Nhiệm của hệ điều hành trong việc quản lý tiến trình l Tạo và hủy các tiến trình của người sử dụng và của hệ thống l Ngưng và thực hiện lại một tiến trình l Cung cấp cơ chế đồng bộ tiến trình l Cung cấp cách thông tin giữa các tiến trình l Cung cấp cơ chế kiểm soát bế tắc giữa các tiến trình Quản lý tiến trình"
74040f5628748874779838fa7a292b09:82,74040f5628748874779838fa7a292b09,82,83,,,821,"Chương 1 Tổng quan về Hệ Điều Hành 6. Các khái niệm trong Hệ điều hành 6.1 Các thành phần của hệ thống l Bộ nhớ chính là một mảng kiểu byte (word). Mỗi phần tử có địa chỉ. Đó là nơi lưu dữ liệu được CPU truy xuất l Một chương trình muốn thi hành trước hết phải được ánh xạ thành địa chỉ tuyệt đối và nạp vào bộ nhớ chính.Khi chương trình thi hành, hệ thống truy xuất các chỉ thị và dữ liệu của chương trình trong bộ nhớ chính. l Để tối ưu hóa quá trình hoạt động của CPU và tốc độ của máy tính, một số tiến trình được lưu giữ trong bộ nhớ l Vai trò của Hệ điều hành trong việc quản lý bộ nhớ chính lLưu giữ thông tin về các vị trí trong bộ nhớ đã được sử dụng và ai sử dụng lQuyết định tiến trình nào được nạp vào bộ nhớ chính, khi bộ nhớ đã có thể dùng được lCấp phát và thu hồi bộ nhớ khi cần thiết Quản lý bộ nhớ chính"
74040f5628748874779838fa7a292b09:83,74040f5628748874779838fa7a292b09,83,84,,,541,"Chương 1 Tổng quan về Hệ Điều Hành 6. Các khái niệm trong Hệ điều hành 6.1 Các thành phần của hệ thống l Mục đích: che dấu những đặc thù của các thiết bị phần cứng đối với người sử dụng thay vào đó làm cho người sử dụng dễ thao tác hơn l Quản lý hệ thống vào ra bao gồm lThành phần quản lý bộ nhớ gồm buffering, caching, spooling lGiao tiếp điều khiển thiết bị (device drivers) tổng quát. lBộ điều khiển cho các thiết bị phần cứng đặc biệt. Chỉ có device driver mới hiểu đến cấu trúc đặc thù của thiết bị mà nó mô tả. Quản lý hệ thống vào ra"
74040f5628748874779838fa7a292b09:84,74040f5628748874779838fa7a292b09,84,85,,,429,Chương 1 Tổng quan về Hệ Điều Hành 6. Các khái niệm trong Hệ điều hành 6.1 Các thành phần của hệ thống l Máy tính có thể lưu trữ thông tin trên nhiều loại thiết bị lưu trữ khác nhau l File (Tập tin)đơn vị lưu trữ cơ bản nhất l Nhiệm vụ của quản lý file lTạo/ xoá một tập tin/ thư mục. l Hỗ trợ các thao tác trên file và thư mục lÁnh xạ file trên hệ thống lưu trữ phụ. lBackup hệ thống file trên các thiết bị lưu trữ. Quản lý file
74040f5628748874779838fa7a292b09:85,74040f5628748874779838fa7a292b09,85,86,,,503,Chương 1 Tổng quan về Hệ Điều Hành 6. Các khái niệm trong Hệ điều hành 6.1 Các thành phần của hệ thống l Chương được lưu trữ trên bộ nhớ phụ (đĩa từ) cho tới khi nó được nạp vào trong bộ nhớ chính và thực hiện sử dụng đĩa để chứa dữ liệu và kết quả xử lý l Có thể sử dụng đĩa để chứa dữ liệu và kết quả xử lý tạm thời: bộ nhớ ảo l Vai trò của hệ điều hành trong việc quản lý đĩa lQuản lý vùng trống trên đĩa lCung cấp vùng lưu trữ theo yêu cầu lLập lịch cho truy nhâp đĩa hiệu quả Quản lý bộ nhớ lưu trữ
74040f5628748874779838fa7a292b09:86,74040f5628748874779838fa7a292b09,86,87,,,598,"Chương 1 Tổng quan về Hệ Điều Hành 6. Các khái niệm trong Hệ điều hành 6.1 Các thành phần của hệ thống l Hệ thống phân tán gồm tập các VXL (có thểkhông đồng nhất) không có đồng hồ và bộ nhớ chung. Mỗi VXL có bộ nhớ cục bộ riêng l Các VXL liên kết qua hệ thống mạng truyền thông l Truyền thông được thực hiện nhờ các giao thức (FTP, HTTP...) l Hệ phân tán cho phép người sử dụng truy nhập tới các tài nguyên khác nhau l Truy nhập tới tài nguyên dùng chung cho phép lTăng tốc độ tính toán lTăng khả năng sẵn sàng của dữ liệu lTăng độ tin cậy của hệ thống Hệ thống trao đổi dữ liệu (Hệ thống phân tán)"
74040f5628748874779838fa7a292b09:87,74040f5628748874779838fa7a292b09,87,88,,,496,"Chương 1 Tổng quan về Hệ Điều Hành 6. Các khái niệm trong Hệ điều hành 6.1 Các thành phần của hệ thống l Hệ thống nhiều người dùng đồng thời ⇒Các tiến trình phải được bảo vệ từ các sự hoạt động của tiến trình khác l Bảo vệ là cơ chế kiểm soát truy nhập của chương trình, tiến trình hay người dùng tới hệ thống hoặc các tài nguyên người dùng l Cơ chế bảo vệ đòi hỏi lPhân biệt giữa sử dụng hợp pháp và không hợp pháp lXác lập các kiểm soát được áp đặt lCung cấp phương tiện ép buộc Bảo vệ hệ thống"
74040f5628748874779838fa7a292b09:88,74040f5628748874779838fa7a292b09,88,89,,,476,"Chương 1 Tổng quan về Hệ Điều Hành 6. Các khái niệm trong Hệ điều hành 6.1 Các thành phần của hệ thống l Thực hiện câu lệnh người dùng. Các câu lệnh được cung cấp cho hệ điều hành bởi các câu lệnh điều khiển nhằm l Tạo và quản lý tiến trình l Quản lý bộ nhớ chính, bộ nhớ lưu trữ l Truy nhập hệ thống file l Bảo vệ l Hệ thống mạng l . . . l Giao diện người dùng có thể là dòng lệnh (DOS, UNIX) hay thân thiện hơn nhờ dùng giao diện đồ họa (Windows, MacOS) Giao diện người dùng"
74040f5628748874779838fa7a292b09:89,74040f5628748874779838fa7a292b09,89,90,,,398,"Chương 1 Tổng quan về Hệ Điều Hành 6. Các khái niệm trong Hệ điều hành 6.1 Các thành phần của hệ thống Một số hình thái giao tiếp người máy l Dòng lệnh (Command line) l Đơn giản nhưng có tổ chức l Không đòi hỏi cấu hình phức tạp l Việc gắn thông số vào là hết sức đơn giản l Bảng chọn l Menu l Popup l Menu_popup: 2 phương thức on và onselect l Biểu tượng Cửa sổ, icon, desktop Giao diện người dùng"
74040f5628748874779838fa7a292b09:90,74040f5628748874779838fa7a292b09,90,91,,,151,Chương 1 Tổng quan về Hệ Điều Hành 6. Cấu trúc Hệ điều hành lCác thành phần của hệ thống lDịch vụ Hệ điều hành lLời gọi hệ thống lCác cấu trúc hệ thống
74040f5628748874779838fa7a292b09:91,74040f5628748874779838fa7a292b09,91,92,,,861,"Chương 1 Tổng quan về Hệ Điều Hành 6. Các khái niệm trong Hệ điều hành 6.2 Dịch vụ Hệ điều hành l Thi hành chương trình : nạp chương trình vào bộ nhớ và thi hành. Chấm dứt thi hành theo cách thông thường hay bất thường (lỗi) l Thao tác nhập xuất : Để tăng tính hiệu quả, chương trình không truy xuất trực tiếp các thiết bị vào/ra. HĐH phải cung cấp phương tiện để thực hiện vào ra. l Thao tác trên hệ thống tập tin Chương trình có khả năng đọc, viết tạo xóa file l Truyền thông: Trao đổi thông tin giữa các tiến trình đang thực thi trên cùng một máy hoặc trên các máy trong mạng. Truyền thông được thực hiện nhờ bộ nhớ phân chia hoặc bằng kỹ thuật chuyển thông điệp. l Phát hiện lỗi Đảm bảo thực hiện chính xác bởi chỉ ra lỗi tại CPU, bộ nhớ, trong thiết bị vào ra hay trong các chương trình. Mỗi dạng lỗi, HĐH sẽ có cách giải quyết tương ứng. Dịch vụ chính yếu"
74040f5628748874779838fa7a292b09:92,74040f5628748874779838fa7a292b09,92,93,,,530,"Chương 1 Tổng quan về Hệ Điều Hành 6. Các khái niệm trong Hệ điều hành 6.2 Dịch vụ Hệ điều hành Không nhằm trợ giúp người dùng mà dùng để vận hành hệ thống hiệu quả l Cung cấp tài nguyên Phân phối tài nguyên cho nhiều người dùng hoặc nhiều công việc thực diện trong cùng thời điểm l Thống kê báo cáo Lưu giữ thông tin về loại và số lượng tài nguyên sử dụng, nhằm sử dụng cho tính toán (giá thành sử dụng), nghiên cứu (cải tiến hệ thống) l Bảo vệ Đảm bảo mọi truy nhập tới các tài nguyên hệ thống đều được kiểm soát Dịch vụ phụ trợ"
74040f5628748874779838fa7a292b09:93,74040f5628748874779838fa7a292b09,93,94,,,151,Chương 1 Tổng quan về Hệ Điều Hành 6. Cấu trúc Hệ điều hành lCác thành phần của hệ thống lDịch vụ Hệ điều hành lLời gọi hệ thống lCác cấu trúc hệ thống
74040f5628748874779838fa7a292b09:94,74040f5628748874779838fa7a292b09,94,95,,,180,Chương 1 Tổng quan về Hệ Điều Hành 6. Các khái niệm trong Hệ điều hành 6.3 Lời gọi hệ thống Lời gọi hệ thống cung cấp một giao tiếp giữa tiến trình và hệ điều hành Lời gọi hệ thống
74040f5628748874779838fa7a292b09:95,74040f5628748874779838fa7a292b09,95,96,,,403,"Chương 1 Tổng quan về Hệ Điều Hành 6. Các khái niệm trong Hệ điều hành 6.3 Lời gọi hệ thống lQuản lý tiến trình: khởi tạo tiến trình, huỷ tiến trình.. lQuản lý bộ nhớ: cấp phát và giải phóng bộ nhớ... lQuản lý file: tạo mới, xoá, đọc và ghi file... lQuản lý thiết bị vào ra: thực hiện trao đổi vào/ra... lTrao đổi thông tin với hệ thống lấy/đặt ngày giờ... lTruyền thông liên tiến trình Lời gọi hệ thống"
74040f5628748874779838fa7a292b09:96,74040f5628748874779838fa7a292b09,96,97,,,151,Chương 1 Tổng quan về Hệ Điều Hành 6. Cấu trúc Hệ điều hành lCác thành phần của hệ thống lDịch vụ Hệ điều hành lLời gọi hệ thống lCác cấu trúc hệ thống
74040f5628748874779838fa7a292b09:97,74040f5628748874779838fa7a292b09,97,98,,,132,Chương 1 Tổng quan về Hệ Điều Hành 6. Các khái niệm trong Hệ điều hành 6.4 Các cấu trúc hệ thống Cấu trúc MS-DOS (Silberschatz 2002)
74040f5628748874779838fa7a292b09:98,74040f5628748874779838fa7a292b09,98,99,,,130,Chương 1 Tổng quan về Hệ Điều Hành 6. Các khái niệm trong Hệ điều hành 6.4 Các cấu trúc hệ thống Cấu trúc UNIX (Silberschatz 2002)
74040f5628748874779838fa7a292b09:99,74040f5628748874779838fa7a292b09,99,100,,,130,Chương 1 Tổng quan về Hệ Điều Hành 6. Các khái niệm trong Hệ điều hành 6.4 Các cấu trúc hệ thống Cấu trúc OS/2 (Silberschatz 2002)
74040f5628748874779838fa7a292b09:100,74040f5628748874779838fa7a292b09,100,101,,,123,Chương 1 Tổng quan về Hệ Điều Hành 6. Các khái niệm trong Hệ điều hành 6.4 Các cấu trúc hệ thống Máy ảo (Silberschatz 2002)
74040f5628748874779838fa7a292b09:101,74040f5628748874779838fa7a292b09,101,102,,,135,Chương 1 Tổng quan về Hệ Điều Hành 6. Các khái niệm trong Hệ điều hành 6.4 Các cấu trúc hệ thống Mô hình Client-Server (Tanenbaum 2001)
74040f5628748874779838fa7a292b09:102,74040f5628748874779838fa7a292b09,102,103,,,153,Chương 1 Tổng quan về Hệ Điều Hành 6. Các khái niệm trong Hệ điều hành 6.4 Các cấu trúc hệ thống Mô hình Client-Server trong hệ phân tán (Tanenbaum 2001)
74040f5628748874779838fa7a292b09:103,74040f5628748874779838fa7a292b09,103,104,,,251,①Khái niệm Hệ điều hành ②Lịch sử phát triển Hệ điều hành ③Định nghĩa và phân loại Hệ điều hành ④Tính chất cơ bản của Hệ điều hành ⑤Các khái niệm trong hệ điều hành ⑥Cấu trúc hệ điều hành ⑦Vấn đề xây dựng Hệ điều hành Chương 1 Tổng quan về Hệ Điều Hành
74040f5628748874779838fa7a292b09:104,74040f5628748874779838fa7a292b09,104,105,,,296,Chương 1 Tổng quan về Hệ Điều Hành 7. Vấn đề xây dựng hệ điều hành Nguyên tắc xây dựng hệ điều hành lNguyên tắc modul lNguyên tắc tương đối trong định vị lNguyên tắc macroprocessor lNguyên tắc khởi tạo trong cài đặt lNguyên tắc lặp chức năng lNguyên tắc giá trị chuẩn lNguyên tắc bảo vệ nhiều mức
74040f5628748874779838fa7a292b09:105,74040f5628748874779838fa7a292b09,105,106,,,714,Tóm Lược ① Khái niệm Hệ điều hành l Cấu trúc phân lớp của hệ thống l Chức năng Hệ điều hành ② Lịch sử phát triển Hệ điều hành l Lịch sử phát triển của máy tính điện tử l Lịch sử phát triển Hệ điều hành ③ Định nghĩa và phân loại Hệ điều hành l Định nghĩa l Phân loại Hệ điều hành ④ Tính chất cơ bản của Hệ điều hành l Độ tin cậy cao l An toàn l Hiệu quả l Tổng quát theo thời gian l Thuận tiện Chương 1 Tổng quan về Hệ Điều Hành ⑤Các khái niệm trong hệ điều hành l Tiến trình và luồng l Tài nguyên hệ thống l Bộ xử lý lệnh (Shell) l Lời gọi hệ thống (System calls) ⑥Cấu trúc hệ điều hành l Những thành phần của hệ thống l Dịch vụ Hệ điều Hành l Lời gọi hệ thống l Các cấu trúc hệ thống ⑦Vấn đề xây dựng Hệ điều hành
a3aa8203ae0398a1ef263322bcadebc3:0,a3aa8203ae0398a1ef263322bcadebc3,0,1,,,143,Hệ Điều Hành (Nguyên lý các hệ điều hành) Đỗ Quốc Huy huydq@soict.hust.edu.vn Bộ môn Khoa Học Máy Tính Viện Công Nghệ Thông Tin và Truyền Thông
a3aa8203ae0398a1ef263322bcadebc3:1,a3aa8203ae0398a1ef263322bcadebc3,1,2,,,99,①Nguyên tắc quản lý chung ②Dịch vụ vào ra của hệ thống ③Hệ thống vào ra đĩa Chương 5 Quản lý vào ra
a3aa8203ae0398a1ef263322bcadebc3:2,a3aa8203ae0398a1ef263322bcadebc3,2,3,,,76,lGiới thiệu lNgắt và xử lý ngắt Chương 5: Quản lý vào ra 1. Nguyên tắc chung
a3aa8203ae0398a1ef263322bcadebc3:3,a3aa8203ae0398a1ef263322bcadebc3,3,4,,,140,"Chương 5: Quản lý vào ra 1. Nguyên tắc chung 1.1 Giới thiệu Thiết bị vào ra l Đa dạng, nhiều loại thiết bị, mỗi loại có nhiều kiểu khác nhau"
a3aa8203ae0398a1ef263322bcadebc3:4,a3aa8203ae0398a1ef263322bcadebc3,4,5,,,229,"Chương 5: Quản lý vào ra 1. Nguyên tắc chung 1.1 Giới thiệu Thiết bị vào ra Quan điểm l kỹ thuật: là các thiết bị với bộ VXL, motor, các linh kiện khác l lập trình: Giao diện như phần mềm để nhận lệnh, thực hiện và trả kết quả về"
a3aa8203ae0398a1ef263322bcadebc3:5,a3aa8203ae0398a1ef263322bcadebc3,5,6,,,428,"Chương 5: Quản lý vào ra 1. Nguyên tắc chung 1.1 Giới thiệu Thiết bị vào ra l Phân loại thiết bị ngoại vi l khối (Đĩa từ, băng từ) l Thông tin được lưu trữ có kích thước cố định và địa chỉ riêng l Có thể đọc ghi 1 khối độc lập với khối khác l Tồn tại thao tác định vị thông tin (seek) l ký tự (Máy in, Bàn phím, chuột,..) l Chấp nhận luồng ký tự, không có cấu trúc khối l Không có thao tác định vị thông tin l Loại khác: Đồng hồ"
a3aa8203ae0398a1ef263322bcadebc3:6,a3aa8203ae0398a1ef263322bcadebc3,6,7,,,424,Thiết bị điều khiển I Chương 5: Quản lý vào ra 1. Nguyên tắc chung 1.1 Giới thiệu l Thiết bị ngoại vi (Tbnv) đa dạng và nhiều loại l CPU không biết hết ⇒Không tồn tại tín hiệu riêng cho từng thiết bị l Processor không điều khiển trực tiếp thiết bị l TBNV được nối với hệ thống qua thiết bị điều khiển (D.C - Device Controller-Bộ điều khiển thiết bị) l Các mạch điện tử được cắm trên các khe cắm (slot) của mainboard máy tính
a3aa8203ae0398a1ef263322bcadebc3:7,a3aa8203ae0398a1ef263322bcadebc3,7,8,,,82,Thiết bị điều khiển II Chương 5: Quản lý vào ra 1. Nguyên tắc chung 1.1 Giới thiệu
a3aa8203ae0398a1ef263322bcadebc3:8,a3aa8203ae0398a1ef263322bcadebc3,8,9,,,380,"Thiết bị điều khiển II Chương 5: Quản lý vào ra 1. Nguyên tắc chung 1.1 Giới thiệu l Mỗi TBĐK có thể điều khiển được 1,2,4,.. Tbnv l Tùy theo số giắc cắm có trên TBĐK l Nếu giao diện điều khiển chuẩn (ANSI, IEEE, ISO,...) có thể nối tới nhiều thiết bị khác l Mỗi TBĐK có các thanh ghi riêng để làm việc với CPU l Dùng các không gian địa chỉ đặc biệt cho các thanh ghi: cổng vào ra"
a3aa8203ae0398a1ef263322bcadebc3:9,a3aa8203ae0398a1ef263322bcadebc3,9,10,,,83,Thiết bị điều khiển III Chương 5: Quản lý vào ra 1. Nguyên tắc chung 1.1 Giới thiệu
a3aa8203ae0398a1ef263322bcadebc3:10,a3aa8203ae0398a1ef263322bcadebc3,10,11,,,655,"l Giao diện TBĐK và TBNV: Giao diện mức rất thấp l Sector = 512bytes = 4096bits l Bộ điều khiển đĩa phải đọc/ghi các bit và nhóm lại thành các sector l HĐH chỉ làm việc với các TBĐK l Thông qua các thanh ghi điều khiển của thiết bị l Các câu lệnh và tham số sẽ được đưa vào các thanh ghi điều khiển l Khi 1 lệnh được bộ điều khiển chấp nhận, CPU sẽ để cho bộ điều khiển hoạt động một mình và nó quay sang làm công việc khác l Khi lệnh thực hiện xong, bộ điều khiển sẽ báo cho CPU bằng tín hiệu ngắt l CPU sẽ lấy KQ và trạng thái thiết bị thông qua các thanh ghi điều khiển Chương 5: Quản lý vào ra 1. Nguyên tắc chung 1.1 Giới thiệu Thiết bị điều khiển IV"
a3aa8203ae0398a1ef263322bcadebc3:11,a3aa8203ae0398a1ef263322bcadebc3,11,12,,,716,"Trình điều khiển thiết bị (Device driver) Chương 5: Quản lý vào ra 1. Nguyên tắc chung 1.1 Giới thiệu l Là đoạn mã trong nhân của hệ thống cho phép tương tác trực tiếp với phần cứng thiết bị l Cung cấp 1 giao diện chuẩn cho các Tbnv khác nhau l Các device driver thường được chia làm 2 mức l Mức cao : Được truy nhập qua các lời gọi hệ thống l Cài đặt tập lời gọi chuẩn như open(), close(), read(), write()... l Là giao diện của nhân HĐH với trình điều khiển l Luồng mức cao khởi động thiết bị thực hiện vào/ra và sau đó đặt luồng điều khiển tạm nghỉ l Mức thấp: Được thực hiện như 1 thủ tục ngắt l Đọc dữ liệu đầu vào, hoặc đưa khối dữ liệu tiếp theo ra ngoài l Đánh thức luồng tạm nghỉ mức trên khi vào/ra kết thúc"
a3aa8203ae0398a1ef263322bcadebc3:12,a3aa8203ae0398a1ef263322bcadebc3,12,13,,,89,Chu kỳ của một yêu cầu vào ra Chương 5: Quản lý vào ra 1. Nguyên tắc chung 1.1 Giới thiệu
a3aa8203ae0398a1ef263322bcadebc3:13,a3aa8203ae0398a1ef263322bcadebc3,13,14,,,785,"Giao tiếp thiết bị ngoại vi với hệ điều hành Chương 5: Quản lý vào ra 1. Nguyên tắc chung 1.1 Giới thiệu l Sau khi HĐH gửi yêu cầu ra tbnv, HĐH cần phải biết l Tbnv hoàn thành yêu cầu vào ra l Tbnv gặp lỗi l Có thể thực hiện theo 2 p/pháp Ngắt và thăm dò l Ngắt (I/O interrupts) l Tbnv phát sinh ra 1 tín hiệu ngắt để báo cho CPU biết l IRQ: Đường dẫn vật lý đến bộ quản lý ngắt l Ánh xạ các tín hiệu IRQ thành các vector ngắt l Gọi tới chương trình xử lý ngắt l Thăm dò (polling) l HĐH chu kỳ kiểm tra thanh ghi trạng thái của thiết bị l Lãng phí chu kỳ thăm dò nếu thao tác vào ra không thường xuyên l Các thiệt bị hiện thời có thể kết hợp cả 2 p/pháp (VD Các thiết bị mạng băng thông cao) l Ngắt khi gói tin đầu tiên tới l Thăm dò với các gói tin tiếp theo cho tới khi vùng đệm rỗng"
a3aa8203ae0398a1ef263322bcadebc3:14,a3aa8203ae0398a1ef263322bcadebc3,14,15,,,76,lGiới thiệu lNgắt và xử lý ngắt Chương 5: Quản lý vào ra 1. Nguyên tắc chung
a3aa8203ae0398a1ef263322bcadebc3:15,a3aa8203ae0398a1ef263322bcadebc3,15,16,,,337,Khái niệm ngắt Chương 5: Quản lý vào ra 1. Nguyên tắc chung 1.2 Ngắt và xử lý ngắt Ngắt là phương tiện để cho các thiết bị khác trong hệ thống báo cho processor biết trạng thái của nó Ngắt là hiện tượng dừng đột xuất chương trình để chuyển sang thực hiện chương trình khác ứng với một sự kiện nào đó xảy ra l Ngắt >< chương trình con ! ?
a3aa8203ae0398a1ef263322bcadebc3:16,a3aa8203ae0398a1ef263322bcadebc3,16,17,,,276,Phân loại ngắt Chương 5: Quản lý vào ra 1. Nguyên tắc chung 1.2 Ngắt và xử lý ngắt l Theo nguồn gốc l Ngắt bên trong l Ngắt bên ngoài l Theo thiết bị l Ngắt cứng l Ngắt mềm l Theo khả năng quản lý l Ngắt che được l Ngắt không che được l Theo thời điểm ngắt l Yêu cầu l Báo cáo
a3aa8203ae0398a1ef263322bcadebc3:17,a3aa8203ae0398a1ef263322bcadebc3,17,18,,,353,Xử lý ngắt Chương 5: Quản lý vào ra 1. Nguyên tắc chung 1.2 Ngắt và xử lý ngắt ①Ghi nhận đặc trưng sự kiện gây ngắt vào ô nhớ cố định ②Ghi nhận trạng thái của tiến trình bị ngắt ③Chuyển địa chỉ của chương trình xử lý ngắt vào thanh ghi con trỏ lệnh l Sử dụng bảng vector ngắt (IBM-PC) ④Thực hiện chương trình xử lý ngắt ⑤Khôi phục lại tiến trình bị ngắt
a3aa8203ae0398a1ef263322bcadebc3:18,a3aa8203ae0398a1ef263322bcadebc3,18,19,,,99,①Nguyên tắc quản lý chung ②Dịch vụ vào ra của hệ thống ③Hệ thống vào ra đĩa Chương 5 Quản lý vào ra
a3aa8203ae0398a1ef263322bcadebc3:19,a3aa8203ae0398a1ef263322bcadebc3,19,20,,,123,lVùng đệm (Buffer) lQuản lý lỗi vào ra lKỹ thuật SPOOL Chương 5: Quản lý vào ra 2. Dịch vụ vào ra của hệ thống 2.1 Vùng đệm
a3aa8203ae0398a1ef263322bcadebc3:20,a3aa8203ae0398a1ef263322bcadebc3,20,21,,,521,"Khái niệm chung Chương 5: Quản lý vào ra 2. Dịch vụ vào ra của hệ thống 2.1 Vùng đệm l Đặc trưng của Tbnv: hoạt động chậm l Kích hoạt thiết bị l Chờ đợi thiết bị đạt được trạng thái h/động thích hợp l Chờ đợi các thao tác vào ra được thực hiện l Đảm bảo hiệu năng của hệ thống cần l Giảm số lượng thao tác vào ra, làm việc với từng khối dữ liệu l Thực hiện song song thao tác vào ra với các t/tác khác l Thực hiện trước các phép truy nhập Vùng đệm: Vùng nhớ trung gian, làm nơi lưu trữ thông tin trong các thao tác vào ra"
a3aa8203ae0398a1ef263322bcadebc3:21,a3aa8203ae0398a1ef263322bcadebc3,21,22,,,255,"Phân loại vùng đệm 1 Chương 5: Quản lý vào ra 2. Dịch vụ vào ra của hệ thống 2.1 Vùng đệm l Vùng đệm vào l Có thể thực hiện ngay phép truy nhập dữ liệu l Ví dụ đọc đĩa l Vùng đệm ra l Thông tin được đưa ra vùng đệm, khi nào vùng đệm đầy sẽ đưa ra thiết bị"
a3aa8203ae0398a1ef263322bcadebc3:22,a3aa8203ae0398a1ef263322bcadebc3,22,23,,,678,"Phân loại vùng đệm 2 Chương 5: Quản lý vào ra 2. Dịch vụ vào ra của hệ thống 2.1 Vùng đệm l Vùng đệm gắn với thiết bị l Được xây dựng khi mở thiết bị/file l Phục vụ riêng cho thiết bị bị xóa khi đóng thiết bị l Thích hợp khi các thiết bị có cấu trúc bản ghi vật lý khác nhau l Vùng đệm gắn với hệ thống l Xây dựng khi khởi tạo hệ thống, không gắn với thiết bị cụ thể l Tồn tại trong suốt quá trình hoạt động của hệ thống l Mở file/thiết bị ⇒Gắn với 1 vùng đệm có sẵn l Khi đóng file/thiết bị⇒vùng đệm được trả về hệ thống l Thích hợp khi các thiết bị có cấu trúc bản ghi vật lý chung l Tránh việc tạo xóa vùng đệm nhiều lần l Vùng đệm trở thành các tài nguyên găng ⇒phải điều độ"
a3aa8203ae0398a1ef263322bcadebc3:23,a3aa8203ae0398a1ef263322bcadebc3,23,24,,,226,Phân loại vùng đệm 3 Chương 5: Quản lý vào ra 2. Dịch vụ vào ra của hệ thống 2.1 Vùng đệm l Vùng đệm trung chuyển l Vùng đệm vào l Vùng đệm ra l Vùng đệm xử lý l Vùng đệm vòng tròn l Vùng đệm vào l Vùng đệm ra l Vùng đệm xử lý
a3aa8203ae0398a1ef263322bcadebc3:24,a3aa8203ae0398a1ef263322bcadebc3,24,25,,,134,lVùng đệm (Buffer) lQuản lý lỗi vào ra lKỹ thuật SPOOL Chương 5: Quản lý vào ra 2. Dịch vụ vào ra của hệ thống 2. 2 Quản lý lỗi vào ra
a3aa8203ae0398a1ef263322bcadebc3:25,a3aa8203ae0398a1ef263322bcadebc3,25,26,,,486,"Đặt vấn đề Chương 5: Quản lý vào ra 2. Dịch vụ vào ra của hệ thống 2.2 Quản lý lỗi vào ra l Lỗi luôn có thể xảy ra tại mọi bộ phận của hệ thống l Phần cứng: Intel 486? l Phần mềm: Win 98 ? l Tbnv: Hay gặp lỗi do tác động của môi trường l Xử lý lỗi ⇒Trách nhiệm của hệ thống l Được quan tâm ngay tại giai đoạn thiết kế, chế tạo l Kiểm tra chẵn/lẻ (parity check) l Tổng kiểm tra (check sum) l Các phép kiểm tra do phần cứng/phần mềm đảm nhiệm l Yêu cầu sử dụng linh hoạt các phép kiểm tra"
a3aa8203ae0398a1ef263322bcadebc3:26,a3aa8203ae0398a1ef263322bcadebc3,26,27,,,551,"Xử lý lỗi Chương 5: Quản lý vào ra 2. Dịch vụ vào ra của hệ thống 2.2 Quản lý lỗi vào ra l Phát hiện lỗi -> hệ thống cố gắng khắc phục bằng cách t/hiện lại nhiều lần l Nếu lỗi ổn định ⇒Cố gắng khôi phục lại thông tin ban đầu l Trường hợp lưu trữ, để đảm bảo chất lượng thông tin l TBĐK đọc lại kết quả vừa lưu trữ l So sánh với thông tin gốc/So sánh 2 tổng kiểm tra l Kết quả báo cho hệ thống để có xử lý tương ứng ⇒Lặp lại thao tác/ Thông báo lỗi l Thiết bị vào ra thường cung cấp mã trả về (return code) l Phân tích và đánh giá dựa trên mã nhận được"
a3aa8203ae0398a1ef263322bcadebc3:27,a3aa8203ae0398a1ef263322bcadebc3,27,28,,,129,lVùng đệm (Buffer) lQuản lý lỗi vào ra lKỹ thuật SPOOL Chương 5: Quản lý vào ra 2. Dịch vụ vào ra của hệ thống 2.3 Kỹ thuật SPOOL
a3aa8203ae0398a1ef263322bcadebc3:28,a3aa8203ae0398a1ef263322bcadebc3,28,29,,,560,"Kỹ thuật SPOOL (Simultaneous peripheral operation on-line) Chương 5: Quản lý vào ra 2. Dịch vụ vào ra của hệ thống 2.3 Kỹ thuật SPOOL l Trên phương diện lập trình, Tbvr là l Trạm nhận các yêu cầu từ chương trình và thực hiện l Trả các mã trạng thái để hệ thống phân tích -> có thể dùng phần mềm mô phỏng các Tbvr l Tbvr có thể coi như tiến trình l Được điều độ theo quy tắc quản lý TT l Mục đích l Mô phỏng quá trình điều khiển, quản lý Tbnv l Kiểm tra hoạt động của các thiết bị đang chế tạo l Tạo hiệu ứng sử dụng song song cho các thiết bị truy nhập tuần tự"
a3aa8203ae0398a1ef263322bcadebc3:29,a3aa8203ae0398a1ef263322bcadebc3,29,30,,,106,Kỹ thuật SPOOL: Ví dụ máy in ảo Chương 5: Quản lý vào ra 2. Dịch vụ vào ra của hệ thống 2.3 Kỹ thuật SPOOL
a3aa8203ae0398a1ef263322bcadebc3:30,a3aa8203ae0398a1ef263322bcadebc3,30,31,,,115,Chương 5: Quản lý vào ra 2. Dịch vụ vào ra của hệ thống 2.3 Kỹ thuật SPOOL Kỹ thuật SPOOL: Ví dụnhập xuất thông tin
a3aa8203ae0398a1ef263322bcadebc3:31,a3aa8203ae0398a1ef263322bcadebc3,31,32,,,99,①Nguyên tắc quản lý chung ②Dịch vụ vào ra của hệ thống ③Hệ thống vào ra đĩa Chương 5 Quản lý vào ra
a3aa8203ae0398a1ef263322bcadebc3:32,a3aa8203ae0398a1ef263322bcadebc3,32,33,,,109,lCấu trúc đĩa từ lĐiều phối truy nhập đĩa Chương 5: Quản lý vào ra 3. Hệ thống vào ra đĩa 3.1 Cấu trúc đĩa từ
a3aa8203ae0398a1ef263322bcadebc3:33,a3aa8203ae0398a1ef263322bcadebc3,33,34,,,391,Cấu trúc Chương 5: Quản lý vào ra 3. Hệ thống vào ra đĩa 3.1 Cấu trúc đĩa từ l Mô hình hóa như mảng một chiều các khối logic l Khối logic là đơn vị trao đổi nhỏ nhất l Ánh xạ liên tiếp các khối logic tới các sector của đĩa l Khối 0 là sector đầu mặt 0 rãnh/Cylinder ngoài cùng l Ánh xạ theo trật tự: Sector →Header →Track/Cylinder l Ít phải dịch chuyển đầu từ khi đọc các sector kế tiếp nhau
a3aa8203ae0398a1ef263322bcadebc3:34,a3aa8203ae0398a1ef263322bcadebc3,34,35,,,534,Vấn đề truy nhập đĩa Chương 5: Quản lý vào ra 3. Hệ thống vào ra đĩa 3.1 Cấu trúc đĩa từ l HĐH có trách nhiệm sử dụng hiệu quả phần cứng l Với đĩa: Thời gian truy nhập nhanh và băng thông cao l Băng thông được tính dựa trên l Tổng số bytes đã trao đổi l Khoảng t/gian từ y/cầu dịch vụ đầu tiên cho tới khi hoàn thành l Thời gian truy nhập gồm 2 phần l T/gian định vị (seek time) : T/gian dịch chuyển đầu từ tới cylinders chứa sector cần truy nhập l Độ trễ quay (Rotational latency) :T/gian chờ đợi để đĩa quay tới sector cần truy nhập
a3aa8203ae0398a1ef263322bcadebc3:35,a3aa8203ae0398a1ef263322bcadebc3,35,36,,,368,Vấn đề truy nhập đĩa Chương 5: Quản lý vào ra 3. Hệ thống vào ra đĩa 3.1 Cấu trúc đĩa từ l Mục đích: cực tiểu hóa thời gian định vị l Thời gian định vị ≈khoảng cách dịch chuyển l Hàng đợi yêu cầu l Đĩa và bộ đ/khiển l sẵn sàng -> y/cầu truy nhập đc thực hiện ngay l chưa sẵn sàng -> y/cầu đc đặt trong hàng đợi l Hoàn thành 1 y/cầu truy nhập đĩa -> lựa chọn y/cầu nào?
a3aa8203ae0398a1ef263322bcadebc3:36,a3aa8203ae0398a1ef263322bcadebc3,36,37,,,117,lCấu trúc đĩa từ lĐiều phối truy nhập đĩa Chương 5: Quản lý vào ra 3. Hệ thống vào ra đĩa 3.2 Điều phối truy nhập đĩa
a3aa8203ae0398a1ef263322bcadebc3:37,a3aa8203ae0398a1ef263322bcadebc3,37,38,,,348,"Các thuật toán Chương 5: Quản lý vào ra 3. Hệ thống vào ra đĩa 3. 2 Điều phối truy nhập đĩa Tồn tại một số t/toán điều phối dịch vụ cho y/cầu vào ra đĩa FCFS:First Come First Served SSTF: Shortest Seek Time First SCAN C-SCAN: Circular SCAN LOOK/C-LOOK Giả thiết l Các yêu cầu truy nhập 98, 183, 37, 122, 14, 124, 65, 67 l Đầu đọc đang ở cylinder 53"
a3aa8203ae0398a1ef263322bcadebc3:38,a3aa8203ae0398a1ef263322bcadebc3,38,39,,,216,"FCFS Chương 5: Quản lý vào ra 3. Hệ thống vào ra đĩa 3. 2 Điều phối truy nhập đĩa Truy nhập theo trật tự yêu cầu ⇒Không hiệu quả Yêu cầu truy nhập 98, 183, 37, 122, 14, 124, 65, 67 45 85 59 85 108 110 2 146 Tổng: 630"
a3aa8203ae0398a1ef263322bcadebc3:39,a3aa8203ae0398a1ef263322bcadebc3,39,40,,,311,"SSTF Chương 5: Quản lý vào ra 3. Hệ thống vào ra đĩa 3. 2 Điều phối truy nhập đĩa Chọn truy nhập có t/gian định vị từ vị trí hiện tại nhỏ nhất ⇒Có thể tồn tại y/c phải đợi vô hạn do y/c mới x/hiện gần đầu đọc hơn (tương tự SJF) Yêu cầu truy nhập 98, 183, 37, 122, 14, 124, 65, 67 12 2 2 23 84 24 59 30 Tổng: 236"
a3aa8203ae0398a1ef263322bcadebc3:40,a3aa8203ae0398a1ef263322bcadebc3,40,41,,,331,"SCAN Chương 5: Quản lý vào ra 3. Hệ thống vào ra đĩa 3. 2 Điều phối truy nhập đĩa Đầu từ dich chuyển từ cylinder ngoài cùng đến cylinder trong cùng và quay ngược lại. Phục vụ cho các yêu cầu gặp trên đường đi Yêu cầu truy nhập 98, 183, 37, 122, 14, 124, 65, 67 15 23 24 65 2 31 2 14 Tổng: 235 59 Đầu từ đang dịch về phía cylinder 0"
a3aa8203ae0398a1ef263322bcadebc3:41,a3aa8203ae0398a1ef263322bcadebc3,41,42,,,701,"C-SCAN Chương 5: Quản lý vào ra 3. Hệ thống vào ra đĩa 3. 2 Điều phối truy nhập đĩa Nguyên tắc: Xử lý các cylinders như một danh sách nối vòng: Cylinder ngoài cùng nối tiếp với cylinder trong cùng l Đầu từ d/chuyển từ cylinder ngoài cùng -> cylinder trong cùng l Phục vụ cho các y/cầu gặp trên đường đi l Khi tới Cylinder trong cùng, quay ngược lại Cylinder ngoài cùng l Không phục vụ cho các y/cầu gặp trên đường đi l Nhận xét: l Thu được thời gian đợi đồng nhất hơn thuật toán SCAN l Khi đầu đọc đạt tới 1 phía của đĩa (cylinders trong cùng, ngoài cùng), mật độ các y/cầu xuất hiện ở phía bên kia > vị trí hiện tại (do vừa đi qua). l Các y/cầu này cũng đợi lâu hơn ⇒Quay ngay lập tức về phía bên kia"
a3aa8203ae0398a1ef263322bcadebc3:42,a3aa8203ae0398a1ef263322bcadebc3,42,43,,,262,"C-SCAN Chương 5: Quản lý vào ra 3. Hệ thống vào ra đĩa 3. 2 Điều phối truy nhập đĩa Đầu từ dich chuyển từ cylinder ngoài cùng đến cylinder trong cùng và quay ngược lại. Phục vụ cho các yêu cầu gặp trên đường đi Yêu cầu truy nhập 98, 183, 37, 122, 14, 124, 65, 67"
a3aa8203ae0398a1ef263322bcadebc3:43,a3aa8203ae0398a1ef263322bcadebc3,43,44,,,284,"LOOK/ C-LOOK Chương 5: Quản lý vào ra 3. Hệ thống vào ra đĩa 3. 2 Điều phối truy nhập đĩa Phiên bản của SCAN/C-SCAN: Đầu đọc không di chuyển tới các cylinders ngoài/trong cùng mà chỉ đến các y/cầu xa nhất về 2 phía rồi quay lại ngay Yêu cầu truy nhập 98, 183, 37, 122, 14, 124, 65, 67"
a3aa8203ae0398a1ef263322bcadebc3:44,a3aa8203ae0398a1ef263322bcadebc3,44,45,,,749,"Vấn đề lựa chọn thuật toán Chương 5: Quản lý vào ra 3. Hệ thống vào ra đĩa 3. 2 Điều phối truy nhập đĩa l SSTF: Phổ biến, hiệu quả hơn FCFS l SCAN/C-SCAN hoạt động tốt hơn cho hệ thống có nhiều y/cầu truy nhập đĩa l Không gặp vấn đề ""starvation: chờ đợi quá lâu"" l Hiệu quả của các t/toán phụ thuộc số lượng và kiểu các y/cầu l Y/cầu truy xuất đĩa bị ảnh hưởng bởi các p/pháp phân phối đĩa cho file l P/phối liên tục: đưa ra các y/cầu truy xuất lân cận nhau l P/phối liên kết/ chỉ mục: có thể gồm các khối được phân bố rộng rãi trên đĩa l T/toán điều phối truy nhập đĩa có thể được viết như những modul riêng biệt của HĐH cho phép có thể thay thế bởi các t/toán khác khi cần thiết l Cả SSTF và LOOK đều có thể là lựa chọn hợp lý cho t/ toán mặc định"
a3aa8203ae0398a1ef263322bcadebc3:45,a3aa8203ae0398a1ef263322bcadebc3,45,46,,,260,Kết chương Chương 5: Quản lý vào ra 1. Nguyên tắc quản lý chung 1. Giới thiệu 2. Ngắt và xử lý ngắt 2. Dịch vụ vào ra của hệ thống 1. Vùng đệm (Buffer) 2. Quản lý lỗi vào ra 3. Kỹ thuật SPOOL 3. Hệ thống vào ra đĩa 1. Cấu trúc đĩa từ 2. Điều phối truy nhập đĩa
ea73ad6304ed438f7e7d4c59ddd227a1:0,ea73ad6304ed438f7e7d4c59ddd227a1,0,1,,,143,Hệ Điều Hành (Nguyên lý các hệ điều hành) Đỗ Quốc Huy huydq@soict.hust.edu.vn Bộ môn Khoa Học Máy Tính Viện Công Nghệ Thông Tin và Truyền Thông
ea73ad6304ed438f7e7d4c59ddd227a1:1,ea73ad6304ed438f7e7d4c59ddd227a1,1,2,,,50,①Định nghĩa tiến trình Chương 2 Quản lý tiến trình
ea73ad6304ed438f7e7d4c59ddd227a1:2,ea73ad6304ed438f7e7d4c59ddd227a1,2,3,,,747,"Tiến trình (nhắc lại) lKhi chương trình đang thực hiện l Được cung cấp tài nguyên (CPU, bộ nhớ, thiết bị vào/ra. . .) để hoàn thành công việc l Tài nguyên được cấp khi: l Bắt đầu chương trình l Trong khi chương trình đang thực hiện lGọi là tiến trình (process) lHệ thống bao gồm tập các tiến trình thực hiện đồng thời l Tiến trình hệ điều hành Thực hiện mã lệnh hệ thống l Tiến trình người dùng Thực hiện mã lệnh người dùng lTiến trình có thể chứa một hoặc nhiều tiểu trình lTrách nhiệm của Hệ điều hành: l Đảm bảo họat động của tiến trình và tiểu trình (luồng) l Tạo/xóa tiến trình (người dùng, hệ thống) l Điều phối tiến trình l Cung cấp cơ chế đồng bộ, truyền thông và ngăn ngừa tình trạng bế tắc giữa các tiến trình Chương 2 Quản lý tiến trình"
ea73ad6304ed438f7e7d4c59ddd227a1:3,ea73ad6304ed438f7e7d4c59ddd227a1,3,4,,,133,Chương 2 Quản lí tiến trình ①Tiến trình ②Luồng (Thread) ③Điều phối CPU ④Tài nguyên găng và điều độ tiến trình ⑤Bế tắc và xử lý bế tắc
ea73ad6304ed438f7e7d4c59ddd227a1:4,ea73ad6304ed438f7e7d4c59ddd227a1,4,5,,,208,Chương 2 Quản lí tiến trình 1. Tiến trình 1.1. Khái niệm tiến trình lKhái niệm tiến trình lĐiều phối tiến trình (Process Scheduling) lThao tác trên tiến trình lHợp tác tiến trình lTruyền thông liên tiến trình
ea73ad6304ed438f7e7d4c59ddd227a1:5,ea73ad6304ed438f7e7d4c59ddd227a1,5,6,,,554,"Chương 2 Quản lí tiến trình 1. Tiến trình 1.1. Khái niệm tiến trình * Trạng thái hệ thống l Vi xử lý: Giá trị các thanh ghi l Bộ nhớ: Nội dung các ô nhớ l Thiết bị ngoại vi: Trạng thái thiết bị l Thực hiện chương trình ⇒Trạng thái hệ thống thay đổi l Thay đổi rời rạc, theo từng câu lệnh được thực hiện l Tiến trình là một dãy thay đổi trạng thái của hệ thống l Xuất phát từ một trạng thái ban đầu l Chuyển từ trạng thái này sang trạng thái khác được thực hiện theo yêu cầu nằm trong chương trình của người sử dụng Tiến trình là sự thực hiện chương trình"
ea73ad6304ed438f7e7d4c59ddd227a1:6,ea73ad6304ed438f7e7d4c59ddd227a1,6,7,,,837,"Chương 2 Quản lí tiến trình 1. Tiến trình 1.1. Khái niệm tiến trình l Chương trình: thực thể thụ động (nội dung file trên đĩa) l Mã chương trình: Lệnh máy (CD2190EA...) l Dữ liệu: l Biến được lưu trữ và sử dụng trong bộ nhớ l Biến toàn cục l Biến được cung cấp động (malloc, new,..) l Biến stack (tham số hàm, biến cục bộ) l Thư viện liên kết động (DLL) l Không được dịch & liên kết cùng với chương trình Khi chương trình đang thực hiện, tài nguyên tối thiểu cần có l Bộ nhớ cho mã chương trình và dữ liệu l Các thanh ghi của VXL phục vụ cho quá trình thực hiện l Tiến trình: thực thể chủ động (bộ đếm lệnh, tập tài nguyên) Một chương trình có thể l Chỉ là một phần của trạng thái tiến trình l Một chương trình, nhiều tiến trình( bộ dữ liệu khác nhau) VD: gcc hello.c || gcc baitap.c l Gọi tới nhiều tiến trình Tiến trình >< chương trình"
ea73ad6304ed438f7e7d4c59ddd227a1:7,ea73ad6304ed438f7e7d4c59ddd227a1,7,8,,,102,Chương 2 Quản lí tiến trình 1. Tiến trình 1.1. Khái niệm tiến trình Dịch và thực hiên một chương trình
ea73ad6304ed438f7e7d4c59ddd227a1:8,ea73ad6304ed438f7e7d4c59ddd227a1,8,9,,,781,"Chương 2 Quản lí tiến trình 1. Tiến trình 1.1. Khái niệm tiến trình l Hệ điều hành tạo một tiến trình và phân phối vùng nhớ cho nó l Bộ thực hiện (loader/exec) l Đọc và dịch (interprets) file thực thi (header file) l Thiết lập không gian địa chỉ cho tiến trình để chứa mã lệnh và dữ liệu từ file thực thi l Đặt các tham số dòng lệnh, biến môi trường (argc, argv, envp) vào stack l Thiết lập các thanh ghi của VXL tới các giá trị thích hợp và gọi hàm ""_start()"" (hàm của hệ điều hành) l Chương trình bắt đầu thực hiện tại ""_start()"". Hàm này gọi tới hàm main()(hàm của chương trình) ⇒""Tiến trình"" đang thực hiện, không còn đề cập đến ""chương trình"" nữa l Khi hàm main() kết thúc, OS gọi tới hàm ""_exit()"" để hủy bỏ tiến trình và thu hồi tài nguyên Dịch và thực hiên một chương trình"
ea73ad6304ed438f7e7d4c59ddd227a1:9,ea73ad6304ed438f7e7d4c59ddd227a1,9,10,,,549,"Chương 2 Quản lí tiến trình 1. Tiến trình 1.1. Khái niệm tiến trình Khi thực hiện, tiến trình thay đổi trạng thái l Khởi tạo (New) Tiến trình đang được khởi tạo l Sẵn sàng (Ready) Tiến trình đang đợi sử dụng processor vật lý l Thực hiện (Running) Các câu lệnh của tiến trình đang được thực hiện l Chờ đợi (Waiting) Tiến trình đang chờ đợi một sự kiện nào đó xuất hiện (sự hoàn thành thao tác vào/ra) l Kết thúc (Terminated) Tiến trình thực hiện xong Trạng thái của tiến trình là một phần trong hoạt động hiện tại của tiến trình Trạng thái tiến trình"
ea73ad6304ed438f7e7d4c59ddd227a1:10,ea73ad6304ed438f7e7d4c59ddd227a1,10,11,,,267,Chương 2 Quản lí tiến trình 1. Tiến trình 1.1. Khái niệm tiến trình Lưu đồ thay đổi trạng thái tiến trình (Silberschatz 2002) Hệ thống có một processor l Có duy nhất một tiến trình ở trạng thái thực hiện l Có thể có nhiều tiến trình ở trạng thái chờ đợi hoặc sẵn sàng
ea73ad6304ed438f7e7d4c59ddd227a1:11,ea73ad6304ed438f7e7d4c59ddd227a1,11,12,,,488,Chương 2 Quản lí tiến trình 1. Tiến trình 1.1. Khái niệm tiến trình Khối điều khiển tiến trình (PCB: Process Control Block) l Trạng thái tiến trình l Bộ đếm lệnh l Các thanh ghi của CPU l Thông tin dùng để điều phối tiến trình l Thông tin quản lý bộ nhớ l Thông tin tài nguyên có thể sử dụng l Thông tin thống kê l Con trỏ tới một PCB khác l . . . l Mỗi tiến trình được thể hiện trong hệ thống bởi một khối điều khiển tiến trình l PCB: cấu trúc thông tin cho phép xác định duy nhất một tt
ea73ad6304ed438f7e7d4c59ddd227a1:12,ea73ad6304ed438f7e7d4c59ddd227a1,12,13,,,88,Chương 2 Quản lí tiến trình 1. Tiến trình 1.1. Khái niệm tiến trình Danh sách tiến trình
ea73ad6304ed438f7e7d4c59ddd227a1:13,ea73ad6304ed438f7e7d4c59ddd227a1,13,14,,,363,Chương 2 Quản lí tiến trình 1. Tiến trình 1.1. Khái niệm tiến trình Tiến trình đơn luồng và tiến trình đa luồng l Tiến trình đơn luồng : Là chương trình thực hiện chỉ một luồng thực thi ⇒Cho phép thực hiện chỉ một nhiệm vụ tại một thời điểm l Tiến trình đa luồng : Là tiến trình có nhiều luồng thực thi ⇒Cho phép thực hiện nhiều hơn một nhiệm vụ tại một thời điểm
ea73ad6304ed438f7e7d4c59ddd227a1:14,ea73ad6304ed438f7e7d4c59ddd227a1,14,15,,,213,Chương 2 Quản lí tiến trình 1. Tiến trình 1.1. Điều phối tiến trình * Khái niệm tiến trình * Điều phối tiến trình (Process Scheduling) * Thao tác trên tiến trình * Hợp tác tiến trình * Truyền thông liên tiến trình
ea73ad6304ed438f7e7d4c59ddd227a1:15,ea73ad6304ed438f7e7d4c59ddd227a1,15,16,,,337,Chương 2 Quản lí tiến trình 1. Tiến trình 1.2. Điều phối tiến trình Giới thiệu Mục đích Sử dụng tối đa thời gian của CPU ⇒Cần có nhiều tiến trình trong hệ thống Vấn đề Luân chuyển CPU giữa các tiến trình ⇒Phải có hàng đợi cho các tiến trình Hệ thống một processor ⇒Một tiến trình thực hiện ⇒Các tiến trình khác phải đợi tới khi CPU tự do
ea73ad6304ed438f7e7d4c59ddd227a1:16,ea73ad6304ed438f7e7d4c59ddd227a1,16,17,,,390,"Chương 2 Quản lí tiến trình 1. Tiến trình 1.2. Điều phối tiến trình Các hàng đợi tiến trình I Hệ thống có nhiều hàng đợi dành cho tiến trình l Job-queue Tập các tiến trình trong hệ thống l Ready-Queue Tập các tiến trình tồn tại trong bộ nhớ, đang sẵn sàng và chờ đợi để được thực hiện l Device queues Tập các tiến trình đang chờ đợi một thiết bị vào ra. Phân biệt hàng đợi cho từng thiết bị"
ea73ad6304ed438f7e7d4c59ddd227a1:17,ea73ad6304ed438f7e7d4c59ddd227a1,17,18,,,247,"Chương 2 Quản lí tiến trình 1. Tiến trình 1.2. Điều phối tiến trình Các hàng đợi tiến trình II l Các tiến trình di chuyển giữa hàng đợi khác nhau l Tiến trình mới tạo, được đặt trong hàng đợi sẵn sàng, và đợi cho tới khi được lựa chọn để thực hiện"
ea73ad6304ed438f7e7d4c59ddd227a1:18,ea73ad6304ed438f7e7d4c59ddd227a1,18,19,,,630,"Chương 2 Quản lí tiến trình 1. Tiến trình 1.2. Điều phối tiến trình Các hàng đợi tiến trình III l Tiến trình đã được chọn và đang thực hiên ①Đưa ra một yêu cầu vào ra: đợi trong một hàng đợi thiết bị ②Tạo một tiến trình con và đợi tiến trình con kết thúc ③Hết thời gian sử dụng CPU, phải quay lại hàng đợi sẵn sàng l Trường hợp (1&2) sau khi sự kiện chờ đợi hoàn thành, l Tiến trình sẽ chuyển từ trạng thái đợi sang trạng thái sẵn sàng l Tiến trình quay lại hàng đợi sẵn sàng l Tiến trình tiếp tục chu kỳ (sẵn sàng, thực hiện, chờ đợi) cho tới khi kết thúc l Xóa khỏi tất cả các hàng đợi l PCB và tài nguyên đã cấp được giải phóng"
ea73ad6304ed438f7e7d4c59ddd227a1:19,ea73ad6304ed438f7e7d4c59ddd227a1,19,20,,,244,Chương 2 Quản lí tiến trình 1. Tiến trình 1.2. Điều phối tiến trình Bộ điều phối (Scheduler) Lựa chọn tiến trình trong các hàng đợi l Điều phối công việc (Job scheduler; Long-term scheduler) l Điều phối CPU (CPU scheduler; Short-term scheduler)
ea73ad6304ed438f7e7d4c59ddd227a1:20,ea73ad6304ed438f7e7d4c59ddd227a1,20,21,,,709,"Chương 2 Quản lí tiến trình 1. Tiến trình 1.2. Điều phối tiến trình Điều phối công việc l Chọn các tiến trình từ hàng đợi tiến trình được lưu trong các vùng đệm (đĩa từ) và đưa vào bộ nhớ để thực hiện l Thực hiện không thường xuyên (đơn vị giây/phút) l Điều khiển mức độ đa chương trình (số t/trình trong bộ nhớ) l Khi mức độ đa chương trình ổn định, điều phối công việc được gọi chỉ khi có tiến trình rời khỏi hệ thống l Vấn đề lựa chọn công việc l Tiến trình thiên về vào/ra: sử dụng ít thời gian CPU l Tiến trình thiên về tính toán: sử dụng nhiều thời gian CPU l Cần lựa chọn lẫn cả 2 loại tiến trình ⇒tt vào ra: hàng đợi sẵn sàng rỗng, lãng phí CPU ⇒tt tính toán: hàng đợi thiết bị rỗng, lãng phí thiết bị"
ea73ad6304ed438f7e7d4c59ddd227a1:21,ea73ad6304ed438f7e7d4c59ddd227a1,21,22,,,668,"Chương 2 Quản lí tiến trình 1. Tiến trình 1.2. Điều phối tiến trình Điều phối CPU l Lựa chọn một tiến trình từ hàng đợi các tiến trình đang sẵn sàng thực hiện và phân phối CPU cho nó l Được thực hiện thường xuyên (VD: 100ms/lần) l Tiến trình thực hiện vài ms rồi thực hiện vào ra l Lựa chọn tiến trình mới, đang sẵn sàng l Phải thực hiện nhanh l 10ms để quyết định ⇒10/(110)=9% thời gian CPU lãng phí l Vấn đề luân chuyển CPU từ tiến trình này tới tiến trình khác l Phải lưu trạng thái của tiến trình cũ (PCB) và khôi phục trạng thái cho tiến trình mới l Thời gian luân chuyển là lãng phí l Có thể được hỗ trợ bởi phần cứng l Vấn đề lựa chọn tiến trình (điều phối CPU)"
ea73ad6304ed438f7e7d4c59ddd227a1:22,ea73ad6304ed438f7e7d4c59ddd227a1,22,23,,,330,"Chương 2 Quản lí tiến trình 1. Tiến trình 1.2. Điều phối tiến trình Hoán chuyển tiến trình (Medium-term scheduler) l Nhiệm vụ l Đưa t/trình ra khỏi bộ nhớ (làm giảm mức độ đa chương trình) l Sau đó đưa tiến trình quay trở lại (có thểở vị trí khác) và tiếp tục thực hiện l Mục đích: Giải phóng vùng nhớ, tạo vùng nhớ tự do rộng hơn"
ea73ad6304ed438f7e7d4c59ddd227a1:23,ea73ad6304ed438f7e7d4c59ddd227a1,23,24,,,359,Chương 2 Quản lí tiến trình 1. Tiến trình 1.2. Điều phối tiến trình Chuyển ngữ cảnh (context switch) l Chuyển CPU từ tiến trình này sang tiến trình khác (hoán đổi tiến trình thực hiện) l Thực hiện khi xuất hiện tín hiệu ngắt (ngắt thời gian) hoặc tiến trình đưa ra lời gọi hệ thống (thực hiện và ra) l Lưu đồ của chuyển CPU giữa các t/trình(Silberschatz 2002)
ea73ad6304ed438f7e7d4c59ddd227a1:24,ea73ad6304ed438f7e7d4c59ddd227a1,24,25,,,217,Chương 2 Quản lí tiến trình 1. Tiến trình 1.3. Thao tác trên tiến trình * Khái niệm tiến trình * Điều phối tiến trình (Process Scheduling) * Thao tác trên tiến trình * Hợp tác tiến trình * Truyền thông liên tiến trình
ea73ad6304ed438f7e7d4c59ddd227a1:25,ea73ad6304ed438f7e7d4c59ddd227a1,25,26,,,135,Chương 2 Quản lí tiến trình 1. Tiến trình 1.3. Thao tác trên tiến trình l Tạo tiến trình l Kết thúc tiến trình Thao tác trên tiến trình
ea73ad6304ed438f7e7d4c59ddd227a1:26,ea73ad6304ed438f7e7d4c59ddd227a1,26,27,,,675,"Chương 2 Quản lí tiến trình 1. Tiến trình 1.3. Thao tác trên tiến trình l Tiến trình có thể tạo nhiều tiến trình mới cùng hoạt động (CreateProcess(), fork()) l Tiến trình tạo: tiến trình cha l Tiến trình được tạo: tiến trình con l Tiến trình con có thể tạo tiến trình con khác ⇒Cây tiến trình l Vấn đề phân phối tài nguyên l Tiến trình con lấy tài nguyên từ hệ điều hành l Tiến trình con lấy tài nguyên từ tiến trình cha l Tất cả các tài nguyên l Một phần tài nguyên của tiến trình cha (ngăn ngừa việc tạo quá nhiều tiến trình con) l Vấn đề thực hiện l Tiến trình cha tiếp tục thực hiện đồng thời với tiến trình con l Tiến trình cha đợi tiến trình con kết thúc Tạo tiến trình"
ea73ad6304ed438f7e7d4c59ddd227a1:27,ea73ad6304ed438f7e7d4c59ddd227a1,27,28,,,779,Chương 2 Quản lí tiến trình 1. Tiến trình 1.3. Thao tác trên tiến trình l Hoàn thành câu lệnh cuối và yêu cầu HĐH xóa nó (exit) l Gửi trả dữ liệu tới tiến trình cha l Các tài nguyên đã cung cấp được trả lại hệ thống l Tiến trình cha có thể kết thúc sự thực hiện của tiến trình con l Tiến trình cha phải biết định danh tiến trình con ⇒tiến trình con phải gửi định danh cho tiến trình cha khi được khởi tạo l Sử dụng lời gọi hệ thống (abort) l Tiến trình cha kết thúc tiến trình con khi l Tiến trình con sử dụng vượt quá mức tài nguyên được cấp l Nhiệm vụ cung cấp cho tiến trình con không còn cần thiết nữa l Tiến trình cha kết thúc và hệ điều hành không cho phép tiến trình con tồn tại khi tiến trình cha kết thúc ⇒Cascading termination. VD: kết thúc hệ thống Kết thúc tiến trình
ea73ad6304ed438f7e7d4c59ddd227a1:28,ea73ad6304ed438f7e7d4c59ddd227a1,28,29,,,836,"Chương 2 Quản lí tiến trình 1. Tiến trình 1.3. Thao tác trên tiến trình l CreateProcess(. . .) l LPCTSTR Tên của chương trình được thực hiện l LPTSTR Tham số dòng lệnh l LPSECURITY_ATTRIBUTES Thuộc tính an ninh t/trình l LPSECURITY_ATTRIBUTES Thuộc tính an ninh luồng l BOOL Cho phép kế thừa các thẻ thiết bị (TRUE/FALSE) l DWORD Cờ tạo tiến trình (VD CREATE_NEW_CONSOLE) l LPVOID Trỏ tới khối môi trường l LPCTSTR Đường dẫn đầy đủ đến chương trình l LPSTARTUPINFO Cấu trúc thông tin cho tiến trình mới l LPPROCESS_INFORMATION Thông tin về tiến trình mới l TerminateProcess(HANDLE hProcess, UINT uExitCode) l hProcess Thẻ tiến trình bị kết thúc đóng l uExitCode Mã kết thúc tiến trình l WaitForSingleObject(HANDLE hHandle, DWORD dwMs) l hHandle Thẻ đối tượng l dwMs Thời gian chờ đợi (INFINITE) Một số hàm với tiến trình trong WIN32 API"
ea73ad6304ed438f7e7d4c59ddd227a1:29,ea73ad6304ed438f7e7d4c59ddd227a1,29,30,,,211,Chương 2 Quản lí tiến trình 1. Tiến trình 1.4. Hợp tác tiến trình * Khái niệm tiến trình * Điều phối tiến trình (Process Scheduling) * Thao tác trên tiến trình * Hợp tác tiến trình * Truyền thông liên tiến trình
ea73ad6304ed438f7e7d4c59ddd227a1:30,ea73ad6304ed438f7e7d4c59ddd227a1,30,31,,,211,Chương 2 Quản lí tiến trình 1. Tiến trình 1.4. Hợp tác tiến trình * Khái niệm tiến trình * Điều phối tiến trình (Process Scheduling) * Thao tác trên tiến trình * Hợp tác tiến trình * Truyền thông liên tiến trình
ea73ad6304ed438f7e7d4c59ddd227a1:31,ea73ad6304ed438f7e7d4c59ddd227a1,31,32,,,716,Chương 2 Quản lí tiến trình 1. Tiến trình 1.4. Hợp tác tiến trình l Các tiến trình tuần tự l Điểm bắt đầu của tiến trình này nằm sau điểm kết thúc của tiến trình kia l Các tiến trình song song l Điểm bắt đầu của tiến trình này nằm giữa điểm bắt đầu và kết thúc của tiến trình kia l Độc lập: Không ảnh hưởng tới hoặc bị ảnh hưởng bởi tiến trình khác đang thực hiện trong hệ thống l Có hợp tác: Ảnh hưởng tới hoặc chịu ảnh hưởng bởi tiến trình khác đang thực hiện trong hệ thống l Hợp tác tiến trình nhằm l Chia sẻ thông tin l Tăng tốc độ tính toán: l Module hóa l Tiện dụng l Hợp tác tiến trình đòi hỏi cơ chế cho phép l Truyền thông giữa các tiến trình l Đồng bộ hóa hoạt động của các tiến trình Phân loại tiến trình
ea73ad6304ed438f7e7d4c59ddd227a1:32,ea73ad6304ed438f7e7d4c59ddd227a1,32,33,,,526,"• Hệ thống gồm 2 tiến trình • Producer sản xuất ra các sản phẩm • Consumer tiêu thụ các sản phẩm được sản xuất ra • Ứng dụng • Chương trình in (producer) sản xuất ra các ký tự được tiêu thụ bởi bộ điều khiển máy in (consumer) • Trình dịch (producer) sản xuất ra mã hợp ngữ, trình hợp ngữ (consumer/producer) tiêu thụ mã hợp ngữ rồi sản xuất ra module đối tượng được bộ thực hiện (consumer) tiêu thụ Chương 2 Quản lí tiến trình 1. Tiến trình 1.4. Hợp tác tiến trình Bài toán người sản xuất (producer)-người tiêu thụ(consumer) I"
ea73ad6304ed438f7e7d4c59ddd227a1:33,ea73ad6304ed438f7e7d4c59ddd227a1,33,34,,,749,"• Producer và Consumer hoạt động đồng thời Sử dụng vùng đệm dùng chung (Buffer) chứa sản phẩm được điền vào bởi producer và được lấy ra bởi consumer • IN Vị trí trống kế tiếp trong vùng đệm; • OUT Vị trí đầy đầu tiên trong vùng đệm. • Counter Số sản phẩm trong vùng đệm • Producer và Consumer phải đồng bộ • Consumer không cố gắng tiêu thụ một sản phẩm chưa được sản xuất • Vùng đệm dung lượng vô hạn • Khi Buffer rỗng, Consumer phải đợi • Producer không phải đợi khi đặt sản phẩm vào buffer • Vùng đệm dung lượng hữu hạn • Khi Buffer rỗng, Consumer phải đợi • Producer phải đợi nếu vùng đệm đầy Chương 2 Quản lí tiến trình 1. Tiến trình 1.4. Hợp tác tiến trình Bài toán người sản xuất (producer)-người tiêu thụ(consumer) II"
ea73ad6304ed438f7e7d4c59ddd227a1:34,ea73ad6304ed438f7e7d4c59ddd227a1,34,35,,,465,while(1) { /*produce an item in nextProduced*/ while (Counter == BUFFER_SIZE) ; /*do nothing*/ Buffer[IN] = nextProduced; IN = (IN + 1) % BUFFER_SIZE; Counter++; } while(1){ while(Counter == 0) ; /*do nothing*/ nextConsumed = Buffer[OUT]; OUT =(OUT + 1) % BUFFER_SIZE; Counter--; /*consume the item in nextConsumed*/ } Chương 2 Quản lí tiến trình 1. Tiến trình 1.4. Hợp tác tiến trình Bài toán người sản xuất (producer)-người tiêu thụ(consumer) II Producer Consumer
ea73ad6304ed438f7e7d4c59ddd227a1:35,ea73ad6304ed438f7e7d4c59ddd227a1,35,36,,,221,Chương 2 Quản lí tiến trình 1. Tiến trình 1.5. Truyền thông liên tiến trình * Khái niệm tiến trình * Điều phối tiến trình (Process Scheduling) * Thao tác trên tiến trình * Hợp tác tiến trình * Truyền thông liên tiến trình
ea73ad6304ed438f7e7d4c59ddd227a1:36,ea73ad6304ed438f7e7d4c59ddd227a1,36,37,,,578,Chương 2 Quản lí tiến trình 1. Tiến trình 1.5. Truyền thông liên tiến trình • Dùng mô hình bộ nhớ phân chia • Các tiến trình chia sẻ vùng nhớ chính • Mã cài đặt được viết tường minh bởi người lập trình ứng dụng • Ví dụ: Bài toán Producer-Consumer • Dùng mô hình truyền thông liên tiến trình (Interprocess communication) • Là cơ chế cho phép các tiến trình truyền thông và đồ ng bộ các hoạt động • Thường được sử dụng trong các hệ phân tán khi các tiến trình truyền thông nằm trên các máy khác nhau (chat) • Đảm bảo bởi hệ thống truyền thông điệp Trao đổi giữa các tiến trình
ea73ad6304ed438f7e7d4c59ddd227a1:37,ea73ad6304ed438f7e7d4c59ddd227a1,37,38,,,576,"Chương 2 Quản lí tiến trình 1. Tiến trình 1.5. Truyền thông liên tiến trình • Cho phép các tiến trình trao đổi với nhau không qua sử dụng các biến phân chia • Yêu cầu 2 thao tác cơ bản • Send (msg) Các msg có kích thước cố định hoặc thay đổi • Cố định : dễ cài đặt mức hệ thống, nhiệm vụ lập trình khó • Thay đổi: cài đặt mức hệ thống phức tạp, lập trình đơn giản • Receive (msg) • Nếu 2 tiến trình P và Q muốn trao đổi, chúng cần • Thiết lập một liên kết truyền thông (vật lý/logic) giữa chúng • Trao đổi các messages nhờ các thao tác send/receive Hệ thống truyền thông điệp"
ea73ad6304ed438f7e7d4c59ddd227a1:38,ea73ad6304ed438f7e7d4c59ddd227a1,38,39,,,375,Chương 2 Quản lí tiến trình 1. Tiến trình 1.5. Truyền thông liên tiến trình lCác vấn đề cài đặt l Các liên kết được thiết lập như thế nào? l Một liên kết có thể dùng cho nhiều hơn 2 tiến trình? l Bao nhiêu liên kết có thể tồn tại giữa mọi cặp tiến trình? l Kích thước thông báo mà liên kết chấp nhận cố định/thay đổi? l Liên kết một hay hai chiều? Hệ thống truyền thông điệp
ea73ad6304ed438f7e7d4c59ddd227a1:39,ea73ad6304ed438f7e7d4c59ddd227a1,39,40,,,518,"Chương 2 Quản lí tiến trình 1. Tiến trình 1.5. Truyền thông liên tiến trình lCác tiến trình phải gọi tên tiến trình nhận/gửi một cách tường minh l send (P, message) - gửi một thống báo tới tiến trình P l receive(Q, message) - Nhận một thông báo từ tiến trình Q lTính chất của liên kết truyền thông l Các liên kết được thiết lập tự động l Một liên kết gắn chỉ với cặp tiến trình truyền thông l Chỉ tồn tại một liên kết giữa cặp tiến trình l Liên kết có thể là một chiều, nhưng thường hai chiều Truyền thông trực tiếp"
ea73ad6304ed438f7e7d4c59ddd227a1:40,ea73ad6304ed438f7e7d4c59ddd227a1,40,41,,,716,"Chương 2 Quản lí tiến trình 1. Tiến trình 1.5. Truyền thông liên tiến trình l Các thông điệp được gửi/nhận tới/từ các hòm thư (mailboxes), cổng (ports) l Mỗi hòm thư có định danh duy nhất l Các tiến trình có thể trao đổi nếu chúng dùng chung hòm thư l Tính chất các liên kết l Các liên kết được thiết lập chỉ khi các tiến trình dùng chung hòm thư l Một liên kết có thể được gắn với nhiều tiến trình l Mỗi cặp tiến trình có thể dùng chung nhiều liên kết truyền thông l Liên kết có thể một hay hai chiều l Các thao tác l Tạo hòm thư l Gửi/nhận thông báo qua hòm thư l send(A, msg): Gửi một msg tới hòm thư A l receive(A, msg): Nhận một msg từ hòm thư A lHủy bỏ hòm thư Truyền thông gián tiếp"
ea73ad6304ed438f7e7d4c59ddd227a1:41,ea73ad6304ed438f7e7d4c59ddd227a1,41,42,,,711,"Chương 2 Quản lí tiến trình 1. Tiến trình 1.5. Truyền thông liên tiến trình l Truyền thông điệp có thể phải chờ đợi (blocking), hoặc không chờ đợi (non blocking) l Blocking Truyền thông đồng bộ l Non-blocking Truyền thông không đồng bộ l Các thủ tục send() và receive() có thể bị chờ đợi hoặc không chờ đợi l Blocking send Tiến trình gửi thông báo và đợi cho tới khi msg được nhận bởi tiến trình nhận hoặc bởi hòm thư l Non blockking send Tiến trình gửi thông báo và tiếp tục làm việc l Blocking receive Tiến trình nhận phải đợi cho tới khi có thông báo l Non-blocking receive Tiến trình nhận trả về hoặc một thông báo có giá trị, hoặc một giá trị null Vấn đề đồng bộ hoá"
ea73ad6304ed438f7e7d4c59ddd227a1:42,ea73ad6304ed438f7e7d4c59ddd227a1,42,43,,,727,"Chương 2 Quản lí tiến trình 1. Tiến trình 1.5. Truyền thông liên tiến trình • Các thông điệp trao đổi giữa các tiến trình được lưu trong hàng đợi tạm thời • Hàng đợi có thể được cài đặt theo • Khả năng chứa 0 (Zero capacity): Độ dài hàng đợi là 0 • Không tồn tại thông điệp trong đường liên kết ⇒ Sender phải đợi cho t ới khi thông điệp được nhận • Khả năng chứa có giới hạn(Bound capacity) • Hàng đợi có độ dài n ⇒ chứa nhiều nhất n thông điệp • Nếu hàng đợi không đầy, thông điệp sẽ được lưu vào trong vùng đệm và Sender tiếp tục bình thường • Nếu hàng đợi đầy, sender phải đợi cho tới khi có chỗ trống • Khả năng chứa không giới hạn (Unbound capacity) • Sender không bao giờ phải đợi Vùng đệm"
ea73ad6304ed438f7e7d4c59ddd227a1:43,ea73ad6304ed438f7e7d4c59ddd227a1,43,44,,,124,Chương 2 Quản lí tiến trình 1. Tiến trình 1.5. Truyền thông liên tiến trình Windows XP Truyền thông điệp giữa các tiến trình
ea73ad6304ed438f7e7d4c59ddd227a1:44,ea73ad6304ed438f7e7d4c59ddd227a1,44,45,,,679,"Chương 2 Quản lí tiến trình 1. Tiến trình 1.5. Truyền thông liên tiến trình • Được xem như đầu mút cho truyền thông, qua đó các ứng dụng g ửi/nhận dữ liệu qua mạng • Truyền thông thực hiện giữa các cặp Sockets • Bao gồm cặp địa chỉ IP và cổng. Ví dụ: 161.25.19.8:1625 • Địa chỉ IP: Địa chỉ của máy trong mạng • Cổng (port): Định danh tiến trình tham gia trao đổi trên máy • Các loại sockets • Stream Socket: Dựa trên giao thức TCP/IP →Truyền dữ liệu tin cậy • Datagram Socket: Dựa trên giao thức UDP/IP →Truyền dữ liệu không tin cậy • Win32 API: Winsock • Windows Sockets Application Programming Interface Truyền thông trong hệ thống Client-Server với Socket"
ea73ad6304ed438f7e7d4c59ddd227a1:45,ea73ad6304ed438f7e7d4c59ddd227a1,45,46,,,112,Chương 2 Quản lí tiến trình 1. Tiến trình 1.5. Truyền thông liên tiến trình Thiết lập quá trình trao đổi dữ liệu
ea73ad6304ed438f7e7d4c59ddd227a1:46,ea73ad6304ed438f7e7d4c59ddd227a1,46,47,,,513,Chương 2 Quản lí tiến trình 1. Tiến trình 1.5. Truyền thông liên tiến trình Một số hàm trong Winsock API 32 socket()Tạo socket truyền dữ liệu bind() Định danh cho socket vừa tạo (gán cho một cổng) listen() Lắng nghe một kết nối accept() Chấp nhận một kết nối connect() kết nối với server. send() Gửi dữ liệu với stream socket. sendto() Gửi dữ liệu với datagram socket. receive() Nhận dữ liệu với stream socket. recvfrom() Nhận dữ liệu với datagram socket. closesocket() Kết thúc một socket đã tồn tại. ..........
ea73ad6304ed438f7e7d4c59ddd227a1:47,ea73ad6304ed438f7e7d4c59ddd227a1,47,48,,,165,Chương 2 Quản lí tiến trình 1. Tiến trình 1.5. Truyền thông liên tiến trình Bài tập Sử dụng Winsock xây dựng chương trình Client-Server Chương trình Chat. ..........
ea73ad6304ed438f7e7d4c59ddd227a1:48,ea73ad6304ed438f7e7d4c59ddd227a1,48,49,,,133,Chương 2 Quản lí tiến trình ①Tiến trình ②Luồng (Thread) ③Điều phối CPU ④Tài nguyên găng và điều độ tiến trình ⑤Bế tắc và xử lý bế tắc
ea73ad6304ed438f7e7d4c59ddd227a1:49,ea73ad6304ed438f7e7d4c59ddd227a1,49,50,,,126,Chương 2 Quản lí tiến trình 2. Luồng 2.1. Giới thiệu lGiới thiệu lMô hình đa luồng lCài đặt luồng với Windows lVấn đề đa luồng
ea73ad6304ed438f7e7d4c59ddd227a1:50,ea73ad6304ed438f7e7d4c59ddd227a1,50,51,,,191,Chương 2 Quản lí tiến trình 2. Luồng 2.1. Giới thiệu lTính toán trên vector kích thước lớn For (k = 0;k < n;k++) { a[k] = b[k]*c[k]; } Với hệ thống nhiều vi xử lý Ví dụ: Tính toán trên vector
ea73ad6304ed438f7e7d4c59ddd227a1:51,ea73ad6304ed438f7e7d4c59ddd227a1,51,52,,,342,"Chương 2 Quản lí tiến trình 2. Luồng 2.1. Giới thiệu Ví dụ: Chat While (1) { ReadLine(Msg); Send(Q,Msg); Receive(Q,Msg); PrintLine(Msg); } While (1) { Receive(P,Msg); PrintLine(Msg); ReadLine(Msg); Send(P,Msg); } Vấn đề nhận Msg l Blocking Recieve l Non-blocking Receive Giải quyết Thực hiện song song Receive & Send Tiến trình P Tiến trình Q"
ea73ad6304ed438f7e7d4c59ddd227a1:52,ea73ad6304ed438f7e7d4c59ddd227a1,52,53,,,353,"Chương 2 Quản lí tiến trình 2. Luồng 2.1. Giới thiệu Chương trình - Tiến trình - Luồng l Chương trình: Dãy lệnh, các biến,.. l Tiến trình: Chương trình đang thực hiện: Stack, t/bị, VXL,.. l Luồng: C/trình đang thực hiện trong ngữ cảnh tiến trình l Nhiều processor →Nhiều luồng, mỗi luồng trên một VXL l Khác nhau về giá trị các thanh ghi, nội dung stack"
ea73ad6304ed438f7e7d4c59ddd227a1:53,ea73ad6304ed438f7e7d4c59ddd227a1,53,54,,,316,"Chương 2 Quản lí tiến trình 2. Luồng 2.1. Giới thiệu Tiến trình đơn luồng và đa luồng l Hệ điều hành truyền thống (MS-DOS, UNIX) l Tiến trình có một luồng điều khiển (heavyweight process) l Hệ điều hành hiện nay (Windows, Linux) l Tiến trình có thể gồm nhiều luồng l Có thể thực hiện nhiều nhiệm vụ tại một thời điểm"
ea73ad6304ed438f7e7d4c59ddd227a1:54,ea73ad6304ed438f7e7d4c59ddd227a1,54,55,,,91,Chương 2 Quản lí tiến trình 2. Luồng 2.1. Giới thiệu Ví dụ: Word processor (Tanenbaum 2001)
ea73ad6304ed438f7e7d4c59ddd227a1:55,ea73ad6304ed438f7e7d4c59ddd227a1,55,56,,,592,"Chương 2 Quản lí tiến trình 2. Luồng 2.1. Giới thiệu Khái niệm luồng l Là đơn vị sử dụng CPU cơ bản, gồm l Định danh luồng (ID Thread) l Bộ đếm chương trình (Program Counter) l Tập các thanh ghi (Registers) l Không gian stack l Chia sẻ cùng các luồng khác trong cùng một tiến trình l Đoạn mã lệnh l Đoạn dữ liệu (đối tượng toàn cục) l Các tài nguyên hệ điều hành khác (file đang mở) l Các luồng có thể thực hiện cùng đoạn mã với ngữ cảnh (Tập thanh ghi, Bộ đếm chương trình, stack) khác nhau l Còn được gọi là tiến trình nhẹ (LWP: Lightweight Process) l Một tiến trình có ít nhất là một luồng"
ea73ad6304ed438f7e7d4c59ddd227a1:56,ea73ad6304ed438f7e7d4c59ddd227a1,56,57,,,830,"Chương 2 Quản lí tiến trình 2. Luồng 2.1. Giới thiệu Phân biệt tiến trình và luồng Tiến trình có đoạn mã/dữ liệu/heap & các đoạn khác Các luồng trong phạm vi một tiến trình chia sẻ mã/dữ liệu/heap, vào/ra nhưng có stack và tập thanh ghi riêng Phải có ít nhất một luồng trong mỗi tiến trình Thao tác khởi tạo, luân chuyển tiến trình tốn kém Bảo vệ tốt do có không gian điạ chỉ riêng Khi tiến trình kết thúc, các tài nguyên được đòi lại và các luồng phải kết thúc theo Luồng không có đoạn dữ liệu hay heap riêng Luồng không đứng riêng mà nằm trong một tiến trình Có thể tồn tại nhiều luồng trong mỗi tiến trình. Luồng đầu là luồng chính và sở hữu không gian stack của tiến trình Thao tác khởi tạo và luân chuyển luồng không tốn kém Không gian điạ chỉ chung, cần phải bảo vệ Luồng kết thúc, stack của nó được thu hồi Luồng Tiến trình"
ea73ad6304ed438f7e7d4c59ddd227a1:57,ea73ad6304ed438f7e7d4c59ddd227a1,57,58,,,825,"Chương 2 Quản lí tiến trình 2. Luồng 2.1. Giới thiệu Lợi ích của lập trình đa luồng l Tăng tính đáp ứng với người dùng l Cho phép chương trình vẫn thực hiện ngay khi một phần đang chờ đợi (block) hoặc đang thực hiện tính toán tăng cường (lengthy operation) l Chia sẻ tài nguyên l Các luồng chia sẻ bộ nhớ và tài nguyên của tiến trình chứa nó l Tốt cho các thuật toán song song (sử dụng chung các CTDL) l Trao đổi giữa các luồng thông qua bộ nhớ chia sẻ l Cho phép một ứng dụng chứa nhiều luồng hoạt động trong cùng không gian địa chỉ l Tính kinh tế l Các thao tác khởi tạo, hủy bỏ và luân chuyển luồng ít tốn kém l Minh họa được tính song song trên bộ đơn VXL do thời gian luân chuyển CPU nhanh (Thực tế chỉ một luồng thực hiện) l Sử dụng kiến trúc nhiều vi xử lý l Các luồng chạy song song thực sự trên các bộ VXL khác nhau."
ea73ad6304ed438f7e7d4c59ddd227a1:58,ea73ad6304ed438f7e7d4c59ddd227a1,58,59,,,381,"Chương 2 Quản lí tiến trình 2. Luồng 2.1. Giới thiệu Lợi ích của lập trình đa luồng -> Ví dụ Tính toán trên vector for (k = 0;k < n;k++) { a[k] = b[k]*c[k]; } void fn(a,b) for(k = a; k < b; k ++){ a[k] = b[k] ∗c[k]; } void main(){ CreateThread(fn(0, n/4)); CreateThread(fn(n/4, n/2)); CreateThread(fn(n/2, 3n/4)); CreateThread(fn(3n/4, n)); } Tính toán trên vector Mô hình đa luồng"
ea73ad6304ed438f7e7d4c59ddd227a1:59,ea73ad6304ed438f7e7d4c59ddd227a1,59,60,,,116,Chương 2 Quản lí tiến trình 2. Luồng 2.1. Giới thiệu Cài đặt luồng Trong không gian người dùng Trong không gian nhân
ea73ad6304ed438f7e7d4c59ddd227a1:60,ea73ad6304ed438f7e7d4c59ddd227a1,60,61,,,646,"Chương 2 Quản lí tiến trình 2. Luồng 2.1. Giới thiệu Luồng người dùng (User -Level Threads) l Quản lý các luồng được thực hiện bởi chương trình ứng dụng l Nhân hệ thống không biết gì về sự tồn tại luồng l Điều phối tiến trình như một đơn vị duy nhất l Gán cho mỗi tiến trình một trạng thái duy nhất l Sẵn sàng, chờ đợi, thực hiện,.. l Chương trình ứng dụng được lập trình theo mô hình đa luồng được hỗtrợ bởi thư viện luồng l Ưu điểm l Nhanh chóng trong tạo và quản lý luồng l Nhược điểm l Khi một luồng rơi vào trạng thái chờ đợi, tất cả các luồng trong cùng tiến trình bị chờ đợi theo ⇒Không tận dụng được ưu điểm của mô hình lập trình đa luồng"
ea73ad6304ed438f7e7d4c59ddd227a1:61,ea73ad6304ed438f7e7d4c59ddd227a1,61,62,,,552,"Chương 2 Quản lí tiến trình 2. Luồng 2.1. Giới thiệu Luồng mức hệ thống (Kernel - Level threads) l Nhân duy trì thông tin về tiến trình và các luồng l Quản lý luồng được thực hiện bởi nhân l Không tồn tại các mã quản lý luồng trong ứng dụng l Điều phối luồng được thực hiện bởi nhân, dựa trên các luồng l Nhược điểm: l Chậm trong tạo và quản lý luồng l Ưu điểm: l Một luồng chờ đợi vào ra, không ảnh hưởng tới luồng khác l Trong môi trường đa VXL, nhân có thể điều phối các luồng cho các VXL khác nhau l Hệ điều hành: Windows NT/2000/XP, Linux, OS/2,.."
ea73ad6304ed438f7e7d4c59ddd227a1:62,ea73ad6304ed438f7e7d4c59ddd227a1,62,63,,,131,Chương 2 Quản lí tiến trình 2. Luồng 2.2.Mô hình đa luồng lGiới thiệu lMô hình đa luồng lCài đặt luồng với Windows lVấn đề đa luồng
ea73ad6304ed438f7e7d4c59ddd227a1:63,ea73ad6304ed438f7e7d4c59ddd227a1,63,64,,,173,Chương 2 Quản lí tiến trình 2. Luồng 2.2. Mô hình đa luồng Giới thiệu l Nhiều hệ thống hỗ trợ cả luồng mức người dùng và luồng mức hệ thống ⇒Nhiều mô hình đa luồng khác nhau
ea73ad6304ed438f7e7d4c59ddd227a1:64,ea73ad6304ed438f7e7d4c59ddd227a1,64,65,,,460,Chương 2 Quản lí tiến trình 2. Luồng 2.2. Mô hình đa luồng Mô hình nhiều-một l Ánh xạ nhiều luồng mức người dùng tới một luồng mức hệ thống l Quản lý luồng được thực hiện trong không gian người dùng l Hiệu quả l Cho phép tạo nhiều luồng tùy ý l Toàn bộ tiến trình sẽ bị khóa nếu một luồng bị khóa l Không thể chạy song song trên các máy nhiều vi xử lý (Chỉ một luồng có thểtruy nhập nhân tại một thời điểm) l Dùng trong hệ điều hành không hỗ trợ luồng hệ thống
ea73ad6304ed438f7e7d4c59ddd227a1:65,ea73ad6304ed438f7e7d4c59ddd227a1,65,66,,,451,Chương 2 Quản lí tiến trình 2. Luồng 2.2. Mô hình đa luồng Mô hình một-một l Ánh xạ mỗi luồng mức người dùng tới một luồng hệ thống l Cho phép thực hiện luồng khác khi một luồng bị chờ đợi l Cho phép chạy song song đa luồng trên máy nhiều vi xử lý l Tạo luồng mức người dùng đòi hỏi tạo một luồng mức hệ thống tương ứng l Ảnh hướng tới hiệu năng của ứng dụng l Chi phi cao ⇒Giới hạn số luồng được hệ thống hỗ trợ l Được sử dụng trong Window NT/2000/XP
ea73ad6304ed438f7e7d4c59ddd227a1:66,ea73ad6304ed438f7e7d4c59ddd227a1,66,67,,,513,"Chương 2 Quản lí tiến trình 2. Luồng 2.2. Mô hình đa luồng Mô hình nhiều nhiều l Nhiều luồng mức người dùng ánh xạ tới một số nhỏ luồng mức hệ thống l Số lượng luồng nhân có thể được xác định theo máy hoặc theo ứng dụng l VD: Được cấp nhiều luồng nhân hơn trên hệ thống nhiều VXL l Có được ưu điểm của 2 mô hình trên l Cho phép tạo nhiều luồng mức ứng dụng theo yêu cầu l Các luồng nhân tương ứng có thể chạy song song trên hệ nhiều VXL l Một luồng bị khóa, nhân có thể cho phép luồng khác thực hiện l Ví dụ: UNIX"
ea73ad6304ed438f7e7d4c59ddd227a1:67,ea73ad6304ed438f7e7d4c59ddd227a1,67,68,,,141,Chương 2 Quản lí tiến trình 2. Luồng 2.3. Cài đặt luồng với Windows lGiới thiệu lMô hình đa luồng lCài đặt luồng với Windows lVấn đề đa luồng
ea73ad6304ed438f7e7d4c59ddd227a1:68,ea73ad6304ed438f7e7d4c59ddd227a1,68,69,,,742,"Chương 2 Quản lí tiến trình 2. Luồng 2.3. Cài đặt luồng với Windows Một số hàm với luồng trong WIN32 API l HANDLE CreateThread(. . . ); l LPSECURITY_ATTRIBUTESlpThreadAttributes, ⇒Trỏ tới cấu trúc an ninh: thẻ trả về có thể được kế thừa? l DWORD dwStackSize, ⇒Kích thước ban đầu của stack cho luồng mới l LPTHREAD_START_ROUTINE lpStartAddress, ⇒Trỏ tới hàm được thực hiện bởi luồng mới l LPVOID lpParameter, ⇒Trỏ tới các biến được gửi tới luồng mới (tham số của hàm) l DWORD dwCreationFlags, ⇒Phương pháp tạo luồng l CREATE_SUSPENDED : Luồng ở trạng thái tạm ngừng l 0: Luồng được thực hiện ngay lập tức l LPDWORD lpThreadId ⇒Biến ghi nhận định danh luồng mới l Kết quả trả về: Thẻ của luồng mới hoặc giá trị NULL nếu không tạo được luồng mới"
ea73ad6304ed438f7e7d4c59ddd227a1:69,ea73ad6304ed438f7e7d4c59ddd227a1,69,70,,,455,"Chương 2 Quản lí tiến trình 2. Luồng 2.3. Cài đặt luồng với Windows Ví dụ #include <windows.h> #include <stdio.h> void Routine(int *n){ printf(""My argument is %d\n"", &n); } int main(){ int i, P[5]; DWORD Id; HANDLE hHandles[5]; for (i=0;i < 5;i++) { P[i] = i; hHandles[i] = CreateThread(NULL,0, (LPTHREAD_START_ROUTINE)Routine,&P[i],0,&Id); printf(""Thread %d was created\n"",Id); } for (i=0;i < 5;i++) WaitForSingleObject(hHandles[i],INFINITE); return 0; }"
ea73ad6304ed438f7e7d4c59ddd227a1:70,ea73ad6304ed438f7e7d4c59ddd227a1,70,71,,,369,"Chương 2 Quản lí tiến trình 2. Luồng 2.3. Cài đặt luồng với Windows Luồng trong Windows XP Thread bao gồm l Thread ID l Registers l user stack dùng trong user mode, kernel stack dùng trong kernel mode. l Vùng lưu trữ riêng được dùng bởi các thư viện khi thực hiện (run- time) và thư viện liên kết động executive thread block Kernel thread block Thread environment block"
ea73ad6304ed438f7e7d4c59ddd227a1:71,ea73ad6304ed438f7e7d4c59ddd227a1,71,72,,,130,Chương 2 Quản lí tiến trình 2. Luồng 2.4.Vấn đề đa luồng lGiới thiệu lMô hình đa luồng lCài đặt luồng với Windows lVấn đề đa luồng
ea73ad6304ed438f7e7d4c59ddd227a1:72,ea73ad6304ed438f7e7d4c59ddd227a1,72,73,,,461,"Chương 2 Quản lí tiến trình 2. Luồng 2.4. Vấn đề đa luồng Ví dụ #include <windows.h> #include <stdio.h> int x = 0, y = 1; void T1(){ while(1){ x = y + 1; printf(""%4d"", x); } } void T2(){ while(1){ y = 2; y = y * 2; } } int main(){ HANDLE h1, h2; DWORD Id; h1=CreateThread(NULL,0,(LPTHREAD_START_ROUTINE)T1,NULL,0,&Id); h2=CreateThread(NULL,0,(LPTHREAD_START_ROUTINE)T2,NULL,0,&Id); WaitForSingleObject(h1,INFINITE); WaitForSingleObject(h2,INFINITE); return 0; }"
ea73ad6304ed438f7e7d4c59ddd227a1:73,ea73ad6304ed438f7e7d4c59ddd227a1,73,74,,,75,Chương 2 Quản lí tiến trình 2. Luồng 2.4. Vấn đề đa luồng Kết quả thực hiện
ea73ad6304ed438f7e7d4c59ddd227a1:74,ea73ad6304ed438f7e7d4c59ddd227a1,74,75,,,229,Chương 2 Quản lí tiến trình 2. Luồng 2.4. Vấn đề đa luồng Giải thích Kết quả thực hiện các luồng song song phụ thuộc trật tự truy nhập biến dùng chung giữa chúng Thread T1 Thread T2 t x = y + 1 y = 2 y = y * 2 x = y + 1 x = y + 1
ea73ad6304ed438f7e7d4c59ddd227a1:75,ea73ad6304ed438f7e7d4c59ddd227a1,75,76,,,133,Chương 2 Quản lí tiến trình ①Tiến trình ②Luồng (Thread) ③Điều phối CPU ④Tài nguyên găng và điều độ tiến trình ⑤Bế tắc và xử lý bế tắc
ea73ad6304ed438f7e7d4c59ddd227a1:76,ea73ad6304ed438f7e7d4c59ddd227a1,76,77,,,164,Chương 2 Quản lí tiến trình 3. Điều phối CPU 3.1. Các khái niệm cơ bản lCác khái niệm cơ bản lTiêu chuẩn điều phối lCác thuật toán điều phối lCPU Điều phối đa xử lý
ea73ad6304ed438f7e7d4c59ddd227a1:77,ea73ad6304ed438f7e7d4c59ddd227a1,77,78,,,753,"Chương 2 Quản lí tiến trình 3. Điều phối CPU 3.1. Các khái niệm cơ bản l Hệ thống có một processor →Chỉ có một tiến trình được thực hiện tại một thời điểm l Tiến trình được thực hiện (chiếm dụng VXL) cho tới khi phải chờ đợi một thao tác vào ra l Hệ đơn chương trình: CPU không được sử dụng ⇒Lãng phí l Hệ đa chương trình: cố gắng sử dụng CPU (đang rảnh rỗi) cho các tiến trình khác (đang chờ đợi) l Cần nhiều tiến trình sẵn sàng trong bộ nhớ tại một thời điểm l Khi một tiến trình phải chờ, hệ điều hành lấy lại processor để phân cho tiến trình khác l Điều phối processor quan trọng với hệ điều hành đa nhiệm l Luân chuyển CPU giữa các tiến trình →khai thác hệ thống hiệu quả hơn l Điều phối processor là nền tảng trong thiết kế hệ điều hành Giới thiệu"
ea73ad6304ed438f7e7d4c59ddd227a1:78,ea73ad6304ed438f7e7d4c59ddd227a1,78,79,,,608,Chương 2 Quản lí tiến trình 3. Điều phối CPU 3.1. Các khái niệm cơ bản l Tiến trình là chuỗi luân phiên giữa chu kỳ tính toán và chờ đợi vào/ra l Bắt đầu bởi chu kỳ tính toán l Tiếp theo chu kỳ đợi vào/ra l Tính toán→đợi vào/ra →tính toán → đợi vào/ra →. . . l Kết thúc: Tính toán (yêu cầu hệ thống kết thúc thực hiện) l Phân biệt các kiểu tiến trình l Dựa trên sự phân bổ thời gian cho các chu kỳ CPU & vào/ra l Tiến trình tính toán (CPU-bound process) có vài chu kỳ CPU dài l Tiến trình vào ra (I/0-bound process) có nhiều chu kỳ CPU ngắn l Để chọn giải thuật điều phối thích hợp Chu kỳ thực hiện CPU - I/O
ea73ad6304ed438f7e7d4c59ddd227a1:79,ea73ad6304ed438f7e7d4c59ddd227a1,79,80,,,725,"Chương 2 Quản lí tiến trình 3. Điều phối CPU 3.1. Các khái niệm cơ bản l Lựa chọn một trong số các tiến trình đang sẵn sàng trong bộ nhớ và cung cấp CPU cho nó l Các tiến trình phải sắp hàng trong hàng đợi l Hàng đợi FIFO, Hàng đợi ưu tiên, DSLK đơn giản . . . l Quyết định điều phối CPU xảy ra khi tiến trình 1) Chuyển từ trạng thái thực hiện sang trạng thái chờ đợi (y/c vào/ra) 2) Chuyển từ trạng thái thực hiện sang trạng thái sẵn sàng (hết thời gian sử dụng CPU →ngắt thời gian) 3) Chuyển từ trạng thái chờ đợi sang trạng thái sẵn sàng (hoàn thành vào/ra) 4) Tiến trình kết thúc l Ghi chú l Trường hợp 1&4 ⇒Điều phối không trưng dụng (non-preemptive) l Trường hợp khác ⇒Điều phối trưng dụng (preemptive) Bộ điều phối CPU"
ea73ad6304ed438f7e7d4c59ddd227a1:80,ea73ad6304ed438f7e7d4c59ddd227a1,80,81,,,748,"Chương 2 Quản lí tiến trình 3. Điều phối CPU 3.1. Các khái niệm cơ bản l Điều phối không trưng dụng l Tiến trình chiếm CPU cho tới khi giải phóng bởi l Kết thúc nhiệm vụ l Chuyển sang trạng thái chờ đợi l Không đòi hỏi phần cứng đặc biệt (đồng hồ ) l Ví dụ: DOS, Win 3.1, Macintosh l Điều phối trưng dụng l Tiến trình chỉ được phép thực hiện trong khoảng thời gian l Hết thời gian, ngắt thời gian xuất hiện, bộ điều vận (dispatcher) quyết định phục hồi lại tiến trình hay chọn tiến trình khác l Bảo vệ CPU khỏi các tiến trình ""đói-CPU"" l Vấn đề dữ liệu dùng chung l Tiến trình 1 đang cập nhật DL thì bị mất CPU l Tiến trình 2, được giao CPU và đọc DL đang cập nhật l Ví dụ: Hệ điều hành đa nhiệm WinNT, UNIX Điều phối trưng dụng và không trưng dụng"
ea73ad6304ed438f7e7d4c59ddd227a1:81,ea73ad6304ed438f7e7d4c59ddd227a1,81,82,,,164,Chương 2 Quản lí tiến trình 3. Điều phối CPU 3.2. Tiêu chuẩn điều phối lCác khái niệm cơ bản lTiêu chuẩn điều phối lCác thuật toán điều phối lCPU Điều phối đa xử lý
ea73ad6304ed438f7e7d4c59ddd227a1:82,ea73ad6304ed438f7e7d4c59ddd227a1,82,83,,,719,Chương 2 Quản lí tiến trình 3. Điều phối CPU 3.2. Tiêu chuẩn điều phối l Sử dụng CPU (Lớn nhất) l Mục đích của điều độ là làm CPU hoạt động nhiều nhất có thể l Độ sử dụng CPU thay đổi từ 40% (hệ thống tải nhẹ) đến 90% (hệ thống tải nặng). l Thông lượng (throughput) (Lớn nhất) l Số lượng tiến trình hoàn thành trong một đơn vị thời gian l Các tiến trình dài: 1 tiến trình/giờ l Các tiến trình ngắn: 10 tiến trình/giây l Thời gian hoàn thành (Nhỏ nhất) l Khoảng thời gian từ thời điểm gửi đến hệ thống tới khi quá trình hoàn thành l Thời gian chờ đợi để đưa tiến trình vào bộ nhớ l Thời gian chờ đợi trong hàng đợi sẵn sàng l Thời gian chờ đợi trong hàng đợi thiết bị l Thời gian thực hiện thực tế Tiêu chuẩn điều phối I
ea73ad6304ed438f7e7d4c59ddd227a1:83,ea73ad6304ed438f7e7d4c59ddd227a1,83,84,,,609,Chương 2 Quản lí tiến trình 3. Điều phối CPU 3.2. Tiêu chuẩn điều phối l Thời gian chờ đợi (Nhỏ nhất) l Tổng thời gian chờ trong hàng đợi sẳn sàng (Giải thuật điều độ CPU không ảnh hưởng tới các tiến trình đang thực hiện hay đang đợi thiết bị vào ra) l Thời gian đáp ứng (Nhỏ nhất) l Từ lúc gửi câu hỏi cho tới khi câu trả lời đầu tiên được tạo ra l Tiến trình có thể tạo kết quả ra từng phần l Tiến trình vẫn tiếp tục tính toán kết quả mới trong khi kết quả cũ được gửi tới người dùng Tiêu chuẩn điều phối II l Giả thiết: Các tiến trình chỉ có một chu kỳ tính toán (ms) l Đo đạc: Thời gian chờ đợi trung bình
ea73ad6304ed438f7e7d4c59ddd227a1:84,ea73ad6304ed438f7e7d4c59ddd227a1,84,85,,,168,Chương 2 Quản lí tiến trình 3. Điều phối CPU 3.3. Các thuật toán điều phối lCác khái niệm cơ bản lTiêu chuẩn điều phối lCác thuật toán điều phối lCPU Điều phối đa xử lý
ea73ad6304ed438f7e7d4c59ddd227a1:85,ea73ad6304ed438f7e7d4c59ddd227a1,85,86,,,386,"Chương 2 Quản lí tiến trình 3. Điều phối CPU 3.3. Các thuật toán điều phối l Nguyên tắc: Tiến trình được quyền sử dụng CPU theo trình tự xuất hiện Tiến trình sở hữu CPU tới khi kết thúc hoặc chờ đợi vào ra l Ví dụ l Đặc điểm l Đơn giản, dễ thực hiện l Tiến trình ngắn phải chờ đợi như tiến trình dài l Nếu P1 thực hiện sau cùng ? Đến trước phục vụ trước (FCFS: First Come, First Served)"
ea73ad6304ed438f7e7d4c59ddd227a1:86,ea73ad6304ed438f7e7d4c59ddd227a1,86,87,,,544,Chương 2 Quản lí tiến trình 3. Điều phối CPU 3.3. Các thuật toán điều phối l Nguyên tắc: Mỗi tiến trình lưu trữ thời gian của chu kỳ sử dụng CPU tiếp theo l Tiến trình có thời gian sử dụng CPU ngắn nhất sẽ sở hữu CPU l Hai phương pháp l Không trưng dụng CPU l Có trưng dụng CPU (SRTF: Shortest Remaining Time First) l Ví dụ l Đặc điểm l SJF (SRTF) là tối ưu: Thời gian chờ đợi trung bình nhỏ nhất l Không thể biết chính xác thời gian của chu kỳ sử dụng CPU l Dự báo dựa trên những giá trị trước đó Công việc ngắn trước (SJF: Shortest Job First)
ea73ad6304ed438f7e7d4c59ddd227a1:87,ea73ad6304ed438f7e7d4c59ddd227a1,87,88,,,517,"Chương 2 Quản lí tiến trình 3. Điều phối CPU 3.3. Các thuật toán điều phối l Mỗi tiến trình gắn với một sô hiệu ưu tiên (số nguyên) l CPU sẽ được phân phối cho tiến trình có độ ưu tiên cao nhất l SJF: độ ưu tiên gắn liền với thời gian thực hiện l Hai phương pháp l Không trưng dụng CPU l Có trưng dụng CPU l Ví dụ l Vấn đề ""Nạn đói"": Tiến trình có độ ưu tiên thấp phải chờ đợi lâu (thậm chí không được thực hiện) l Giải pháp tăng dần độ ưu tiên tt theo t/gian trong hệ thống Điều phối có ưu tiên (Priority Scheduling)"
ea73ad6304ed438f7e7d4c59ddd227a1:88,ea73ad6304ed438f7e7d4c59ddd227a1,88,89,,,495,"Chương 2 Quản lí tiến trình 3. Điều phối CPU 3.3. Các thuật toán điều phối l Nguyên tắc l Mỗi tiến trình được cấp một lượng tử thời gian τ để thực hiện l Khi hết thời gian, tiến trình bị trưng dụng processor và được đưa vào cuối hàng đợi sẵn sàng l Nếu có n tiến trình, thời gian chờ đợi nhiều nhất (n − 1)τ l Ví dụ Lượng tử thời gian τ = 4 l Vấn đề: Lựa chọn lượng tử thời gian τ l τ lớn: FCFS l τ nhỏ: Hãy phải luân chuyển CPU l Thông thường τ = 10-100ms Vòng tròn (RR: Round Robin Scheduling)"
ea73ad6304ed438f7e7d4c59ddd227a1:89,ea73ad6304ed438f7e7d4c59ddd227a1,89,90,,,113,Chương 2 Quản lí tiến trình 3. Điều phối CPU 3.3. Các thuật toán điều phối Vòng tròn (RR: Round Robin Scheduling)
ea73ad6304ed438f7e7d4c59ddd227a1:90,ea73ad6304ed438f7e7d4c59ddd227a1,90,91,,,804,"Chương 2 Quản lí tiến trình 3. Điều phối CPU 3.3. Các thuật toán điều phối l Hàng đợi sẵn sàng được phân chia thành nhiều hàng đợi nhỏ l Tiến trình được ấn định cố định cho một hàng đợi l Dựa vào tính chất như độ ưu tiên, kiểu tiến trình.. l Mỗi hàng đợi sử dụng thuật toán điều độ riêng l Cần điều phối giữa các hàng đợi l Điều phối có trưng dụng, độ ưu tiên cố định l Tiến trình hàng đợi độ ưu tiên thấp chỉ được thực hiện khi các hàng đợi có độ ưu tiên cao rỗng l Tiến trình độ ưu tiên mức cao, trưng dụng tiến trình độ ưu tiên mức thấp l Có thể gặp tình trạng starvation l Phân chia thời gian giữa các hàng đợi l Hàng đợi cho foreground process, chiếm 80% thời gian CPU cho RR l Hàng đợi cho background process, chiếm 20% thời gian CPU cho FCFS Điều phối hàng đợi đa mức (Multilevel Queue Scheduling)"
ea73ad6304ed438f7e7d4c59ddd227a1:91,ea73ad6304ed438f7e7d4c59ddd227a1,91,92,,,108,Chương 2 Quản lí tiến trình 3. Điều phối CPU 3.3. Các thuật toán điều phối Điều phối hàng đợi đa mức (Ví dụ)
ea73ad6304ed438f7e7d4c59ddd227a1:92,ea73ad6304ed438f7e7d4c59ddd227a1,92,93,,,731,"Chương 2 Quản lí tiến trình 3. Điều phối CPU 3.3. Các thuật toán điều phối l Cho phép các tiến trình được dịch chuyển giữa các hàng đợi l Phân chia tiến trình theo đặc điểm sử dụng VXL l Nếu dùng quá nhiều thời gian của VXL →Chuyển xuống hàng đợi có độ ưu tiên thấp l Tiến trình vào ra nhiều →hàng đợi có độ ưu tiên cao l Tiến trình đợi quá lâu tại hàng đợi có độ ưu tiên thấp →Chuyển lên hàng đợi độ ưu tiên cao l Ngăn ngừa tình trạng ""đói CPU"" l Được định nghĩa bởi các tham số l Số hàng đợi l Thuật toán điều độ cho mỗi hàng đợi l Điều kiện để tiến trình được chuyển lên/xuống hàng đợi có độ ưu tiên cao/thấp hơn l Phương pháp xác định một hàng đợi khi tiến trình cần phục vụ Hàng đợi hồi tiếp đa mức (Multilevel Feedback Queue)"
ea73ad6304ed438f7e7d4c59ddd227a1:93,ea73ad6304ed438f7e7d4c59ddd227a1,93,94,,,107,Chương 2 Quản lí tiến trình 3. Điều phối CPU 3.3. Các thuật toán điều phối l Ví dụ Hàng đợi hồi tiếp đa mức
ea73ad6304ed438f7e7d4c59ddd227a1:94,ea73ad6304ed438f7e7d4c59ddd227a1,94,95,,,162,Chương 2 Quản lí tiến trình 3. Điều phối CPU 3.4. Điều phối đa xử lý lCác khái niệm cơ bản lTiêu chuẩn điều phối lCác thuật toán điều phối lCPU Điều phối đa xử lý
ea73ad6304ed438f7e7d4c59ddd227a1:95,ea73ad6304ed438f7e7d4c59ddd227a1,95,96,,,591,Chương 2 Quản lí tiến trình 3. Điều phối CPU 3.4. Điều phối đa xử lý l Điều phối phức tạp hơn so với trường hợp có một VXL l Vấn đề chia sẻ tải l Mỗi VXL có một hàng đợi sẵn sàng riêng l Tồn tại VXL rảnh rỗi với hàng đợi rỗng trong khi VXL khác phải tính toán nhiều l Hàng đợi sẵn sàng dùng chung l Vấn đề dùng chung cấu trúc dữ liêu (hàng đợi) : →Một tiến trình được lựa chọn bởi 2 processors hoặc →Một tiến trình bị thất lạc trên hàng đợi l Đa xử lý không đối xứng l Chỉ có một processor truy nhập hàng đợi hủy bỏ vấn đề dùng chung cơ sở dữ liệu l Có thể tắc nghẽn tại một processor Vấn đề
ea73ad6304ed438f7e7d4c59ddd227a1:96,ea73ad6304ed438f7e7d4c59ddd227a1,96,97,,,105,Chương 2 Quản lí tiến trình 3. Điều phối CPU lViết chương trình mô phỏng hàng đợi hồi tiếp đa mức Bài tập
ea73ad6304ed438f7e7d4c59ddd227a1:97,ea73ad6304ed438f7e7d4c59ddd227a1,97,98,,,133,Chương 2 Quản lí tiến trình ①Tiến trình ②Luồng (Thread) ③Điều phối CPU ④Tài nguyên găng và điều độ tiến trình ⑤Bế tắc và xử lý bế tắc
ea73ad6304ed438f7e7d4c59ddd227a1:98,ea73ad6304ed438f7e7d4c59ddd227a1,98,99,,,224,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình lKhái niệm tài nguyên găng lPhương pháp khóa trong lPhương pháp kiểm tra và xác lập lKỹ thuật đèn báo lVí dụ về đồng bộ tiến trình lCông cụ điều độ cấp cao
ea73ad6304ed438f7e7d4c59ddd227a1:99,ea73ad6304ed438f7e7d4c59ddd227a1,99,100,,,98,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.1 Khái niệm tài nguyên găng
ea73ad6304ed438f7e7d4c59ddd227a1:100,ea73ad6304ed438f7e7d4c59ddd227a1,100,101,,,98,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.1 Khái niệm tài nguyên găng
ea73ad6304ed438f7e7d4c59ddd227a1:101,ea73ad6304ed438f7e7d4c59ddd227a1,101,102,,,98,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.1 Khái niệm tài nguyên găng
ea73ad6304ed438f7e7d4c59ddd227a1:102,ea73ad6304ed438f7e7d4c59ddd227a1,102,103,,,503,"Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.1. Khái niệm tài nguyên găng Ví dụ #include <windows.h> #include <stdio.h> int x = 0, y = 1; void T1(){ while(1){ x = y + 1; printf(""%4d"", x); } } void T2(){ while(1){ y = 2; y = y * 2; } } int main(){ HANDLE h1, h2; DWORD Id; h1=CreateThread(NULL,0,(LPTHREAD_START_ROUTINE)T1,NULL,0,&Id); h2=CreateThread(NULL,0,(LPTHREAD_START_ROUTINE)T2,NULL,0,&Id); WaitForSingleObject(h1,INFINITE); WaitForSingleObject(h2,INFINITE); return 0; }"
ea73ad6304ed438f7e7d4c59ddd227a1:103,ea73ad6304ed438f7e7d4c59ddd227a1,103,104,,,116,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.1 Khái niệm tài nguyên găng Kết quả thực hiện
ea73ad6304ed438f7e7d4c59ddd227a1:104,ea73ad6304ed438f7e7d4c59ddd227a1,104,105,,,270,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.1 Khái niệm tài nguyên găng Giải thích Kết quả thực hiện các luồng song song phụ thuộc trật tự truy nhập biến dùng chung giữa chúng Thread T1 Thread T2 t x = y + 1 y = 2 y = y * 2 x = y + 1 x = y + 1
ea73ad6304ed438f7e7d4c59ddd227a1:105,ea73ad6304ed438f7e7d4c59ddd227a1,105,106,,,406,• Hệ thống gồm 2 tiến trình • Producer sản xuất ra các sản phẩm • Consumer tiêu thụ các sản phẩm được sản xuất ra • Công việc của Producer phải đồng bộ với Consumer. • Không đưa ra sản phẩm khi hết chỗ trống • Không lấy được sản phẩm khi chưa có Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.1 Khái niệm tài nguyên găng Bài toán người sản xuất (producer)-người tiêu thụ(consumer) I
ea73ad6304ed438f7e7d4c59ddd227a1:106,ea73ad6304ed438f7e7d4c59ddd227a1,106,107,,,618,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.1 Khái niệm tài nguyên găng Bài toán người sản xuất (producer)-người tiêu thụ(consumer) II Producer Consumer while(1) { /*produce an item in nextProduced*/ while (Counter == BUFFER_SIZE) ; /*do nothing*/ Buffer[IN] = nextProduced; IN = (IN + 1) % BUFFER_SIZE; Counter++; } while(1){ while(Counter == 0) ; /*do nothing*/ nextConsumed = Buffer[OUT]; OUT =(OUT + 1) % BUFFER_SIZE; Counter--; /*consume the item in nextConsumed*/ } Nhận xét l Producer sản xuất một sản phẩm l Consumer tiêu thụ một sản phẩm ⇒Số sản phẩm còn trong Buffer không thay đổi
ea73ad6304ed438f7e7d4c59ddd227a1:107,ea73ad6304ed438f7e7d4c59ddd227a1,107,108,,,466,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.1 Khái niệm tài nguyên găng Định nghĩa Tài nguyên Tất cả những gì cần thiết cho thực hiện tiến trình Tài nguyên găng l Tài nguyên hạn chế về khả năng sử dụng chung l Cần đồng thời cho nhiều tiến trình l Tài nguyên găng có thể là thiết bị vật lý hay dữ liệu dùng chung Vấn đề Dùng chung tài nguyên găng có thể dẫn đến không đảm bảo tính toàn vẹn dữ liệu ⇒Đòi hỏi cơ chế đồng bộ hóa các tiến trình
ea73ad6304ed438f7e7d4c59ddd227a1:108,ea73ad6304ed438f7e7d4c59ddd227a1,108,109,,,731,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.1 Khái niệm tài nguyên găng Điều kiện cạnh tranh (Race condition) l Tình trạng trong đó kết quả của việc nhiều tiến trình cùng truy nhập tới dữ liệu phân chia phụ thuộc vào trật tự của các truy nhập l Làm cho chương trình không xác định l Ngăn ngừa điều kiện cạnh tranh được thực hiện bởi đồng bộ hóa (synchronize) các tiến trình thực hiện đồng thời l Chỉ một tiến trình truy nhập tới dữ liệu phân chia tại một thời điểm l Biến counter trong vấn đề Producer-Consumer l Đoạn lệnh truy nhập tới dữ liệu phân chia trong các tiến trình phải thực hiện theo thứ tự xác định l VD: Lệnh x←y+1 trong Thread T1 chỉ thực hiện khi cả 2 lệnh của Thread T2 đã thực hiện xong
ea73ad6304ed438f7e7d4c59ddd227a1:109,ea73ad6304ed438f7e7d4c59ddd227a1,109,110,,,405,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.1 Khái niệm tài nguyên găng Đoạn găng (Critical section) l Đoạn găng (chỗ hẹp) là đoạn chương trình sử dụng tài nguyên găng l Đoạn chương trình thực hiện truy nhập và thao tác trên dữ liệu dùng chung l Khi có nhiều tiến trình sử dụng tài nguyên găng thì phải điều độ l Mục đích: đảm bảo không có quá một tiến trình nằm trong đoạn găng
ea73ad6304ed438f7e7d4c59ddd227a1:110,ea73ad6304ed438f7e7d4c59ddd227a1,110,111,,,747,"Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.1 Khái niệm tài nguyên găng Yêu cầu của chương trình điều độ l Loại trừ lẫn nhau (Mutual Exclusion) Mỗi thời điểm, tài nguyên găng không phải phục vụ một số lượng tiến trình vượt quá khả năng của nó l Một tiến trình đang thực hiện trong đoạn găng (sử dụng tài nguyên găng) ⇒Không một tiến trình nào khác được quyền vào đoạn găng l Tiến triển (Progress) Tài nguyên găng còn khả năng phục vụ và tồn tại tiến trình muốn vào đoạn găng, thì tiến trình đó phải được sử dụng tài nguyên găng l Chờ đợi hữu hạn (Bounded Waiting) Nếu tài nguyên găng hết khả năng phục vụ và vẫn tồn tại tiến trình muốn vào đoạn găng, thì tiến trình đó phải được xếp hàng chờ đợi và sự chờ đợi là hữu hạn"
ea73ad6304ed438f7e7d4c59ddd227a1:111,ea73ad6304ed438f7e7d4c59ddd227a1,111,112,,,422,"Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.1 Khái niệm tài nguyên găng Quy ước l Có 2 tiến trình P1&P2 thực hiện đồng thời l Các tiến trình dùng chung một tài nguyên găng l Mỗi tiến trình đặt đoạn găng ở đầu, tiếp theo là phần còn lại l Tiến trình phải xin phép trước khi vào đoạn găng {phần vào} l Tiến trình khi thoát khỏi đoạn găng thực hiện {phần ra} l Cấu trúc tổng quát của một tiến trình"
ea73ad6304ed438f7e7d4c59ddd227a1:112,ea73ad6304ed438f7e7d4c59ddd227a1,112,113,,,257,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.1 Khái niệm tài nguyên găng Phân loại các phương pháp l Các công cụ cấp thấp l Phương pháp khóa trong l Phương pháp kiểm tra và xác lập l Kỹ thuật đèn báo l Các công cụ cấp cao l Monitor
ea73ad6304ed438f7e7d4c59ddd227a1:113,ea73ad6304ed438f7e7d4c59ddd227a1,113,114,,,252,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.2. Phương pháp khóa trong lKhái niệm tài nguyên găng lPhương pháp khóa trong lPhương pháp kiểm tra và xác lập lKỹ thuật đèn báo lVí dụ về đồng bộ tiến trình lCông cụ điều độ cấp cao
ea73ad6304ed438f7e7d4c59ddd227a1:114,ea73ad6304ed438f7e7d4c59ddd227a1,114,115,,,406,"Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.2. Phương pháp khóa trong l Mỗi t/trình dùng một byte trong vùng nhớ chung làm khóa l Tiến trình vào đoạn găng, đóng khoá (byte khóa: true) l Tiến trình thoát khỏi đoạn găng, mở khóa (byte khóa: false) l Tiến trình muốn vào đoạn găng: kiểm tra khóa của tiến trình còn lại l Đang khóa ⇒Đợi l Đang mở ⇒Được quyền vào đoạn găng Nguyên tắc"
ea73ad6304ed438f7e7d4c59ddd227a1:115,ea73ad6304ed438f7e7d4c59ddd227a1,115,116,,,257,"Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.2. Phương pháp khóa trong l Share var C1,C2 Boolean // Các biến dùng chung làm khóa l Khởi tạo C1 = C2 = false //Tài nguyên găng đang tự do Thuật toán điều độ Tiến trình P1 Tiến trình P2"
ea73ad6304ed438f7e7d4c59ddd227a1:116,ea73ad6304ed438f7e7d4c59ddd227a1,116,117,,,257,"Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.2. Phương pháp khóa trong l Share var C1,C2 Boolean // Các biến dùng chung làm khóa l Khởi tạo C1 = C2 = false //Tài nguyên găng đang tự do Thuật toán điều độ Tiến trình P1 Tiến trình P2"
ea73ad6304ed438f7e7d4c59ddd227a1:117,ea73ad6304ed438f7e7d4c59ddd227a1,117,118,,,351,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.2. Phương pháp khóa trong lĐiều độ chưa hợp lý lHai t/trình yêu cầu tài nguyên tại một thời điểm lVấn đề loại trừ lẫn nhau (trường hợp 1) lVấn đề tiến triển (trường hợp 2) lNguyên nhân: Do tách rời giữa lKiểm tra quyền vào đoạn găng lXác lập quyền sử dụng tài nguyên găng Nhận xét
ea73ad6304ed438f7e7d4c59ddd227a1:118,ea73ad6304ed438f7e7d4c59ddd227a1,118,119,,,202,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.2. Phương pháp khóa trong l Sử dụng biến turn để chỉ ra tiến trình được quyền ưu tiên Thuật toán Dekker Tiến trình P1 Tiến trình P2
ea73ad6304ed438f7e7d4c59ddd227a1:119,ea73ad6304ed438f7e7d4c59ddd227a1,119,120,,,674,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.2. Phương pháp khóa trong lĐiều độ hợp lý cho mọi trường hợp lKhông đòi hỏi sự hỗ trợ đặc biệt của phần cứng nên có thể thực hiện bằng ngôn ngữ bất kỳ lQuá phức tạp khi số tiến trình và số tài nguyên tăng lên lPhải chờ đợi tích cực (busy waiting) trước khi vào đoạn găng l Khi chờ đợi vẫn phải thực hiện kiểm tra quyền vào đoạn găng => Lãng phí thời gian của processor Ghi chú: Thuật toán có thể thực hiện sai trong một số trường hợp l CPU cho phép thực hiện các lệnh không đúng trật tự l Chương trình dịch thực hiện tối ưu hóa khi sinh mã l Các mã bất biến bên trong vòng lặp được đưa ra ngoài Nhận xét
ea73ad6304ed438f7e7d4c59ddd227a1:120,ea73ad6304ed438f7e7d4c59ddd227a1,120,121,,,275,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.3 Phương pháp kiểm tra và xác lập (Test anh Set) lKhái niệm tài nguyên găng lPhương pháp khóa trong lPhương pháp kiểm tra và xác lập lKỹ thuật đèn báo lVí dụ về đồng bộ tiến trình lCông cụ điều độ cấp cao
ea73ad6304ed438f7e7d4c59ddd227a1:121,ea73ad6304ed438f7e7d4c59ddd227a1,121,122,,,622,"Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.3 Phương pháp kiểm tra và xác lập (Test anh Set) l Sử dụng sự hỗ trợ từ phần cứng l Phần cứng cung cấp các câu lệnh xử lý không tách rời l Kiểm tra và thay đổi nội dung của một word boolean TestAndSet(VAR boolean target) { boolean rv = target; target = true; return rv; } l Hoán đổi nội dung của 2 word khác nhau void Swap(VAR boolean , VAR boolean b) { boolean temp = a; a = b; b = temp; } l Xử lý không tách rời (atomically) l Khối lệnh không thể bị ngắt trong khi đang thực hiện l Được gọi đồng thời, sẽ được thực hiện theo thứ tự bất kỳ Nguyên tắc"
ea73ad6304ed438f7e7d4c59ddd227a1:122,ea73ad6304ed438f7e7d4c59ddd227a1,122,123,,,326,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.3 Phương pháp kiểm tra và xác lập (Test anh Set) l Biến phân chia Boolean: Lock: trạng thái của tài nguyên: l Bị khóa (Lock=true) l Tự do (Lock=false) l Khởi tạo: Lock = false ⇒Tài nguyên tự do l Thuật toán cho tiến trình Pi Thuật toán với lệnh TestAndSet
ea73ad6304ed438f7e7d4c59ddd227a1:123,ea73ad6304ed438f7e7d4c59ddd227a1,123,124,,,322,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.3 Phương pháp kiểm tra và xác lập (Test anh Set) l Biến phân chia Lock cho biết trạng thái tài nguyên l Biến địa phương cho mỗi tiến trình: Key: Boolean l Khởi tạo: Lock = false ⇒Tài nguyên tự do l Thuật toán cho tiến trình Pi Thuật toán với lệnh Swap
ea73ad6304ed438f7e7d4c59ddd227a1:124,ea73ad6304ed438f7e7d4c59ddd227a1,124,125,,,525,"Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.3.Phương pháp kiểm tra và xác lập (Test anh Set) lĐơn giản, không phức tạp khi số tiến trình và số đoạn găng tăng lên lCác tiến trình phải chờ đợi tích cực trước khi vào đoạn găng l Luôn kiểm tra xem tài nguyên găng đã được giải phóng chưa ⇒Sử dụng Processor không hiệu quả lKhông đảm bảo yêu cầu chờ đợi hữu hạn l Tiến trình được vào đoạn găng tiếp theo, sẽ phụ thuộc thời điểm giải phóng tài nguyên của tiến trình đang chiếm giữ ⇒Cần khắc phục Nhận xét"
ea73ad6304ed438f7e7d4c59ddd227a1:125,ea73ad6304ed438f7e7d4c59ddd227a1,125,126,,,119,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.3.Phương pháp kiểm tra và xác lập (Test anh Set)
ea73ad6304ed438f7e7d4c59ddd227a1:126,ea73ad6304ed438f7e7d4c59ddd227a1,126,127,,,245,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.4 Kỹ thuật đèn báo lKhái niệm tài nguyên găng lPhương pháp khóa trong lPhương pháp kiểm tra và xác lập lKỹ thuật đèn báo lVí dụ về đồng bộ tiến trình lCông cụ điều độ cấp cao
ea73ad6304ed438f7e7d4c59ddd227a1:127,ea73ad6304ed438f7e7d4c59ddd227a1,127,128,,,110,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.4. Kỹ thuật đèn báo Đèn báo (Semaphore)
ea73ad6304ed438f7e7d4c59ddd227a1:128,ea73ad6304ed438f7e7d4c59ddd227a1,128,129,,,108,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.4. Kỹ thuật đèn báo Sử dụng đèn báo I
ea73ad6304ed438f7e7d4c59ddd227a1:129,ea73ad6304ed438f7e7d4c59ddd227a1,129,130,,,109,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.4. Kỹ thuật đèn báo Sử dụng đèn báo II
ea73ad6304ed438f7e7d4c59ddd227a1:130,ea73ad6304ed438f7e7d4c59ddd227a1,130,131,,,114,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.4. Kỹ thuật đèn báo Hủy bỏ chờ đợi tích cực
ea73ad6304ed438f7e7d4c59ddd227a1:131,ea73ad6304ed438f7e7d4c59ddd227a1,131,132,,,106,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.4. Kỹ thuật đèn báo Cài đặt đèn báo
ea73ad6304ed438f7e7d4c59ddd227a1:132,ea73ad6304ed438f7e7d4c59ddd227a1,132,133,,,106,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.4. Kỹ thuật đèn báo Sử dụng đèn báo
ea73ad6304ed438f7e7d4c59ddd227a1:133,ea73ad6304ed438f7e7d4c59ddd227a1,133,134,,,174,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.4. Kỹ thuật đèn báo Ví dụ điều độ P1 P2 P3 running running running Semaphore S S.Value = 1 S.Ptr NULL t
ea73ad6304ed438f7e7d4c59ddd227a1:134,ea73ad6304ed438f7e7d4c59ddd227a1,134,135,,,182,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.4. Kỹ thuật đèn báo Ví dụ điều độ P1 P2 P3 running running running Semaphore S S.Value = 0 S.Ptr NULL t P1→P(S)
ea73ad6304ed438f7e7d4c59ddd227a1:135,ea73ad6304ed438f7e7d4c59ddd227a1,135,136,,,189,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.4. Kỹ thuật đèn báo Ví dụ điều độ P1 P2 P3 running block running Semaphore S S.Value = -1 S.Ptr t P1→P(S) P2→P(S) PCB2
ea73ad6304ed438f7e7d4c59ddd227a1:136,ea73ad6304ed438f7e7d4c59ddd227a1,136,137,,,200,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.4. Kỹ thuật đèn báo Ví dụ điều độ P1 P2 P3 running block block Semaphore S S.Value = -2 S.Ptr t P1→P(S) P2→P(S) PCB2 P3→P(S) PCB3
ea73ad6304ed438f7e7d4c59ddd227a1:137,ea73ad6304ed438f7e7d4c59ddd227a1,137,138,,,205,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.4. Kỹ thuật đèn báo Ví dụ điều độ P1 P2 P3 running running block Semaphore S S.Value = -1 S.Ptr t P1→P(S) P2→P(S) PCB3 P3→P(S) P1→V(S)
ea73ad6304ed438f7e7d4c59ddd227a1:138,ea73ad6304ed438f7e7d4c59ddd227a1,138,139,,,214,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.4. Kỹ thuật đèn báo Ví dụ điều độ P1 P2 P3 running running running Semaphore S S.Value = 0 S.Ptr t P1→P(S) P2→P(S) P3→P(S) P1→V(S) P2→V(S) NULL
ea73ad6304ed438f7e7d4c59ddd227a1:139,ea73ad6304ed438f7e7d4c59ddd227a1,139,140,,,222,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.4. Kỹ thuật đèn báo Ví dụ điều độ P1 P2 P3 running running running Semaphore S S.Value = 1 S.Ptr t P1→P(S) P2→P(S) P3→P(S) P1→V(S) P2→V(S) P3→V(S) NULL
ea73ad6304ed438f7e7d4c59ddd227a1:140,ea73ad6304ed438f7e7d4c59ddd227a1,140,141,,,222,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.4. Kỹ thuật đèn báo Ví dụ điều độ P1 P2 P3 running running running Semaphore S S.Value = 1 S.Ptr t P1→P(S) P2→P(S) P3→P(S) P1→V(S) P2→V(S) P3→V(S) NULL
ea73ad6304ed438f7e7d4c59ddd227a1:141,ea73ad6304ed438f7e7d4c59ddd227a1,141,142,,,231,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.4. Kỹ thuật đèn báo l Dễ dàng áp dụng cho các hệ thống phức tạp l Không tồn tại hiện tượng chờ đợi tích cực l Hiệu quả sử dụng phụ thuộc vào người dùng Nhận xét
ea73ad6304ed438f7e7d4c59ddd227a1:142,ea73ad6304ed438f7e7d4c59ddd227a1,142,143,,,443,"Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.4. Kỹ thuật đèn báo lCác phép xử lý P(S) và V(S) là không phân chia được ⇒bản thân P(S) và V(S) cũng là 2 tài nguyên găng ⇒Cũng cần điều độ. lHệ thống một VXL: Cấm ngắt khi thực hiện wait(), signal() lHệ thống nhiều vi xử lý lKhông thể cấm ngắt trên VXL khác lCó thể dùng phương pháp khoa trong ⇒Hiện tượng chờ đợi tích cực, nhưng thời gian chờ đợi ngắn (10 lệnh) Nhận xét"
ea73ad6304ed438f7e7d4c59ddd227a1:143,ea73ad6304ed438f7e7d4c59ddd227a1,143,144,,,784,"Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.4. Kỹ thuật đèn báo l CreateSemaphore(. . .) : Tạo một Semaphore l LPSECURITY_ATTRIBUTES lpSemaphoreAttributes ⇒Trỏ tới cấu trúc an ninh, thẻ trả về được kế thừa? l LONG InitialCount, ⇒Giá trị khởi tạo cho đối tượng Semaphore l LONG MaximumCount, ⇒Giá trị lớn nhất của đối tượng Semaphore l LPCTSTR lpName ⇒Tên của đối tượng Semaphore Ví dụ CreateSemaphore(NULL,0,1,NULL); l Trả về thẻ (HANDLE) của đối tượng Semaphore hoặc NULL l WaitForSingleObject(HANDLE h, DWORD time) l ReleaseSemaphore (. . .) l HANDLE hSemaphore, ⇐Thẻ của đối tượng Semaphore l LONG lReleaseCount, ⇐Giá trị được tăng lên, l LPLONG lpPreviousCount ⇐Giá trị trước đó l Ví dụ: ReleaseSemaphore(S, 1, NULL); Đối tượng Semaphore trong WIN32 API"
ea73ad6304ed438f7e7d4c59ddd227a1:144,ea73ad6304ed438f7e7d4c59ddd227a1,144,145,,,98,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.4. Kỹ thuật đèn báo Ví dụ 1
ea73ad6304ed438f7e7d4c59ddd227a1:145,ea73ad6304ed438f7e7d4c59ddd227a1,145,146,,,98,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.4. Kỹ thuật đèn báo Ví dụ 1
ea73ad6304ed438f7e7d4c59ddd227a1:146,ea73ad6304ed438f7e7d4c59ddd227a1,146,147,,,256,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.5 Ví dụ về đồng bộ tiến trình lKhái niệm tài nguyên găng lPhương pháp khóa trong lPhương pháp kiểm tra và xác lập lKỹ thuật đèn báo lVí dụ về đồng bộ tiến trình lCông cụ điều độ cấp cao
ea73ad6304ed438f7e7d4c59ddd227a1:147,ea73ad6304ed438f7e7d4c59ddd227a1,147,148,,,332,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.5 Ví dụ về đồng bộ tiến trình lNgười sản xuất-người tiêu thụ (Producer- Consumer) lBữa ăn tối của triết gia (Dining Philosophers) lNgười đọc và biên tập viên (Readers-Writers) lNgười thợ cắt tóc ngủ gật (Sleeping Barber) lBathroom Problem lĐồng bộ theo Barriers
ea73ad6304ed438f7e7d4c59ddd227a1:148,ea73ad6304ed438f7e7d4c59ddd227a1,148,149,,,491,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.5 Ví dụ về đồng bộ tiến trình Bài toán người sản xuất (producer)-người tiêu thụ(consumer) Producer Consumer while(1) { /*produce an item in Buffer*/ while (Counter == BUFFER_SIZE) ; /*do nothing*/ Buffer[IN] = nextProduced; IN = (IN + 1) % BUFFER_SIZE; Counter++; } while(1){ while(Counter == 0) ; /*do nothing*/ nextConsumed = Buffer[OUT]; OUT =(OUT + 1) % BUFFER_SIZE; Counter--; /*consume the item in nextConsumed*/ }
ea73ad6304ed438f7e7d4c59ddd227a1:149,ea73ad6304ed438f7e7d4c59ddd227a1,149,150,,,550,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.5 Ví dụ về đồng bộ tiến trình Bài toán người sản xuất (producer)-người tiêu thụ(consumer) Producer Consumer while(1) { /*produce an in Buffer */ if(Counter==SIZE) block(); /*do nothing*/ Buffer[IN] = nextProduced; IN = (IN + 1) % BUFFER_SIZE; Counter++; if(Counter==1) wakeup(Consumer); } while(1){ if(Counter == 0) block(); /*do nothing*/ nextConsumed = Buffer[OUT]; OUT =(OUT + 1) % BUFFER_SIZE; Counter--; if(Counter==SIZE-1) wakeup(Producer); /*consume the item in Buffer*/ }
ea73ad6304ed438f7e7d4c59ddd227a1:150,ea73ad6304ed438f7e7d4c59ddd227a1,150,151,,,628,"l Nhiều tiến trình (Readers) cùng truy nhập một cơ sở dữ liệu (CSDL) l Một số tiến trình (Writers) cập nhật cơ sở dữ liệu l Cho phép số lượng tùy ý các tiến trình Readers cùng truy nhập CSDL l Đang tồn tại một tiến trình Reader truy cập CSDL, mọi tiến trình Readers khác mới xuất hiện đều được truy cập CSDL l (Tiến trình Writers phải xếp hàng chờ đợi) l Chỉ cho phép một tiến trình Writers cập nhật CSDL tại một thời điểm. l Vấn đề không trưng dụng. Các tiến trình ở trong đoạn găng mà không bị ngắt Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.5 Ví dụ về đồng bộ tiến trình Người đọc và biên tập viên"
ea73ad6304ed438f7e7d4c59ddd227a1:151,ea73ad6304ed438f7e7d4c59ddd227a1,151,152,,,467,"l N ghế đợi dành cho khách hàng l Một người thợ chỉ có thể cắt tóc cho một khách hàng tại một thời điểm l Không có khách hàng đợi, thợ cắt tóc ngủ l Khi một khách hàng tới l Nếu thợ cắt tóc đang ngủ⇒Đánh thức anh ta dậy làm việc l Nếu thợ cắt tóc đang làm việc l Không còn ghế đợi trống ⇒bỏ đi l Còn ghế đợi trống⇒Ngồi đợi Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.5 Ví dụ về đồng bộ tiến trình Người thợ cắt tóc ngủ gật (Sleeping Barber)"
ea73ad6304ed438f7e7d4c59ddd227a1:152,ea73ad6304ed438f7e7d4c59ddd227a1,152,153,,,573,"Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.5 Ví dụ về đồng bộ tiến trình Bathroom Problem lA bathroom is to be used by both men and women, but not at the same time lIf the bathroom is empty, then anyone can enter lIf the bathroom is occupied, then only a person of the same sex as the occupant(s) may enter lThe number of people that may be in the bathroom at the same time is limited Bài toán l Yêu cầu cài đặt bài toán thỏa mãn các ràng buộc l Có 2 kiểu tiến trình male() và female() l Mỗi t/trình ở trong Bathroom một khoảng t/gian ngẫu nhiên"
ea73ad6304ed438f7e7d4c59ddd227a1:153,ea73ad6304ed438f7e7d4c59ddd227a1,153,154,,,162,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.5 Ví dụ về đồng bộ tiến trình Đồng bộ barriers l Các tiến trình hướng tới một Ba-ri-e chung
ea73ad6304ed438f7e7d4c59ddd227a1:154,ea73ad6304ed438f7e7d4c59ddd227a1,154,155,,,255,"Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.5 Ví dụ về đồng bộ tiến trình Đồng bộ barriers l Các tiến trình hướng tới một Ba-ri-e chung l Khi đạt tới Ba-ri-e, tất cả các tiến trình đều bị block ngoại trừ tiến trình đến cuối cùng"
ea73ad6304ed438f7e7d4c59ddd227a1:155,ea73ad6304ed438f7e7d4c59ddd227a1,155,156,,,353,"Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.5 Ví dụ về đồng bộ tiến trình Đồng bộ barriers l Các tiến trình hướng tới một Ba-ri-e chung l Khi đạt tới Ba-ri-e, tất cả các tiến trình đều bị block ngoại trừ tiến trình đến cuối cùng l Khi tiến trình cuối tới, đánh thức tất cả các tiến trình đang bị block và cùng vượt qua Ba-ri-e"
ea73ad6304ed438f7e7d4c59ddd227a1:156,ea73ad6304ed438f7e7d4c59ddd227a1,156,157,,,537,"Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.5 Ví dụ về đồng bộ tiến trình Bài toán tạo phân tử H2O l Có 2 kiểu tiến trình (luồng): oxygen and hydrogen l Để kết hợp các tiến trình thành một phân tử nước, cần một Ba-ri-e để các tiến trình phải đợi cho tới khi một phân tử nước sẵn sàng được tạo ra. l Khi mỗi tiến trình vượt qua Ba-ri-e, nó phải kích hoạt liên kết. l Tất cả các tiến trình trong cùng một phân tử nước phải tạo liên kết, trước khi một tiến trình của phân tử nước khác gọi tới thủ tục tạo liên kết"
ea73ad6304ed438f7e7d4c59ddd227a1:157,ea73ad6304ed438f7e7d4c59ddd227a1,157,158,,,537,"Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.5 Ví dụ về đồng bộ tiến trình Bài toán tạo phân tử H2O l Có 2 kiểu tiến trình (luồng): oxygen and hydrogen l Để kết hợp các tiến trình thành một phân tử nước, cần một Ba-ri-e để các tiến trình phải đợi cho tới khi một phân tử nước sẵn sàng được tạo ra. l Khi mỗi tiến trình vượt qua Ba-ri-e, nó phải kích hoạt liên kết. l Tất cả các tiến trình trong cùng một phân tử nước phải tạo liên kết, trước khi một tiến trình của phân tử nước khác gọi tới thủ tục tạo liên kết"
ea73ad6304ed438f7e7d4c59ddd227a1:158,ea73ad6304ed438f7e7d4c59ddd227a1,158,159,,,537,"Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.5 Ví dụ về đồng bộ tiến trình Bài toán tạo phân tử H2O l Có 2 kiểu tiến trình (luồng): oxygen and hydrogen l Để kết hợp các tiến trình thành một phân tử nước, cần một Ba-ri-e để các tiến trình phải đợi cho tới khi một phân tử nước sẵn sàng được tạo ra. l Khi mỗi tiến trình vượt qua Ba-ri-e, nó phải kích hoạt liên kết. l Tất cả các tiến trình trong cùng một phân tử nước phải tạo liên kết, trước khi một tiến trình của phân tử nước khác gọi tới thủ tục tạo liên kết"
ea73ad6304ed438f7e7d4c59ddd227a1:159,ea73ad6304ed438f7e7d4c59ddd227a1,159,160,,,537,"Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.5 Ví dụ về đồng bộ tiến trình Bài toán tạo phân tử H2O l Có 2 kiểu tiến trình (luồng): oxygen and hydrogen l Để kết hợp các tiến trình thành một phân tử nước, cần một Ba-ri-e để các tiến trình phải đợi cho tới khi một phân tử nước sẵn sàng được tạo ra. l Khi mỗi tiến trình vượt qua Ba-ri-e, nó phải kích hoạt liên kết. l Tất cả các tiến trình trong cùng một phân tử nước phải tạo liên kết, trước khi một tiến trình của phân tử nước khác gọi tới thủ tục tạo liên kết"
ea73ad6304ed438f7e7d4c59ddd227a1:160,ea73ad6304ed438f7e7d4c59ddd227a1,160,161,,,537,"Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.5 Ví dụ về đồng bộ tiến trình Bài toán tạo phân tử H2O l Có 2 kiểu tiến trình (luồng): oxygen and hydrogen l Để kết hợp các tiến trình thành một phân tử nước, cần một Ba-ri-e để các tiến trình phải đợi cho tới khi một phân tử nước sẵn sàng được tạo ra. l Khi mỗi tiến trình vượt qua Ba-ri-e, nó phải kích hoạt liên kết. l Tất cả các tiến trình trong cùng một phân tử nước phải tạo liên kết, trước khi một tiến trình của phân tử nước khác gọi tới thủ tục tạo liên kết"
ea73ad6304ed438f7e7d4c59ddd227a1:161,ea73ad6304ed438f7e7d4c59ddd227a1,161,162,,,567,"Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.5 Ví dụ về đồng bộ tiến trình Bữa ăn tối của triết gia l 5 triết gia ăn tối quanh một bàn tròn l Trước mỗi triết gia là một đĩa mì l Giữa 2 đĩa kề nhau là một cái dĩa (fork) l Các triết gia thực hiện luân phiên, liên tục 2 việc :Ăn và Nghĩ l Mỗi triết gia cần 2 cái dĩa để ăn l Chỉ lấy một dĩa tại một thời điểm l Cái bên trái rồi tới cái bên phải l Ăn xong, triết gia để dĩa vào vị trí cũ Bài toán đồng bộ hóa tiến trình nổi tiếng, thể hiện tình trạng nhiều tiến trình phân chia nhiều tài nguyên"
ea73ad6304ed438f7e7d4c59ddd227a1:162,ea73ad6304ed438f7e7d4c59ddd227a1,162,163,,,471,"Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.5 Ví dụ về đồng bộ tiến trình Vấn đề triết gia ăn tối: Phương pháp đơn giản l Mỗi chiếc dĩa là một tài nguyên găng, được điều độ bởi một đèn báo fork[i] l Semaphore fork[5] = {1, 1, 1, 1, 1}; l Thuật toán cho Triết gia Pi l Nếu tất cả các triết gia cùng muốn ăn l Cùng lấy chiếc dĩa bên trái (gọi tới: wait(fork[i])) l Cùng đợi lấy chiếc dĩa bên phải (gọi tới: wait(fork[(i+1)%5])) ⇒Bế tắc (deadlock)"
ea73ad6304ed438f7e7d4c59ddd227a1:163,ea73ad6304ed438f7e7d4c59ddd227a1,163,164,,,355,"Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.5 Ví dụ về đồng bộ tiến trình Vấn đề triết gia ăn tối: Giải pháp 1 l Chỉ cho phép một nhà triết học lấy dĩa tại một thời điểm l Semaphore mutex ←1; l Thuật toán cho Triết gia Pi l Có thể làm cho 2 triết gia không kề nhau cùng được ăn tại một thời điểm (P1: ăn, P2: chiếm mutex⇒P3 đợi)"
ea73ad6304ed438f7e7d4c59ddd227a1:164,ea73ad6304ed438f7e7d4c59ddd227a1,164,165,,,300,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.5 Ví dụ về đồng bộ tiến trình Vấn đề triết gia ăn tối: Giải pháp 2 l Thứ tự lấy dĩa của các triết gia khác nhau l Triết gia số hiệu chẵn lấy dĩa trái trước l Triết gia số hiệu lẻ lấy dĩa phải trước l Giải quyết được vấn đề bế tắc
ea73ad6304ed438f7e7d4c59ddd227a1:165,ea73ad6304ed438f7e7d4c59ddd227a1,165,166,,,879,"Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.5 Ví dụ về đồng bộ tiến trình Vấn đề triết gia ăn tối: Một số giải pháp khác l Trả lại dĩa bên trái nếu không lấy được cái bên phải l Kiểm tra dĩa phải sẵn sàng trước khi gọi wait(fork[(i+1)%5]) l Nếu không sẵn có: trả lại dĩa trái, đợi một thời gian rồi thử lại l Không bị bế tắc, nhưng không tiến triển:nạn đói (starvation) l Thực hiện trong thực tế, nhưng không đảm bảo về lý thuyết của đề bài l Sử dụng đèn báo đồng thời PSim(S1, S2, . . . , Sn) l Thu được tất cả đèn báo cùng một thời điểm hoặc không có bất kỳ đèn báo nào l Thao tác PSim(S1, S2, . . . , Sn) sẽ block() tiến trình/luồng gọi khi có bất kỳ một đèn báo nào không thể thu được l Thuật toán l Khó cài đặt đèn báo đồng thời l Giải pháp đề xuất bởi Tanenbaum (Tanenbaum 2001) PSim(fork[i], fork[(i+1)% 5]); { Ăn} VSim(fork[i], fork[(i+1)% 5]);"
ea73ad6304ed438f7e7d4c59ddd227a1:166,ea73ad6304ed438f7e7d4c59ddd227a1,166,167,,,134,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.5 Ví dụ về đồng bộ tiến trình Vấn đề triết gia ăn tối: Minh họa
ea73ad6304ed438f7e7d4c59ddd227a1:167,ea73ad6304ed438f7e7d4c59ddd227a1,167,168,,,115,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.5 Ví dụ về đồng bộ tiến trình True problem ?
ea73ad6304ed438f7e7d4c59ddd227a1:168,ea73ad6304ed438f7e7d4c59ddd227a1,168,169,,,252,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.6 Công cụ điều độ cấp cao lKhái niệm tài nguyên găng lPhương pháp khóa trong lPhương pháp kiểm tra và xác lập lKỹ thuật đèn báo lVí dụ về đồng bộ tiến trình lCông cụ điều độ cấp cao
ea73ad6304ed438f7e7d4c59ddd227a1:169,ea73ad6304ed438f7e7d4c59ddd227a1,169,170,,,546,"Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.6 Công cụ điều độ cấp cao Giới thiệu l Là một kiểu dữ liệu đặc biệt, được đề xuất bởi HOARE 1974 l Bao gồm các thủ tục, dữ liệu cục bộ, đoạn mã khởi tạo l Các tiến trình chỉ có thể truy nhập tới các biến bằng cách gọi tới các thủ tục trong Monitor l Tại một thời điểm chỉ có một tiến trình được quyền sử dụng Monitor l Tiến trình khác muốn sử dụng, phải chờ đợi l Cho phép các tiến trình đợi trong Monitor l Sử dụng các biến điều kiện (condition variable) Cú pháp của Monitor"
ea73ad6304ed438f7e7d4c59ddd227a1:170,ea73ad6304ed438f7e7d4c59ddd227a1,170,171,,,104,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.6 Công cụ điều độ cấp cao Mô hình
ea73ad6304ed438f7e7d4c59ddd227a1:171,ea73ad6304ed438f7e7d4c59ddd227a1,171,172,,,111,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.6 Công cụ điều độ cấp cao Biến điều kiện
ea73ad6304ed438f7e7d4c59ddd227a1:172,ea73ad6304ed438f7e7d4c59ddd227a1,172,173,,,104,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.6 Công cụ điều độ cấp cao Mô hình
ea73ad6304ed438f7e7d4c59ddd227a1:173,ea73ad6304ed438f7e7d4c59ddd227a1,173,174,,,134,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.6 Công cụ điều độ cấp cao Sử dụng Monitor: một tài nguyên chung
ea73ad6304ed438f7e7d4c59ddd227a1:174,ea73ad6304ed438f7e7d4c59ddd227a1,174,175,,,125,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.6 Công cụ điều độ cấp cao Bài toán Producer - Consumer
ea73ad6304ed438f7e7d4c59ddd227a1:175,ea73ad6304ed438f7e7d4c59ddd227a1,175,176,,,133,Chương 2 Quản lí tiến trình ①Tiến trình ②Luồng (Thread) ③Điều phối CPU ④Tài nguyên găng và điều độ tiến trình ⑤Bế tắc và xử lý bế tắc
ea73ad6304ed438f7e7d4c59ddd227a1:176,ea73ad6304ed438f7e7d4c59ddd227a1,176,179,,,226,Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.1. Khái niệm bế tắc(Deadlock) l Khái niệm bế tắc l Điều kiện xảy ra bế tắc l Các phương pháp xử lý bế tắc l Phòng ngừa bế tắc l Phòng tránh bế tắc l Nhận biết và khắc phục
ea73ad6304ed438f7e7d4c59ddd227a1:177,ea73ad6304ed438f7e7d4c59ddd227a1,177,180,,,637,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.1. Khái niệm bế tắc(Deadlock) l Hệ thống gồm nhiều tiến trình hoạt động đồng thời cùng sử dụng tài nguyên l Tài nguyên có nhiều loại (VD: CPU, bộ nhớ,..). l Mỗi loại tài nguyên có nhiều đơn vị (VD: 2 CPU, 5 máy in..) l Mỗi tiến trình thường gồm dãy liên tục các thao tác l Đòi hỏi tài nguyên: Nếu tài nguyên không có sẵn (đang được s/dụng bởi tiến trình khác) ⇒tiến trình yêu cầu phải đợi l Sử dụng tài nguyên theo yêu cầu (in ấn, đọc dữ liệu...) l Giải phóng tài nguyên được cấp l Khi các tiến trình dùng chung ít nhất 2 tài nguyên, hệ thống có thể gặp ""nguy hiểm"" Khái niệm bế tắc"
ea73ad6304ed438f7e7d4c59ddd227a1:178,ea73ad6304ed438f7e7d4c59ddd227a1,178,181,,,355,Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.1. Khái niệm bế tắc(Deadlock) l Xét ví dụ: Hệ thống có hai tiến trình P1 & P2 l Hai tiến trình P1 & P2 dùng chung hai tài nguyên R1 & R2 l R1 được điều độ bởi đèn báo S1 (S1 ←1) l R2 được điều độ bởi đèn báo S2 (S2 ←1) l Đoạn mã cho P1 và P2 Khái niệm bế tắc P(S1) P(S2) { Sử dụng R1&R2 } V(S1) V(S2)
ea73ad6304ed438f7e7d4c59ddd227a1:179,ea73ad6304ed438f7e7d4c59ddd227a1,179,182,,,234,Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.1. Khái niệm bế tắc(Deadlock) Ví dụ P(S1) P(S2) { Sử dụng R1&R2 } V(S1) V(S2) P(S1) P(S2) { Sử dụng R1&R2 } V(S1) V(S2) Process P1 Process P2 Process P1 Process P2 t S2 = 1 S1 = 1
ea73ad6304ed438f7e7d4c59ddd227a1:180,ea73ad6304ed438f7e7d4c59ddd227a1,180,183,,,240,Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.1. Khái niệm bế tắc(Deadlock) Ví dụ P(S1) P(S2) { Sử dụng R1&R2 } V(S1) V(S2) P(S1) P(S2) { Sử dụng R1&R2 } V(S1) V(S2) Process P1 Process P2 Process P1 Process P2 t S2 = 1 S1 = 0 P(S1)
ea73ad6304ed438f7e7d4c59ddd227a1:181,ea73ad6304ed438f7e7d4c59ddd227a1,181,184,,,274,Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.1. Khái niệm bế tắc(Deadlock) Ví dụ P(S1) P(S2) { Sử dụng R1&R2 } V(S1) V(S2) P(S1) P(S2) { Sử dụng R1&R2 } V(S1) V(S2) Process P1 Process P2 Process P1 Process P2 t S2 = 1 S1 = -1 P(S1) P(S1) P2 block() Vào hàng đợi R1
ea73ad6304ed438f7e7d4c59ddd227a1:182,ea73ad6304ed438f7e7d4c59ddd227a1,182,185,,,280,Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.1. Khái niệm bế tắc(Deadlock) Ví dụ P(S1) P(S2) { Sử dụng R1&R2 } V(S1) V(S2) P(S1) P(S2) { Sử dụng R1&R2 } V(S1) V(S2) Process P1 Process P2 Process P1 Process P2 t S2 = 0 S1 = -1 P(S1) P(S1) P2 block() Vào hàng đợi R1 P(S2)
ea73ad6304ed438f7e7d4c59ddd227a1:183,ea73ad6304ed438f7e7d4c59ddd227a1,183,186,,,283,Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.1. Khái niệm bế tắc(Deadlock) Ví dụ P(S1) P(S2) { Sử dụng R1&R2 } V(S1) V(S2) P(S1) P(S2) { Sử dụng R1&R2 } V(S1) V(S2) Process P1 Process P2 Process P1 Process P2 t S2 = 0 S1 = 0 P(S1) P(S1) P(S2) Sử dụng R1&R2 V(S1) wakeup(P2)
ea73ad6304ed438f7e7d4c59ddd227a1:184,ea73ad6304ed438f7e7d4c59ddd227a1,184,187,,,317,Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.1. Khái niệm bế tắc(Deadlock) Ví dụ P(S1) P(S2) { Sử dụng R1&R2 } V(S1) V(S2) P(S1) P(S2) { Sử dụng R1&R2 } V(S1) V(S2) Process P1 Process P2 Process P1 Process P2 t S2 = -1 S1 = 0 P(S1) P(S1) P(S2) Sử dụng R1&R2 V(S1) wakeup(P2) P(S2) P2 block() Vào hàng đợi R2
ea73ad6304ed438f7e7d4c59ddd227a1:185,ea73ad6304ed438f7e7d4c59ddd227a1,185,188,,,295,Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.1. Khái niệm bế tắc(Deadlock) Ví dụ P(S1) P(S2) { Sử dụng R1&R2 } V(S1) V(S2) P(S1) P(S2) { Sử dụng R1&R2 } V(S1) V(S2) Process P1 Process P2 Process P1 Process P2 t S2 = 0 S1 = 0 P(S1) P(S1) P(S2) Sử dụng R1&R2 V(S1) P(S2) V(S2) wakeup(P2)
ea73ad6304ed438f7e7d4c59ddd227a1:186,ea73ad6304ed438f7e7d4c59ddd227a1,186,189,,,309,Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.1. Khái niệm bế tắc(Deadlock) Ví dụ P(S1) P(S2) { Sử dụng R1&R2 } V(S1) V(S2) P(S1) P(S2) { Sử dụng R1&R2 } V(S1) V(S2) Process P1 Process P2 Process P1 Process P2 t S2 = 0 S1 = 0 P(S1) P(S1) P(S2) Sử dụng R1&R2 V(S1) P(S2) V(S2) wakeup(P2) Sử dụng R1&R2
ea73ad6304ed438f7e7d4c59ddd227a1:187,ea73ad6304ed438f7e7d4c59ddd227a1,187,190,,,234,Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.1. Khái niệm bế tắc(Deadlock) Ví dụ P(S1) P(S2) { Sử dụng R1&R2 } V(S1) V(S2) P(S2) P(S1) { Sử dụng R1&R2 } V(S1) V(S2) Process P1 Process P2 Process P1 Process P2 t S2 = 1 S1 = 1
ea73ad6304ed438f7e7d4c59ddd227a1:188,ea73ad6304ed438f7e7d4c59ddd227a1,188,191,,,240,Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.1. Khái niệm bế tắc(Deadlock) Ví dụ P(S1) P(S2) { Sử dụng R1&R2 } V(S1) V(S2) P(S2) P(S1) { Sử dụng R1&R2 } V(S1) V(S2) Process P1 Process P2 Process P1 Process P2 t S2 = 1 S1 = 0 P(S1)
ea73ad6304ed438f7e7d4c59ddd227a1:189,ea73ad6304ed438f7e7d4c59ddd227a1,189,192,,,246,Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.1. Khái niệm bế tắc(Deadlock) Ví dụ P(S1) P(S2) { Sử dụng R1&R2 } V(S1) V(S2) P(S2) P(S1) { Sử dụng R1&R2 } V(S1) V(S2) Process P1 Process P2 Process P1 Process P2 t S2 = 0 S1 = 0 P(S1) P(S2)
ea73ad6304ed438f7e7d4c59ddd227a1:190,ea73ad6304ed438f7e7d4c59ddd227a1,190,193,,,280,Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.1. Khái niệm bế tắc(Deadlock) Ví dụ P(S1) P(S2) { Sử dụng R1&R2 } V(S1) V(S2) P(S2) P(S1) { Sử dụng R1&R2 } V(S1) V(S2) Process P1 Process P2 Process P1 Process P2 t S2 = -1 S1 = 0 P(S1) P(S2) P(S2) P1 block() Vào hàng đợi R2
ea73ad6304ed438f7e7d4c59ddd227a1:191,ea73ad6304ed438f7e7d4c59ddd227a1,191,194,,,314,Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.1. Khái niệm bế tắc(Deadlock) Ví dụ P(S1) P(S2) { Sử dụng R1&R2 } V(S1) V(S2) P(S2) P(S1) { Sử dụng R1&R2 } V(S1) V(S2) Process P1 Process P2 Process P1 Process P2 t S2 = -1 S1 = -1 P(S1) P(S2) P(S2) P1 block() Vào hàng đợi R2 P(S1) P2 block() Vào hàng đợi R1
ea73ad6304ed438f7e7d4c59ddd227a1:192,ea73ad6304ed438f7e7d4c59ddd227a1,192,195,,,323,Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.1. Khái niệm bế tắc(Deadlock) Ví dụ P(S1) P(S2) { Sử dụng R1&R2 } V(S1) V(S2) P(S2) P(S1) { Sử dụng R1&R2 } V(S1) V(S2) Process P1 Process P2 Process P1 Process P2 t S2 = -1 S1 = -1 P(S1) P(S2) P(S2) P1 block() Vào hàng đợi R2 P(S1) P2 block() Vào hàng đợi R1 Deadlock
ea73ad6304ed438f7e7d4c59ddd227a1:193,ea73ad6304ed438f7e7d4c59ddd227a1,193,196,,,254,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.1. Khái niệm bế tắc(Deadlock) Định nghĩa Bế tắc là tình trạng l Hai hay nhiều tiến trình cùng chờ đợi một sự kiện nào đó xảy ra l Nếu không có sự tác động gì từ bên ngoài, thì sự chờ đợi đó là vô hạn"
ea73ad6304ed438f7e7d4c59ddd227a1:194,ea73ad6304ed438f7e7d4c59ddd227a1,194,197,,,226,Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.1. Khái niệm bế tắc(Deadlock) l Khái niệm bế tắc l Điều kiện xảy ra bế tắc l Các phương pháp xử lý bế tắc l Phòng ngừa bế tắc l Phòng tránh bế tắc l Nhận biết và khắc phục
ea73ad6304ed438f7e7d4c59ddd227a1:195,ea73ad6304ed438f7e7d4c59ddd227a1,195,198,,,938,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.2. Điều kiện xảy ra bế tắc Cần có 4 điều kiện sau, không được thiếu điều kiện nào l Tồn tại tài nguyên găng l Tài nguyên được sử dụng theo mô hình không phân chia được l Chỉ có một tiến trình dung tài nguyên tại một thời điểm l Tiến trình khác cũng yêu cầu tài nguyên ⇒yêu cầu phải được hoãn lại tới khi tài nguyên được giải phóng l Chờ đợi trước khi vào đoạn găng l Tiến trình không được vào đoạn găng phải xếp hàng chờ đợi. l Trong khi chờ đợi vẫn chiếm giữ các tài nguyên được cung cấp l Không có hệ thống phân phối lại tài nguyên găng l Tài nguyên không thể được trưng dụng l Tài nguyên được giải phỏng chỉ bởi tiến trình đang chiếm giữ khi đã hoàn thành nhiệm vụ l Chờ đợi vòng tròn l Tồn tại tập các tiến trình {P0, P2, . . . , Pn} đang đợi nhau theo kiểu: P0 →R1 →P1; P1 →R2 →P2; . . . Pn−1 →Rn →Pn; Pn →R0 →P0 l Chờ đợi vòng tròn tạo ra chu trình không kết thúc Điều kiện cần"
ea73ad6304ed438f7e7d4c59ddd227a1:196,ea73ad6304ed438f7e7d4c59ddd227a1,196,199,,,223,Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.2. Điều kiện xảy ra bế tắc l Tài nguyên găng l Chờ đợi trước khi vào đoạn găng l Trưng dụng tài nguyên găng l Chờ đợi vòng tròn Ví dụ: Bài toán bữa ăn tối của triết gia
ea73ad6304ed438f7e7d4c59ddd227a1:197,ea73ad6304ed438f7e7d4c59ddd227a1,197,200,,,584,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.2. Điều kiện xảy ra bế tắc l Dùng để mô hình hóa tình trạng bế tắc trong hệ thống l Là đồthị định hướng gồm tập đỉnh V và tập cung E l Tập đỉnh V được chia thành 2 kiểu đỉnh l P = {P1, P2, . . . Pn} Tập chứa tất cả các tiến trình trong hệ thống l R = {R1, R2, . . . Rm} Tập chứa tất cả các kiểu tài nguyên trong hệ thống l Tập các cung E gồm 2 loại l Cung yêu cầu: đi từ tiến trình Pi tới tài nguyên Rj: Pi →Rj l Cung sử dụng: Đi từ tài nguyên Rj tới tiến trình Pi: Rj →Pi Đồ thị cung cấp tài nguyên (Resource Allocation Graph) I"
ea73ad6304ed438f7e7d4c59ddd227a1:198,ea73ad6304ed438f7e7d4c59ddd227a1,198,201,,,387,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.2. Điều kiện xảy ra bế tắc Khi một tiến trình Pi yêu cầu tài nguyên Rj l Cung yêu cầu Pi →Rj được chèn vào đồ thị l Nếu yêu cầu được thỏa mãn, cung yêu cầu chuyển thành cung sử dung Rj →Pi l Khi tiến trình Pi giải phóng tài nguyên Rj, cung sử dụng Rj → Pi bị xóa khỏi đồ thị Đồ thị cung cấp tài nguyên (Resource Allocation Graph) II"
ea73ad6304ed438f7e7d4c59ddd227a1:199,ea73ad6304ed438f7e7d4c59ddd227a1,199,202,,,480,Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.2. Điều kiện xảy ra bế tắc l Đỉnh kiểu tiến trình được thể hiện bằng hình tròn l Đỉnh kiểu tài nguyên được thể hiện bằng hình chữ nhật l Mỗi đơn vị của kiểu tài nguyên được biểu thị bằng một dấu chấm trong hình chữ nhật l Cung yêu cầu đi từ đỉnh tiến trình tới đỉnh tài nguyên l Cung sử dụng xuất phát từ dấu chấm bên trong đỉnh tài nguyên tới đỉnh tiến trình Đồ thị cung cấp tài nguyên: Biểu diễn đồ trong đồ thị P P P R R R
ea73ad6304ed438f7e7d4c59ddd227a1:200,ea73ad6304ed438f7e7d4c59ddd227a1,200,203,,,273,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.2. Điều kiện xảy ra bế tắc l Trạng thái hệ thống l 3 tiến trình P1, P2, P3 l 4 tài nguyên R1, R2, R3, R4 l P3 yêu cầu tài nguyên R4 l Xuất hiện cung yêu cầu P3 →R4 Đồ thị cung cấp tài nguyên: Ví dụ P1 P2 P3 R2 R3 R1 R4"
ea73ad6304ed438f7e7d4c59ddd227a1:201,ea73ad6304ed438f7e7d4c59ddd227a1,201,204,,,328,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.2. Điều kiện xảy ra bế tắc l Trạng thái hệ thống l 3 tiến trình P1, P2, P3 l 4 tài nguyên R1, R2, R3, R4 l P3 yêu cầu tài nguyên R4 l Xuất hiện cung yêu cầu P3 →R4 l Cung yêu cầu P3 →R4 chuyển thành cung sử dụng R4 →P3 Đồ thị cung cấp tài nguyên: Ví dụ P1 P2 P3 R2 R3 R1 R4"
ea73ad6304ed438f7e7d4c59ddd227a1:202,ea73ad6304ed438f7e7d4c59ddd227a1,202,205,,,399,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.2. Điều kiện xảy ra bế tắc l Trạng thái hệ thống l 3 tiến trình P1, P2, P3 l 4 tài nguyên R1, R2, R3, R4 l P3 yêu cầu tài nguyên R4 l Xuất hiện cung yêu cầu P3 →R4 l Cung yêu cầu P3 →R4 chuyển thành cung sử dụng R4 →P3 l P3 Giải phóng tài nguyên R4 l Cung sử dụng R4 →P3 bị xóa khỏi đồ thị Đồ thị cung cấp tài nguyên: Ví dụ P1 P2 P3 R2 R3 R1 R4"
ea73ad6304ed438f7e7d4c59ddd227a1:203,ea73ad6304ed438f7e7d4c59ddd227a1,203,206,,,510,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.2. Điều kiện xảy ra bế tắc l Trạng thái hệ thống l 3 tiến trình P1, P2, P3 l 4 tài nguyên R1, R2, R3, R4 l P3 yêu cầu tài nguyên R4 l Xuất hiện cung yêu cầu P3 →R4 l Cung yêu cầu P3 →R4 chuyển thành cung sử dụng R4 →P3 l P3 Giải phóng tài nguyên R4 l Cung sử dụng R4 →P3 bị xóa khỏi đồ thị l P3 yêu cầu tài nguyên R1 l Xuất hiện cung yêu cầu P3 →R1 l Trên đồ thị xuất hiện chu trình l Hệ thống bế tắc Đồ thị cung cấp tài nguyên: Ví dụ P1 P2 P3 R2 R3 R1 R4"
ea73ad6304ed438f7e7d4c59ddd227a1:204,ea73ad6304ed438f7e7d4c59ddd227a1,204,207,,,423,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.2. Điều kiện xảy ra bế tắc l Đồ thị không chứa chu trình, không bế tắc l Nếu đồ thị chứa đựng chu trình l Nếu tài nguyên chỉ có 1 đơn vị ⇒Bế tắc l Nếu tài nguyên có nhiều hơn 1 đơn vị: có khả năng bế tắc Đồ thị cung cấp tài nguyên: Lập luận cơ bản Chu trình trên đồ thị và tình trạng bế tắc có liên quan ? P1 P3 P2 R2 R1 Đồ thị có chu trình nhưng hệ thống không bế tắc"
ea73ad6304ed438f7e7d4c59ddd227a1:205,ea73ad6304ed438f7e7d4c59ddd227a1,205,208,,,227,Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.3 Các phương pháp xử lý bế tắc l Khái niệm bế tắc l Điều kiện xảy ra bế tắc l Các phương pháp xử lý bế tắc l Phòng ngừa bế tắc l Phòng tránh bế tắc l Nhận biết và khắc phục
ea73ad6304ed438f7e7d4c59ddd227a1:206,ea73ad6304ed438f7e7d4c59ddd227a1,206,209,,,804,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.3. Các phương pháp xử lý bế tắc l Phòng ngừa l Áp dụng các biện pháp để đảm bảo hệ thống không bao giờ rơi vào tình trạng bế tắc l Tốn kém l Áp dụng cho hệ thống hay xảy ra bế tắc và tổn thất do bế tắc gây ra lớn l Phòng tránh l Kiểm tra từng yêu cầu tài nguyên của tiến trình và không chấp nhận yêu cầu nếu việc cung cấp tài nguyên có khả năng dẫn đến tình trạng bế tắc l Thường yêu cầu các thông tin phụ trợ l Áp dụng cho hệ thống ít xảy ra bế tắc nhưng tổn hại lớn l Nhận biết và khắc phục l Cho phép hệ thống hoạt động bình thường ⇒có thểrơi vào tình trạng bế tắc l Định kỳ kiểm tra xem bế tắc có đang xảy ra không l Nếu đang bế tắc, áp dụng các biện pháp loại bỏ bế tắc l Áp dụng cho hệ thống ít xảy ra bế tắc và thiệt hại không lớn Phương pháp"
ea73ad6304ed438f7e7d4c59ddd227a1:207,ea73ad6304ed438f7e7d4c59ddd227a1,207,210,,,216,Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.4 Phòng ngừa bế tắc l Khái niệm bế tắc l Điều kiện xảy ra bế tắc l Các phương pháp xử lý bế tắc l Phòng ngừa bế tắc l Phòng tránh bế tắc l Nhận biết và khắc phục
ea73ad6304ed438f7e7d4c59ddd227a1:208,ea73ad6304ed438f7e7d4c59ddd227a1,208,211,,,245,Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.4 Phòng ngừa bế tắc Tác động vào 1 trong 4 điều kiện cần của bế tắc để nó không xảy ra Tài nguyên găng Chờ đợi trước khi vào đoạn găng Trưng dụng tài nguyên găng Chờ đợi vòng tròn Nguyên tắc
ea73ad6304ed438f7e7d4c59ddd227a1:209,ea73ad6304ed438f7e7d4c59ddd227a1,209,212,,,575,Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.4 Phòng ngừa bế tắc Điều kiện tài nguyên găng l Giảm bớt mức độ găng của hệ thống l Tài nguyên phân chia được (file chỉ đọc): Sử dụng đồng thời l Tài nguyên không phân chia được: Sử dụng không đồng thời l Kỹ thuật SPOOL(Simultaneous peripheral operation on-line) l Không phân phối tài nguyên khi không thực sự cần thiết l Chỉ một số ít tiến trình có khả năng yêu cầu tài nguyên l Chỉ printer daemon mới làm việc với máy in ⇒Bế tắc cho tài nguyên máy in bị hủy bỏ l Không phải tài nguyên nào cũng dùng kỹ thuật SPOOL được
ea73ad6304ed438f7e7d4c59ddd227a1:210,ea73ad6304ed438f7e7d4c59ddd227a1,210,213,,,702,Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.4 Phòng ngừa bế tắc Điều kiện chờ đợi trước khi vào đoạn găng Nguyên tắc: Đảm bảo môt tiến trình xin tài nguyên chỉ khi không sở hữu bất kỳ tài nguyên nào khác l Cung cấp trước l Tiến trình xin toàn bộ tài nguyên ngay từ đầu và chỉ thực hiện khi đã có đầy đủ tài nguyên l Hiệu quả sử dụng tài nguyên thấp l Tiến trình chỉ sử dụng tài nguyên ở giai đoạn cuối? l Tổng số tài nguyên đòi hỏi vượt quá khả năng của hệ thống? l Giải phóng tài nguyên l Tiến trình giải phóng tất cả tài nguyên trước khi xin (xin lại) tài nguyên mới l Nhận xét l Tốc độ thực hiện tiến trình chậm l Phải đảm bảo dữ liệu được giữ trong tài nguyên tạm giải phóng không bị mất
ea73ad6304ed438f7e7d4c59ddd227a1:211,ea73ad6304ed438f7e7d4c59ddd227a1,211,214,,,381,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.4 Phòng ngừa bế tắc Điều kiện chờ đợi trước khi vào đoạn găng: Ví dụ l Tiến trình gồm 2 giai đoạn l Sao chép dữ liệu từ băng từ sang một file trên đĩa từ l Sắp xếp dữ liệu trong file và đưa ra máy in l Phương pháp cung cấp trước l Xin cả băng từ, file trên đĩa và máy in l Lãng phí máy in giai đoạn đầu, băng từ giai đoạn cuối"
ea73ad6304ed438f7e7d4c59ddd227a1:212,ea73ad6304ed438f7e7d4c59ddd227a1,212,215,,,464,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.4 Phòng ngừa bế tắc Điều kiện chờ đợi trước khi vào đoạn găng: Ví dụ l Tiến trình gồm 2 giai đoạn l Sao chép dữ liệu từ băng từ sang một file trên đĩa từ l Sắp xếp dữ liệu trong file và đưa ra máy in l Phương pháp cung cấp trước l Xin cả băng từ, file trên đĩa và máy in l Lãng phí máy in giai đoạn đầu, băng từ giai đoạn cuối l Phương pháp giải phóng tài nguyên l Xin băng từ và file trên đĩa cho giai đoạn 1"
ea73ad6304ed438f7e7d4c59ddd227a1:213,ea73ad6304ed438f7e7d4c59ddd227a1,213,216,,,548,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.4 Phòng ngừa bế tắc Điều kiện chờ đợi trước khi vào đoạn găng: Ví dụ l Tiến trình gồm 2 giai đoạn l Sao chép dữ liệu từ băng từ sang một file trên đĩa từ l Sắp xếp dữ liệu trong file và đưa ra máy in l Phương pháp cung cấp trước l Xin cả băng từ, file trên đĩa và máy in l Lãng phí máy in giai đoạn đầu, băng từ giai đoạn cuối l Phương pháp giải phóng tài nguyên l Xin băng từ và file trên đĩa cho giai đoạn 1 l Giải phóng băng từ và file trên đĩa l Xin file trên đĩa và máy in cho giai đoạn 2"
ea73ad6304ed438f7e7d4c59ddd227a1:214,ea73ad6304ed438f7e7d4c59ddd227a1,214,217,,,626,Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.4 Phòng ngừa bế tắc Điều kiện trưng dụng tài nguyên găng Nguyên tắc: cho phép trưng dụng tài nguyên khi cần thiết l Tiến trình Pi xin tài nguyên Rj l Rj sẵn có: Cung cấp Rj cho Pi l Rj không sẵn: (Rj bị chiếm bởi tiến trình Pk) l Pk đang đợi tài nguyên khác l Trưng dụng Rj từ Pk và cung cấp cho Pi theo yêu cầu l Thêm Rj vào danh sách các tài nguyên đang thiếu của Pk l Pk được thực hiện trở lại khi l Có được tài nguyên đang thiếu l Đòi lại được Rj l Pk đang thực hiện l Pi phải đợi (không giải phóng tài nguyên) l Cho phép trưng dụng tài nguyên nhưng chỉ khi cần thiết
ea73ad6304ed438f7e7d4c59ddd227a1:215,ea73ad6304ed438f7e7d4c59ddd227a1,215,218,,,366,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.4 Phòng ngừa bế tắc Điều kiện trưng dụng tài nguyên găng Nguyên tắc: cho phép trưng dụng tài nguyên khi cần thiết l Chỉ áp dụng cho các tài nguyên có thể lưu trữ và khôi phục trạng thái dễ dàng l (CPU, không gian nhớ) l Khó có thể áp dụng cho các tài nguyên như máy in l Một tiến trình bị trưng dụng nhiều lần ?"
ea73ad6304ed438f7e7d4c59ddd227a1:216,ea73ad6304ed438f7e7d4c59ddd227a1,216,219,,,625,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.4 Phòng ngừa bế tắc Điều kiện chờ đợi vòng tròn l Đặt ra một thứ tự toàn cục của tất cả các kiểu tài nguyên l R = {R1, R2, . . . Rn} Tập tất cả các kiểu tài nguyên l Xây dựng hàm trật tự f : R →N l Hàm f được xây dựng dựa trên trật tự sử dụng các tài nguyên f(Băng từ) = 1 f( Đĩa từ) = 5 f(Máy in) = 12 l Tiến trình chỉ được yêu cầu tài nguyên theo trật tự tăng l Tiến trình chiếm giữ tài nguyên kiểu Rk chỉ được xin tài nguyên kiểu Rj thỏa mãn f(Rj) > f(Rk) l Tiến trình yêu cầu tới tài nguyên Rk sẽ phải giải phóng tất cả tài nguyên Ri thỏa mãn điều kiện f(Ri) ≥ f(Rk)"
ea73ad6304ed438f7e7d4c59ddd227a1:217,ea73ad6304ed438f7e7d4c59ddd227a1,217,220,,,597,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.4 Phòng ngừa bế tắc Điều kiện chờ đợi vòng tròn l Tiến trình chỉ được yêu cầu tài nguyên theo trật tự tăng l Tiến trình chiếm giữ tài nguyên kiểu Rk chỉ được xin tài nguyên kiểu Rj thỏa mãn f(Rj) > f(Rk) l Tiến trình yêu cầu tới tài nguyên Rk sẽ phải giải phóng tất cả tài nguyên Ri thỏa mãn điều kiện f(Ri) ≥ f(Rk) l Chứng minh l Giả thiết bế tắc xảy ra giữa các tiến trình {P1, P2, . . . Pm} l R1 →P1 →R2 →P2 ⇒f(R1) < f(R2) l R2 →P2 →R3 →P3 ⇒f(R2) < f(R3) . . . l Rm →Pm →R1 →P1 ⇒f(Rm) < f(R1) l f(R1) < f(R2) < . . . < f(Rm) < f(R1) ⇒Vô lý"
ea73ad6304ed438f7e7d4c59ddd227a1:218,ea73ad6304ed438f7e7d4c59ddd227a1,218,221,,,217,Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.5 Phòng tránh bế tắc l Khái niệm bế tắc l Điều kiện xảy ra bế tắc l Các phương pháp xử lý bế tắc l Phòng ngừa bế tắc l Phòng tránh bế tắc l Nhận biết và khắc phục
ea73ad6304ed438f7e7d4c59ddd227a1:219,ea73ad6304ed438f7e7d4c59ddd227a1,219,222,,,145,Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.5 Phòng tránh bế tắc Ví dụ P1 P2 S2 = 1 S1 = 1 P(S1) P(S2) P(S2) P(S1) t S1 = 0 yêu cầu R1
ea73ad6304ed438f7e7d4c59ddd227a1:220,ea73ad6304ed438f7e7d4c59ddd227a1,220,223,,,149,Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.5 Phòng tránh bế tắc Ví dụ P1 P2 S2 = 1 P(S1) P(S2) P(S2) P(S1) t S1 = 0 sử dụng R1 yêu cầu R2
ea73ad6304ed438f7e7d4c59ddd227a1:221,ea73ad6304ed438f7e7d4c59ddd227a1,221,224,,,160,Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.5 Phòng tránh bế tắc Ví dụ P1 P2 S2 = 0 P(S1) P(S2) P(S2) P(S1) t S1 = 0 sử dụng R1 sử dụng R2 yêu cầu R1
ea73ad6304ed438f7e7d4c59ddd227a1:222,ea73ad6304ed438f7e7d4c59ddd227a1,222,225,,,189,Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.5 Phòng tránh bế tắc Ví dụ P1 P2 S2 = 0 P(S1) P(S2) P(S2) P(S1) t S1 = -1 Yêu cầu R2 sử dụng R2 yêu cầu R1 sử dụng R1 S2 = -1 DeadLock
ea73ad6304ed438f7e7d4c59ddd227a1:223,ea73ad6304ed438f7e7d4c59ddd227a1,223,226,,,170,Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.5 Phòng tránh bế tắc Ví dụ P1 P2 S2 = 1 P(S1) P(S2) P(S2) P(S1) t S1 = 0 sử dụng R1 yêu cầu R2 Block(P2) Yêu cầu R2
ea73ad6304ed438f7e7d4c59ddd227a1:224,ea73ad6304ed438f7e7d4c59ddd227a1,224,227,,,376,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.5 Phòng tránh bế tắc Ví dụ P1 P2 S2 = 0 P(S1) P(S2) P(S2) P(S1) t S1 = 0 sử dụng R1 yêu cầu R2 Block(P2) sử dụng R2 Nhận xét: Nếu biết được chuỗi yêu cầu/giải phóng tài nguyên của các tiến trình, hệ thống có thể đưa ra được chiến lược phân phối tài nguyên (chấp thuận hay phải đợi) cho mọi yêu cầu để bế tắc không xảy ra."
ea73ad6304ed438f7e7d4c59ddd227a1:225,ea73ad6304ed438f7e7d4c59ddd227a1,225,228,,,923,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.5 Phòng tránh bế tắc Nguyên tắc l Phải biết trước các thông tin về tiến trình và tài nguyên l Tiến trình phải khai báo lượng tài nguyên lớn nhất mỗi loại sẽ yêu cầu khi thực hiện l Quyết định dựa trên kết quả kiểm tra trạng thái cung cấp tài nguyên (Resource-Allocation State) -Trạng thái hệ thống l Trạng thái cung cấp tài nguyên xác định bởi các thông số l Số đơn vị tài nguyên có sẵn trong hệ thống l Số đơn vị tài nguyên đã được cấp cho mỗi tiến trình l Số đơn vị tài nguyên lớn nhất mỗi tiến trình có thể yêu cầu l Nếu hệ thống an toàn, sẽ đáp ứng cho yêu cầu l Thực hiện kiểm tra mỗi khi nhận được yêu cầu tài nguyên l Mục đích: Đảm bảo trạng thái hệ thống luôn an toàn l Thời điểm ban đầu (chưa c/cấp tài nguyên), hệ thống an toàn l Hệ thống chỉ cung cấp tài nguyên khi vẫn đảm bảo an toàn ⇒Hệ thống chuyển từ trạng thái an toàn này sang trạng thái an toàn khác"
ea73ad6304ed438f7e7d4c59ddd227a1:226,ea73ad6304ed438f7e7d4c59ddd227a1,226,229,,,303,Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.5 Phòng tránh bế tắc Trạng thái an toàn Trạng thái của hệ thống là an toàn khi l Có thể cung cấp tài nguyên cho từng tiến trình (đến yêu cầu lớn nhất) theo một trật tự nào đấy mà không xảy ra bế tắc l Tồn tại chuỗi an toàn của tất cả các tiến trình
ea73ad6304ed438f7e7d4c59ddd227a1:227,ea73ad6304ed438f7e7d4c59ddd227a1,227,230,,,781,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.5 Phòng tránh bế tắc Chuỗi an toàn Chuỗi tiến trình P={P1, P2, . . . , Pn} là an toàn nếu l Với mỗi tiến trình Pi, mọi yêu cầu tài nguyên trong tương lai đều có thể đáp ứng nhờ vào l Lượng tài nguyên hiện có trong hệ thống l Tài nguyên đang chiếm giữ bởi tất cả các tiến trình Pj(j < i) Trong chuỗi an toàn, khi Pi yêu cầu tài nguyên l Nếu không thể đáp ứng ngay lập tức, Pi đợi cho tới khi Pj kết thúc (j < i) l Khi Pj kết thúc và giải phóng tài nguyên, Pi sẽ nhận được tài nguyên cần thiết, thực hiện, giải phóng các tài nguyên đã được cung cấp và kết thúc l Khi Pi kết thúc và giải phóng tài nguyên ⇒Pi+1 sẽ nhận được tài nguyên cần thiêt và kết thúc được . . . l Tất cả các tiến trình trong chuỗi an toàn đều kết thúc được"
ea73ad6304ed438f7e7d4c59ddd227a1:228,ea73ad6304ed438f7e7d4c59ddd227a1,228,231,,,805,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.5 Phòng tránh bế tắc Ví dụ minh họa Xem xét hệ thống gồm l 3 tiến trình P1, P2, P3 và 1 tài nguyên R có 12 đơn vị l (P1, P2, P3) có thể yêu cầu tối đa tới (10, 4, 9) đơn vị tài nguyên R l Tại thời điểm t0, (P1, P2, P3) đã được cấp (5, 2, 2) đơn vị tài nguyên R l Tại thời điểm hiện tại (t0) hệ thống có an toàn? l Hệ thống đã cấp (5 + 2 + 2) đơn vị, vậy còn lại 3 đơn vị l (P1, P2, P3) còn có thể yêu cầu (5, 2, 7) đơn vị l Với 3 đơn vị hiện có, mọi yêu cầu của P2 đều đáp ứng được ⇒P2 chắc chắn kết thúc được và sẽ giải phóng 2 đơn vị R l Với 3 + 2 đơn vị, P1 chắc chắn kết thúc,sẽ giải phóng 5 đơn vị l Với 3 + 2 + 5 đơn vị P3 chắc chắn kết thúc được l Ở thời điểm t0 P1, P2, P3 đều chắc chắn kết thúc ⇒hệ thống an toàn với dãy an toàn (P2, P1, P3)"
ea73ad6304ed438f7e7d4c59ddd227a1:229,ea73ad6304ed438f7e7d4c59ddd227a1,229,232,,,863,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.5 Phòng tránh bế tắc Ví dụ minh họa 2 Xem xét hệ thống gồm l 3 tiến trình P1, P2, P3 và 1 tài nguyên R có 12 đơn vị l Các tiến trình (P1, P2, P3) có thể yêu cầu tối đa tới (10, 4, 9) đơn vị tài nguyên R l Tại thời điểm t0, các tiến trình (P1, P2, P3) đã được cấp (5, 2, 2) đơn vị tài nguyên R l Tại thời điểm t1, tiến trình P3 yêu cầu và được cấp 1 đơn vị tài nguyên R. Hệ thống có an toàn? l Với 2 đơn vị hiện có, mọi yêu cầu của P2 đều đáp ứng được ⇒P2 chắc chắn kết thúc, giải phóng 2 đơn vị R l Khi P2 kết thúc số tài nguyên sẵn có trong hệ thống là 4 l Với 4 đơn vị tài nguyên, P1 và P3 đều có thể phải đợi khi xin thêm 5 đơn vị tài nguyên l Vậy hệ thống không an toàn với dãy (P1, P3) l Nhận xét: Tại thời điểm t1 nếu tiến trình P3 phải đợi khi yêu cầu thêm 1 đơn vị tài nguyên, bế tắc sẽ được loại trừ"
ea73ad6304ed438f7e7d4c59ddd227a1:230,ea73ad6304ed438f7e7d4c59ddd227a1,230,233,,,534,Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.5 Phòng tránh bế tắc Ví dụ minh họa l Nhận xét l Hệ thống an toàn ⇒Các tiến trình đều có thể kết thúc được ⇒không xảy ra bế tắc l Hệ thống không an toàn ⇒Có khả năng xảy ra bế tắc l Phương pháp l Không để hệ thống rơi vào tình trạng không an toàn l Kiểm tra mọi yêu cầu tài nguyên l Nếu hệ thống vẫn an toàn khi cung cấp ⇒Cung cấp l Nếu hệ thống không an toàn khi cung cấp ⇒Phải đợi l Thuật toán l Thuật toán dựa vào đồ thị cung cấp tài nguyên l Thuật toán người quản lý nhà băng
ea73ad6304ed438f7e7d4c59ddd227a1:231,ea73ad6304ed438f7e7d4c59ddd227a1,231,234,,,601,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.5 Phòng tránh bế tắc Thuật toán dựa vào đồ thị cung cấp tài nguyên l Sử dụng khi mỗi kiểu tài nguyên chỉ có 1 đơn vị l Có chu trình, sẽ có bế tắc l Thêm vào đồ thị loại cung mới: cung đòi hỏi Pi →Rj l Cùng hướng với cung yêu cầu, thể hiện trong đồ thị −− > l Cho biết Pi có thể yêu cầu Rj trong tương lai l Tiến trình khi tham gia hệ thống, phải thêm tất cả các cung đòi hỏi tương ứng vào đồ thị l Khi Pi yêu cầu Rj, cung đòi hỏi Pi →Rj chuyển thành cung yêu cầu Pi →Rj l Khi Pi giải phóng Rj, cung sử dụng Rj →Pi chuyển thành cung đòi hỏi Pi →Rj"
ea73ad6304ed438f7e7d4c59ddd227a1:232,ea73ad6304ed438f7e7d4c59ddd227a1,232,235,,,405,Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.5 Phòng tránh bế tắc Thuật toán dựa vào đồ thị cung cấp tài nguyên Thuật toán: Yêu cầu tài nguyên Rj của tiến trình Pi được thỏa mãn chỉ khi việc chuyển cung yêu cầu Pi →Rj thành cung sử dụng Rj →Pi không tạo chu trình trên đồ thị. l Không chu trình: Hệ thống an toàn l Có chu trình: Việc cung cấp tài nguyên đẩy hệ thống vào tình trạng không an toàn
ea73ad6304ed438f7e7d4c59ddd227a1:233,ea73ad6304ed438f7e7d4c59ddd227a1,233,236,,,308,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.5 Phòng tránh bế tắc Ví dụ Hệ thống: 2 tiến trình P1, P2 và 2 tài nguyên R1, R2, mỗi loại 1 đơn vị l P1 có thể xin R1, R2 trong tương lai l P2 có thể xin R1, R2 trong tương lai P1 P2 R2 R1 l P1 yêu cầu tài nguyên R1 l Cung đòi hỏi trở thành cung yêu cầu"
ea73ad6304ed438f7e7d4c59ddd227a1:234,ea73ad6304ed438f7e7d4c59ddd227a1,234,237,,,443,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.5 Phòng tránh bế tắc Ví dụ Hệ thống: 2 tiến trình P1, P2 và 2 tài nguyên R1, R2, mỗi loại 1 đơn vị l P1 có thể xin R1, R2 trong tương lai l P2 có thể xin R1, R2 trong tương lai P1 P2 R2 R1 l P1 yêu cầu tài nguyên R1 l Cung đòi hỏi trở thành cung yêu cầu l P2 yêu cầu tài nguyên R2 ⇒cung đòi hỏi trở thành cung yêu cầu P2 →R2 l Yêu cầu của P1 được đáp ứng l Cung yêu cầu thành cung sử dụng"
ea73ad6304ed438f7e7d4c59ddd227a1:235,ea73ad6304ed438f7e7d4c59ddd227a1,235,238,,,570,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.5 Phòng tránh bế tắc Ví dụ Hệ thống: 2 tiến trình P1, P2 và 2 tài nguyên R1, R2, mỗi loại 1 đơn vị l P1 có thể xin R1, R2 trong tương lai l P2 có thể xin R1, R2 trong tương lai P1 P2 R2 R1 l P1 yêu cầu tài nguyên R1 l Cung đòi hỏi trở thành cung yêu cầu l P2 yêu cầu tài nguyên R2 ⇒cung đòi hỏi trở thành cung yêu cầu P2 →R2 l Nếu đáp ứng ⇒Cung yêu cầu thành cung sử dụng ⇒Khi P1 yêu cầu R2 ⇒P1 phải đợi ⇒Khi P2 yêu cầu R1 ⇒P2 phải đợi l Yêu cầu của P1 được đáp ứng l Cung yêu cầu thành cung sử dụng Hệ thống bế tắc"
ea73ad6304ed438f7e7d4c59ddd227a1:236,ea73ad6304ed438f7e7d4c59ddd227a1,236,239,,,606,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.5 Phòng tránh bế tắc Ví dụ Hệ thống: 2 tiến trình P1, P2 và 2 tài nguyên R1, R2, mỗi loại 1 đơn vị l P1 có thể xin R1, R2 trong tương lai l P2 có thể xin R1, R2 trong tương lai P1 P2 R2 R1 l P1 yêu cầu tài nguyên R1 l Cung đòi hỏi trở thành cung yêu cầu l P2 yêu cầu tài nguyên R2 ⇒cung đòi hỏi trở thành cung yêu cầu P2 →R2 l Nếu đáp ứng ⇒Cung yêu cầu thành cung sử dụng ⇒Khi P1 yêu cầu R2 ⇒P1 phải đợi ⇒Khi P2 yêu cầu R1 ⇒P2 phải đợi l Yêu cầu của P1 được đáp ứng l Cung yêu cầu thành cung sử dụng Hệ thống bế tắc l Yêu cầu của P2 không được đáp ứng"
ea73ad6304ed438f7e7d4c59ddd227a1:237,ea73ad6304ed438f7e7d4c59ddd227a1,237,240,,,749,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.5 Phòng tránh bế tắc Thuật toán người quản lý nhà băng: Giới thiệu l Thích hợp cho các hệ thống gồm các kiểu tài nguyên có nhiều đơn vị l Một tiến trình mới xuất hiện trong hệ thống cần khai báo số đơn vị lớn nhất của mỗi kiểu tài nguyên sẽ sử dụng l Không được vượt quá tổng số tài nguyên của hệ thống l Khi một tiến trình yêu cầu tài nguyên, hệ thống kiểm tra liệu đáp ứng cho yêu cầu hệ thống có còn an toàn không l Nếu hệ thống vẫn an toàn ⇒Cung cấp tài nguyên cho yêu cầu l Nếu hệ thống không an toàn ⇒Tiến trình phải đợi l Thuật toán cần l Các cấu trúc dữ liệu biểu diễn trạng thái phân phối tài nguyên l Thuật toán kiểm tra tình trạng an toàn của hệ thông l Thuật toán yêu cầu tài nguyên"
ea73ad6304ed438f7e7d4c59ddd227a1:238,ea73ad6304ed438f7e7d4c59ddd227a1,238,241,,,659,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.5 Phòng tránh bế tắc Các cấu trúc dữ liệu I Hệ thống n số tiến trình trong hệ thống m số kiểu tài nguyên trong hệ thống Các cấu trúc dữ liệu Available Vector chiều dài m cho biết số đơn vị tài nguyên sẵn có trong hệ thống. (Available[3] = 8 ⇒?) Max Ma trận n ∗m cho biết số lượng lớn nhất mỗi kiểu tài nguyên của từng tiến trình. (Max[2,3] = 5 ⇒?) Allocation Ma trận n ∗m cho biết số lượng mỗi kiểu tài nguyên đã cấp cho tiến trình. (Allocation[2,3] = 2 ⇒?) Need Ma trận n ∗m chỉ ra số lượng mỗi kiểu tài nguyên còn cần đến của từng tiến trình. Need[2,3] = 3 ⇒?) Need[i][j] = Max[i][j] - Allocation[i][j]"
ea73ad6304ed438f7e7d4c59ddd227a1:239,ea73ad6304ed438f7e7d4c59ddd227a1,239,242,,,450,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.5 Phòng tránh bế tắc Các cấu trúc dữ liệu I Quy ước l X, Y là các vector độ dài n l X ≤ Y ⇔X[i] ≤ Y[i] ∀i = 1, 2, . . . , n l Các dòng của ma trận Max,Need,Allocation được xử lý như các vector l Thuật toán tính toán trên các vector l Các cấu trúc cục bộ Work vector độ dài m cho biết mỗi tài nguyên còn bao nhiêu Finish vector độ dài n, kiểu logic cho biết tiến trình có chắc chắn kết thúc không"
ea73ad6304ed438f7e7d4c59ddd227a1:240,ea73ad6304ed438f7e7d4c59ddd227a1,240,243,,,431,Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.5 Phòng tránh bế tắc Thuật toán kiểm tra An toàn BOOL Safe(Current Resource-Allocation State){ Work←Available for (i : 1 →n) Finish[i]←false flag←true While(flag){ flag←false for (i : 1 →n) if(Finish[i]=false AND Need[i] ≤Work){ Finish[i]←true Work ←Work+Allocation[i] flag←true }//endif }//endwhile for (i : 1 →n) if (Finish[i]=false)return false return true; }//End function
ea73ad6304ed438f7e7d4c59ddd227a1:241,ea73ad6304ed438f7e7d4c59ddd227a1,241,244,,,617,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.5 Phòng tránh bế tắc Ví dụ minh họa l Xét hệ thống gồm 5 tiến trình P0, P1, P2, P3, P4 và 3 tài nguyên R0, R1, R2 l Tài nguyên R0 có 10 đơn vị, R1 có 5 đơn vị, R2 có 7 đơn vị l Yêu cầu tài nguyên lớn nhất và lượng tài nguyên đã cấp của mỗi tiến trình R0 R1 R2 P0 7 5 3 P1 3 2 2 P2 9 0 2 P3 2 2 2 P4 4 3 3 Max R0 R1 R2 P0 0 1 0 P1 2 0 0 P2 3 0 2 P3 2 1 1 P4 0 0 2 Allocation l Hệ thống có an toàn? l Tiến trình P1 yêu cầu thêm 1 đơn vị R0 và 2 đơn vị R2? l Tiến trình P4 yêu cầu thêm 3 đơn vị R0 và 3 đơn vị R1? l Tiến trình P0 yêu cầu thêm 2 đơn vị R1. Cung cấp?"
ea73ad6304ed438f7e7d4c59ddd227a1:242,ea73ad6304ed438f7e7d4c59ddd227a1,242,245,,,430,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.5 Phòng tránh bế tắc Ví dụ minh họa : Kiểm tra tính an toàn l Số tài nguyên còn sẵn trong hệ thống Avaiable(R0, R1, R2) =(3, 3, 2) l Yêu cầu còn lại của mỗi tiến trình (Need = Max - Allocation) R0 R1 R2 P0 7 5 3 P1 3 2 2 P2 9 0 2 P3 2 2 2 P4 4 3 3 Max R0 R1 R2 P0 0 1 0 P1 2 0 0 P2 3 0 2 P3 2 1 1 P4 0 0 2 Allocation R0 R1 R2 P0 7 4 3 P1 1 2 2 P2 6 0 0 P3 0 1 1 P4 4 3 1 Need"
ea73ad6304ed438f7e7d4c59ddd227a1:243,ea73ad6304ed438f7e7d4c59ddd227a1,243,246,,,453,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.5 Phòng tránh bế tắc Ví dụ minh họa : Kiểm tra tính an toàn l Số tài nguyên còn sẵn trong hệ thống Avaiable(R0, R1, R2) =(3, 3, 2) R0 R1 R2 P0 7 5 3 P1 3 2 2 P2 9 0 2 P3 2 2 2 P4 4 3 3 Max R0 R1 R2 P0 0 1 0 P1 2 0 0 P2 3 0 2 P3 2 1 1 P4 0 0 2 Allocation R0 R1 R2 P0 7 4 3 P1 1 2 2 P2 6 0 0 P3 0 1 1 P4 4 3 1 Need Tiến trình P0 P1 P2 P3 P4 Finish F F F F F Work F F F T (5,3,2) (3,3,2) F T F (7,4,3)"
ea73ad6304ed438f7e7d4c59ddd227a1:244,ea73ad6304ed438f7e7d4c59ddd227a1,244,247,,,486,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.5 Phòng tránh bế tắc Ví dụ minh họa : Kiểm tra tính an toàn l Số tài nguyên còn sẵn trong hệ thống Avaiable(R0, R1, R2) =(3, 3, 2) R0 R1 R2 P0 7 5 3 P1 3 2 2 P2 9 0 2 P3 2 2 2 P4 4 3 3 Max R0 R1 R2 P0 0 1 0 P1 2 0 0 P2 3 0 2 P3 2 1 1 P4 0 0 2 Allocation R0 R1 R2 P0 7 4 3 P1 1 2 2 P2 6 0 0 P3 0 1 1 P4 4 3 1 Need Tiến trình P0 P1 P2 P3 P4 Finish F T F T T Work F F T (7,5,5) (7,4,5) T (10,5,7) Hệ thống an toàn (P1, P3, P4, P0, P2)"
ea73ad6304ed438f7e7d4c59ddd227a1:245,ea73ad6304ed438f7e7d4c59ddd227a1,245,248,,,848,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.5 Phòng tránh bế tắc Thuật toán yêu cầu tài nguyên l Request[i] Vector yêu cầu tài nguyên của tiến trình Pi l Request[3,2] = 2: Tiến trình P3 yêu cầu 2 đơn vị tài nguyên R2 l Khi Pi yêu cầu tài nguyên, hệ thống thực hiện ①if(Request[i]>Need[i]) Error(Yêu cầu vượt quá khai báo tài nguyên) ②if(Request[i]>Available) Block(Không đủ tài nguyên, tiến trình phải đợi) ③Thiết lập trạng thái phân phối tài nguyên mới cho hệ thống l Available = Available - Request[i] l Allocation[i] = Allocation[i] + Request[i] l Need[i] = Need[i] - Request[i] ④Phân phối tài nguyên dựa trên kết quả kiểm tra tính an toàn của trạng thái phân phối tài nguyên mới if(Safe(New Resource Allocation State)) Phân phối cho Pi theo yêu cầu else Tiến trình Pi phải đợi Khôi phục lại trạng thái cũ (Available, Allocation,Need)"
ea73ad6304ed438f7e7d4c59ddd227a1:246,ea73ad6304ed438f7e7d4c59ddd227a1,246,249,,,400,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.5 Phòng tránh bế tắc Ví dụ minh họa : P1 yêu cầu (1, 0, 2) l Request[1]≤Available ((1, 0, 2) ≤ (3, 3, 2)) ⇒Có thể cung cấp l Nếu cung cấp : Available = ( 2 , 3, 0) R0 R1 R2 P0 0 1 0 P1 3 0 2 P2 3 0 2 P3 2 1 1 P4 0 0 2 Allocation R0 R1 R2 P0 7 4 3 P1 1 2 2 P2 6 0 0 P3 0 1 1 P4 4 3 1 Need Tiến trình P0 P1 P2 P3 P4 Finish F F F F F Work (2,3,0) F"
ea73ad6304ed438f7e7d4c59ddd227a1:247,ea73ad6304ed438f7e7d4c59ddd227a1,247,250,,,400,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.5 Phòng tránh bế tắc Ví dụ minh họa : P1 yêu cầu (1, 0, 2) l Request[1]≤Available ((1, 0, 2) ≤ (3, 3, 2)) ⇒Có thể cung cấp l Nếu cung cấp : Available = ( 2 , 3, 0) R0 R1 R2 P0 0 1 0 P1 3 0 2 P2 3 0 2 P3 2 1 1 P4 0 0 2 Allocation R0 R1 R2 P0 7 4 3 P1 1 2 2 P2 6 0 0 P3 0 1 1 P4 4 3 1 Need Tiến trình P0 P1 P2 P3 P4 Finish F F F F F Work (2,3,0) F"
ea73ad6304ed438f7e7d4c59ddd227a1:248,ea73ad6304ed438f7e7d4c59ddd227a1,248,251,,,400,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.5 Phòng tránh bế tắc Ví dụ minh họa : P1 yêu cầu (1, 0, 2) l Request[1]≤Available ((1, 0, 2) ≤ (3, 3, 2)) ⇒Có thể cung cấp l Nếu cung cấp : Available = ( 2 , 3, 0) R0 R1 R2 P0 0 1 0 P1 3 0 2 P2 3 0 2 P3 2 1 1 P4 0 0 2 Allocation R0 R1 R2 P0 7 4 3 P1 1 2 2 P2 6 0 0 P3 0 1 1 P4 4 3 1 Need Tiến trình P0 P1 P2 P3 P4 Finish F T F F F Work (5,3,2) F"
ea73ad6304ed438f7e7d4c59ddd227a1:249,ea73ad6304ed438f7e7d4c59ddd227a1,249,252,,,400,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.5 Phòng tránh bế tắc Ví dụ minh họa : P1 yêu cầu (1, 0, 2) l Request[1]≤Available ((1, 0, 2) ≤ (3, 3, 2)) ⇒Có thể cung cấp l Nếu cung cấp : Available = ( 2 , 3, 0) R0 R1 R2 P0 0 1 0 P1 3 0 2 P2 3 0 2 P3 2 1 1 P4 0 0 2 Allocation R0 R1 R2 P0 7 4 3 P1 1 2 2 P2 6 0 0 P3 0 1 1 P4 4 3 1 Need Tiến trình P0 P1 P2 P3 P4 Finish F T F F F Work (5,3,2) F"
ea73ad6304ed438f7e7d4c59ddd227a1:250,ea73ad6304ed438f7e7d4c59ddd227a1,250,253,,,400,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.5 Phòng tránh bế tắc Ví dụ minh họa : P1 yêu cầu (1, 0, 2) l Request[1]≤Available ((1, 0, 2) ≤ (3, 3, 2)) ⇒Có thể cung cấp l Nếu cung cấp : Available = ( 2 , 3, 0) R0 R1 R2 P0 0 1 0 P1 3 0 2 P2 3 0 2 P3 2 1 1 P4 0 0 2 Allocation R0 R1 R2 P0 7 4 3 P1 1 2 2 P2 6 0 0 P3 0 1 1 P4 4 3 1 Need Tiến trình P0 P1 P2 P3 P4 Finish F T F T F Work (7,4,3) F"
ea73ad6304ed438f7e7d4c59ddd227a1:251,ea73ad6304ed438f7e7d4c59ddd227a1,251,254,,,400,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.5 Phòng tránh bế tắc Ví dụ minh họa : P1 yêu cầu (1, 0, 2) l Request[1]≤Available ((1, 0, 2) ≤ (3, 3, 2)) ⇒Có thể cung cấp l Nếu cung cấp : Available = ( 2 , 3, 0) R0 R1 R2 P0 0 1 0 P1 3 0 2 P2 3 0 2 P3 2 1 1 P4 0 0 2 Allocation R0 R1 R2 P0 7 4 3 P1 1 2 2 P2 6 0 0 P3 0 1 1 P4 4 3 1 Need Tiến trình P0 P1 P2 P3 P4 Finish F T F T T Work (7,4,5) F"
ea73ad6304ed438f7e7d4c59ddd227a1:252,ea73ad6304ed438f7e7d4c59ddd227a1,252,255,,,400,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.5 Phòng tránh bế tắc Ví dụ minh họa : P1 yêu cầu (1, 0, 2) l Request[1]≤Available ((1, 0, 2) ≤ (3, 3, 2)) ⇒Có thể cung cấp l Nếu cung cấp : Available = ( 2 , 3, 0) R0 R1 R2 P0 0 1 0 P1 3 0 2 P2 3 0 2 P3 2 1 1 P4 0 0 2 Allocation R0 R1 R2 P0 7 4 3 P1 1 2 2 P2 6 0 0 P3 0 1 1 P4 4 3 1 Need Tiến trình P0 P1 P2 P3 P4 Finish T T F T T Work (7,5,5) F"
ea73ad6304ed438f7e7d4c59ddd227a1:253,ea73ad6304ed438f7e7d4c59ddd227a1,253,256,,,422,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.5 Phòng tránh bế tắc Ví dụ minh họa : P1 yêu cầu (1, 0, 2) l Request[1]≤Available ((1, 0, 2) ≤ (3, 3, 2)) ⇒Có thể cung cấp l Nếu cung cấp : Available = ( 2 , 3, 0) R0 R1 R2 P0 0 1 0 P1 3 0 2 P2 3 0 2 P3 2 1 1 P4 0 0 2 Allocation R0 R1 R2 P0 7 4 3 P1 1 2 2 P2 6 0 0 P3 0 1 1 P4 4 3 1 Need Tiến trình P0 P1 P2 P3 P4 Finish T T T T T Work (10,5,7) Yêu cầu được chấp nhận"
ea73ad6304ed438f7e7d4c59ddd227a1:254,ea73ad6304ed438f7e7d4c59ddd227a1,254,257,,,574,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.5 Phòng tránh bế tắc Ví dụ minh họa : (tiếp tục) l Tiến trình P4 yêu cầu thêm 3 đơn vị R0 và 3 đơn vị R2 l Request[4] = (3, 0, 3) l Available = (2, 3, 0) ⇒Không đủ tài nguyên, P4 phải đợi l Tiến trình P0 yêu cầu thêm 2 đơn vị R1 l Request[0]≤Available ((0, 2, 0) ≤ (2, 3, 0)) ⇒Có thể cung cấp l Nếu cung cấp : Available = (2 , 1, 0) l Thực hiện thuật toán an toàn ⇒Tất cả các tiến trình đều có thể không kết thúc ⇒Nếu chấp nhận, hệ thống rơi vào trạng thái không an toàn ⇒Đủ tài nguyên nhưng không cung cấp. P0 phải đợi"
ea73ad6304ed438f7e7d4c59ddd227a1:255,ea73ad6304ed438f7e7d4c59ddd227a1,255,258,,,221,Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.6 Nhận biết và khắc phục l Khái niệm bế tắc l Điều kiện xảy ra bế tắc l Các phương pháp xử lý bế tắc l Phòng ngừa bế tắc l Phòng tránh bế tắc l Nhận biết và khắc phục
ea73ad6304ed438f7e7d4c59ddd227a1:256,ea73ad6304ed438f7e7d4c59ddd227a1,256,259,,,544,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.6 Nhận biết và khắc phục Giới thiệu l Nguyên tắc l Không áp dụng các biện pháp phòng ngừa hoặc phòng tránh, để cho bế tắc xảy ra l Định kỳ kiểm tra xem bế tắc có đang xảy ra không. Nếu có tìm cách khắc phục l Để thực hiện, hệ thống phải cung cấp l Thuật toán xác định hệ thống đang bế tắc không l Thuật toán chữa bế tắc l Nhận biết bế tắc l Thuật toán dựa trên đồ thị cung cấp tài nguyên l Thuật toán chỉ ra bế tắc tổng quát l Khắc phục bế tắc l Kết thúc tiến trình l Trưng dụng tài nguyên"
ea73ad6304ed438f7e7d4c59ddd227a1:257,ea73ad6304ed438f7e7d4c59ddd227a1,257,260,,,792,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.6 Nhận biết và khắc phục Thuận toán dựa trên đồ thị cung cấp tài nguyên l Áp dụng khi mỗi tài nguyên trong hệ thống có một đơn vị l Kiểm tra hệ thống có bế tắc bằng cách kiểm tra chu trình trên đồ thị l Nếu trên đồ thị có chu trình, hệ thống đang bế tắc l Định kỳ gọi tới các thuật toán kiểm tra chu trình trên đồ thị l Thuật toán đòi hỏi n2 thao tác (n: số đỉnh của đồ thị) l Sử dụng đồ thị chờ đợi - phiên bản thu gọn của đồ thị cung cấp tài nguyên l Chỉ có các đỉnh dạng tiến trình l Cung chờ đợi Pi →Pj: Tiến trình Pi đang đợi tiến trình Pj giải phóng tài nguyên Pi cần l Cung chờ đợi Pi →Pj tồn tại trên đồ thị đợi khi và chỉ khi trên đồ thị phân phối tài nguyên tương ứng tồn tại đồng thời cung yêu cầu Pi → R và cung sử dụng R →Pj"
ea73ad6304ed438f7e7d4c59ddd227a1:258,ea73ad6304ed438f7e7d4c59ddd227a1,258,261,,,161,Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.6 Nhận biết và khắc phục Đồ thị chờ đợi: Ví dụ P1 P3 R2 R3 R1 R4 R5 P5 P2 P4 P1 P3 P5 P2 P4 Đồ thị chờ đợi
ea73ad6304ed438f7e7d4c59ddd227a1:259,ea73ad6304ed438f7e7d4c59ddd227a1,259,262,,,680,Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.6 Nhận biết và khắc phục Thuật toán chỉ ra bế tắc tổng quát : Giới thiệu l Sử dụng cho các hệ thống có các kiểu tài nguyên gồm nhiều đơn vị l Thuật toán tương tự thuật toán người quản lý nhà băng l Các cấu trúc dữ liệu l Available Vector độ dài m: Tài nguyên sẵn có trong hệ thống l Allocation Ma trận n ∗m: Tài nguyên đã cấp cho tiến trình l Request Ma trận n ∗m Tài nguyên tiến trình yêu cầu l Các cấu trúc cục bộ l Work Vector độ dài m cho biết tài nguyên hiện đang có l Finish Vector độ dài n cho biết tiến trình có thể kết thúc không l Các qui ước l Quan hệ ≤ giữa các Vector l Xử lý các dòng ma trận n ∗m như các vector
ea73ad6304ed438f7e7d4c59ddd227a1:260,ea73ad6304ed438f7e7d4c59ddd227a1,260,263,,,586,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.6 Nhận biết và khắc phục Thuật toán chỉ ra bế tắc tổng quát BOOL Deadlock(Current Resource-Allocation State){ Work←Available for (i : 1 →n) if(Allocation[i]≠0) Finish[i]←false elseFinish[i]←true; flag←true While(flag){ flag←false for (i : 1 →n) if(Finish[i]=false AND Request[i] ≤Work){ Finish[i]←true Work ←Work+Allocation[i] flag←true }//endif }//endwhile for (i : 1 →n) if (Finish[i]=false)return true; return false; }//End function //Allocation= 0 không nằm trong chu trình đợi //Finish[i] = false, tiến trình Pi đang bị bế tắc"
ea73ad6304ed438f7e7d4c59ddd227a1:261,ea73ad6304ed438f7e7d4c59ddd227a1,261,264,,,435,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.6 Nhận biết và khắc phục Ví dụ minh họa l 5 tiến trình P0, P1, P2, P3, P4; 3 tài nguyên R0, R1, R2 l Tài nguyên R0 có 7 đơn vị, R1 có 2 đơn vị, R2 có 6 đơn vị l Trạng thái cung cấp tài nguyên tại thời điểm t0 R0 R1 R2 P0 0 0 0 P1 2 0 2 P2 0 0 0 P3 1 0 0 P4 6 0 2 Request R0 R1 R2 P0 0 1 0 P1 2 0 0 P2 3 0 3 P3 2 1 1 P4 0 0 2 Allocation l Tài nguyên hiện có (R0, R1, R2) =(0, 0, 0)"
ea73ad6304ed438f7e7d4c59ddd227a1:262,ea73ad6304ed438f7e7d4c59ddd227a1,262,265,,,324,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.6 Nhận biết và khắc phục Ví dụ minh họa R0 R1 R2 P0 0 0 0 P1 2 0 2 P2 0 0 0 P3 1 0 0 P4 6 0 2 Request R0 R1 R2 P0 0 1 0 P1 2 0 0 P2 3 0 3 P3 2 1 1 P4 0 0 2 Allocation l Tài nguyên hiện có (R0, R1, R2) =(0, 0, 0) Tiến trình P0 P1 P2 P3 P4 Finish F F F F F Work (0,0,0) F"
ea73ad6304ed438f7e7d4c59ddd227a1:263,ea73ad6304ed438f7e7d4c59ddd227a1,263,266,,,326,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.6 Nhận biết và khắc phục Ví dụ minh họa R0 R1 R2 P0 0 0 0 P1 2 0 2 P2 0 0 0 P3 1 0 0 P4 6 0 2 Request R0 R1 R2 P0 0 1 0 P1 2 0 0 P2 3 0 3 P3 2 1 1 P4 0 0 2 Allocation l Tài nguyên hiện có (R0, R1, R2) =(0, 0, 0) Tiến trình P0 P1 P2 P3 P4 Finish T F F F F Work (0,1,0) F F"
ea73ad6304ed438f7e7d4c59ddd227a1:264,ea73ad6304ed438f7e7d4c59ddd227a1,264,267,,,324,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.6 Nhận biết và khắc phục Ví dụ minh họa R0 R1 R2 P0 0 0 0 P1 2 0 2 P2 0 0 0 P3 1 0 0 P4 6 0 2 Request R0 R1 R2 P0 0 1 0 P1 2 0 0 P2 3 0 3 P3 2 1 1 P4 0 0 2 Allocation l Tài nguyên hiện có (R0, R1, R2) =(0, 0, 0) Tiến trình P0 P1 P2 P3 P4 Finish T F T F F Work (3,1,3) F"
ea73ad6304ed438f7e7d4c59ddd227a1:265,ea73ad6304ed438f7e7d4c59ddd227a1,265,268,,,324,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.6 Nhận biết và khắc phục Ví dụ minh họa R0 R1 R2 P0 0 0 0 P1 2 0 2 P2 0 0 0 P3 1 0 0 P4 6 0 2 Request R0 R1 R2 P0 0 1 0 P1 2 0 0 P2 3 0 3 P3 2 1 1 P4 0 0 2 Allocation l Tài nguyên hiện có (R0, R1, R2) =(0, 0, 0) Tiến trình P0 P1 P2 P3 P4 Finish T F T T F Work (5,2,4) F"
ea73ad6304ed438f7e7d4c59ddd227a1:266,ea73ad6304ed438f7e7d4c59ddd227a1,266,269,,,324,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.6 Nhận biết và khắc phục Ví dụ minh họa R0 R1 R2 P0 0 0 0 P1 2 0 2 P2 0 0 0 P3 1 0 0 P4 6 0 2 Request R0 R1 R2 P0 0 1 0 P1 2 0 0 P2 3 0 3 P3 2 1 1 P4 0 0 2 Allocation l Tài nguyên hiện có (R0, R1, R2) =(0, 0, 0) Tiến trình P0 P1 P2 P3 P4 Finish T F T T F Work (5,2,4) F"
ea73ad6304ed438f7e7d4c59ddd227a1:267,ea73ad6304ed438f7e7d4c59ddd227a1,267,270,,,324,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.6 Nhận biết và khắc phục Ví dụ minh họa R0 R1 R2 P0 0 0 0 P1 2 0 2 P2 0 0 0 P3 1 0 0 P4 6 0 2 Request R0 R1 R2 P0 0 1 0 P1 2 0 0 P2 3 0 3 P3 2 1 1 P4 0 0 2 Allocation l Tài nguyên hiện có (R0, R1, R2) =(0, 0, 0) Tiến trình P0 P1 P2 P3 P4 Finish T T T T F Work (7,2,4) F"
ea73ad6304ed438f7e7d4c59ddd227a1:268,ea73ad6304ed438f7e7d4c59ddd227a1,268,271,,,365,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.6 Nhận biết và khắc phục Ví dụ minh họa R0 R1 R2 P0 0 0 0 P1 2 0 2 P2 0 0 0 P3 1 0 0 P4 6 0 2 Request R0 R1 R2 P0 0 1 0 P1 2 0 0 P2 3 0 3 P3 2 1 1 P4 0 0 2 Allocation l Tài nguyên hiện có (R0, R1, R2) =(0, 0, 0) Tiến trình P0 P1 P2 P3 P4 Finish T T T T T Work (7,2,6) Hệ thống không bế tắc (P0, P2, P3, P1, P4)"
ea73ad6304ed438f7e7d4c59ddd227a1:269,ea73ad6304ed438f7e7d4c59ddd227a1,269,272,,,358,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.6 Nhận biết và khắc phục Ví dụ minh họa l tại thời điểm t1: P2 yêu cầu thêm 1 đơn vị tài nguyên R2 l Trạng thái cung cấp tài nguyên R0 R1 R2 P0 0 0 0 P1 2 0 2 P2 0 0 1 P3 1 0 0 P4 6 0 2 Request R0 R1 R2 P0 0 1 0 P1 2 0 0 P2 3 0 3 P3 2 1 1 P4 0 0 2 Allocation l Tài nguyên hiện có (R0, R1, R2) =(0, 0, 0)"
ea73ad6304ed438f7e7d4c59ddd227a1:270,ea73ad6304ed438f7e7d4c59ddd227a1,270,273,,,279,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.6 Nhận biết và khắc phục Ví dụ minh họa R0 R1 R2 P0 0 0 0 P1 2 0 2 P2 0 0 1 P3 1 0 0 P4 6 0 2 Request R0 R1 R2 P0 0 1 0 P1 2 0 0 P2 3 0 3 P3 2 1 1 P4 0 0 2 Allocation Tiến trình P0 P1 P2 P3 P4 Finish F F F F F Work (0,0,0) F"
ea73ad6304ed438f7e7d4c59ddd227a1:271,ea73ad6304ed438f7e7d4c59ddd227a1,271,274,,,285,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.6 Nhận biết và khắc phục Ví dụ minh họa R0 R1 R2 P0 0 0 0 P1 2 0 2 P2 0 0 1 P3 1 0 0 P4 6 0 2 Request R0 R1 R2 P0 0 1 0 P1 2 0 0 P2 3 0 3 P3 2 1 1 P4 0 0 2 Allocation Tiến trình P0 P1 P2 P3 P4 Finish T F F F F Work (0,1,0) F F F F"
ea73ad6304ed438f7e7d4c59ddd227a1:272,ea73ad6304ed438f7e7d4c59ddd227a1,272,275,,,386,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.6 Nhận biết và khắc phục Ví dụ minh họa R0 R1 R2 P0 0 0 0 P1 2 0 2 P2 0 0 1 P3 1 0 0 P4 6 0 2 Request R0 R1 R2 P0 0 1 0 P1 2 0 0 P2 3 0 3 P3 2 1 1 P4 0 0 2 Allocation Tiến trình P0 P1 P2 P3 P4 Finish T F F F F Work (0,1,0) F F F F P0 có thể kết thúc nhưng hệ thống đang bế tắc. Các tiến trình đang chờ đợi lẫn nhau (P1, P2, P3, P4)"
ea73ad6304ed438f7e7d4c59ddd227a1:273,ea73ad6304ed438f7e7d4c59ddd227a1,273,276,,,890,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.6 Nhận biết và khắc phục Khắc phục bế tắc: Phương pháp kết thúc tiến trình Nguyên tắc: Hủy bỏ các tiến trình đang trong tình trạng bế tắc và lấy lại tài nguyên đã cấp cho tiến trình bị hủy bỏ l Hủy bỏ tất cả các tiến trình l Nhanh chóng hủy bỏ bế tắc l Quá tốn kém l Các tiến trình bị hủy bỏ có thể gần kết thúc l Hủy bỏ lần lượt tiến trình cho tới khi bế tắc không xảy ra l Sau khi hủy bỏ, phải kiểm tra xem bế tắc còn tồn tại không l Thuật toán kiểm tra bế tắc có độ phức tạp m ∗n2 l Cần chỉ ra thứ tự tiến trình bị hủy bỏ để phá vỡ bế tắc l Độ ưu tiên của tiến trình. l Tiến trình đã tồn tại bao lâu, còn bao lâu nữa thì kết thúc l Tài nguyên tiến trình đang chiếm giữ, còn cần để kết thúc l . . . l Vấn đề hủy bỏ tiến trình l Tiến trình đang cập nhật file ⇒File không hoàn chỉnh l Tiến trình sử dụng máy in ⇒Reset trạng thái máy in"
ea73ad6304ed438f7e7d4c59ddd227a1:274,ea73ad6304ed438f7e7d4c59ddd227a1,274,277,,,725,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.6 Nhận biết và khắc phục Khắc phục bế tắc: Phương pháp trưng dụng tài nguyên Trưng dụng liên tục một vài tài nguyên từ một số tiến trình đang bế tắc cho các tiến trình khác đến khi bế tắc được hủy bỏ Các vấn đề cần quan tâm ①Lựa chọn nạn nhân (victim) l Tài nguyên nào và tiến trình nào được chọn? l Trật tự trưng dụng để chi phí nhỏ nhất l Lượng tài nguyên nắm giữ, thời gian sử dụng. . . ②Quay lui (Rollback) l Quay lui tới một trạng thái an toàn trước đó và bắt đầu lại l Yêu cầu lưu giữ thông tin trạng thái của t/trình đang thực hiện ③Đói tài nguyên (Starvation) l Một tiến trình bị trưng dụng quá nhiều lần ⇒chờ đợi vô hạn l Giải pháp: ghi lại số lần bị trưng dụng"
ea73ad6304ed438f7e7d4c59ddd227a1:275,ea73ad6304ed438f7e7d4c59ddd227a1,275,278,,,104,Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.6 Nhận biết và khắc phục Cách xử lý bế tắc khác ?
ea73ad6304ed438f7e7d4c59ddd227a1:276,ea73ad6304ed438f7e7d4c59ddd227a1,276,279,,,665,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc Tổng kết l Bế tắc là tình trạng 2 hay nhiều tiến trình cùng chờ đợi độc lập một sự kiện chỉ có thể xảy ra bởi sự hoạt động của các tiến trình đang đợi l Bế tắc xảy ra khi hội đủ 4 điều kiện l Tồn tại tài nguyên găng l Phải chờ đợi trước khi vào đoạn găng l Không tồn tại hệ thống phân phối lại tài nguyên l Tồn tại hiện tượng chờ đợi vòng tròn l Để xử lý bế tắc có 3 lớp thuật toán l Phòng ngừa bế tắc l Tác động vào các điều kiện xảy ra bế tắc l Dự báo và phòng tránh l Ngăn ngừa hệ thống rơi vào tình trạng có thể dẫn đến bế tắc l Nhận biết và khắc phục l Cho phép bế tắc xảy ra, chỉ ra bế tắc và khắc phục sau"
ea73ad6304ed438f7e7d4c59ddd227a1:277,ea73ad6304ed438f7e7d4c59ddd227a1,277,280,,,390,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.6 Nhận biết và khắc phục Ví dụ minh họa l 5 tiến trình P0, P1, P2, P3, P4; 3 tài nguyên R0, R1, R2 l Tài nguyên R0 có 6 đơn vị, R1 có 4 đơn vị, R2 có 7 đơn vị l Trạng thái cung cấp tài nguyên tại thời điểm t0 R0 R1 R2 P0 0 0 0 P1 2 1 2 P2 0 0 2 P3 1 0 0 P4 6 0 2 Request R0 R1 R2 P0 0 1 1 P1 1 0 0 P2 3 0 2 P3 2 1 1 P4 0 2 2 Allocation"
