{
  "1e8e6c622bfb571b0b783d8347182318": [
    {
      "question": "Trong chiến lược phân trang, PTBR (Page-table base register) có chức năng gì?",
      "answer": "PTBR (Page-table base register) là một thanh ghi trỏ tới bảng quản lý trang (PCB)[cite: 1]."
    },
    {
      "question": "Điều gì xảy ra khi giá trị của bit Mp (Memory present) bằng 0 trong quá trình truy nhập bộ nhớ?",
      "answer": "Khi Mp = 0, điều đó cho biết trang không có trong bộ nhớ, dẫn đến lỗi trang (page fault) và sinh ra một ngắt để hệ điều hành tiến hành nạp trang[cite: 2]."
    },
    {
      "question": "Bộ nhớ được phân cấp dựa trên tiêu chí nào?",
      "answer": "Bộ nhớ được phân cấp dựa trên tốc độ truy nhập[cite: 3], từ nhanh nhất là các thanh ghi (registers) đến chậm nhất là băng từ hoặc đĩa quang[cite: 3]."
    },
    {
      "question": "Cấu trúc nạp động (dynamic loading) hoạt động như thế nào?",
      "answer": "Trong cấu trúc nạp động, mỗi modul được biên tập riêng[cite: 15]. Khi thực thi, hệ thống sẽ định vị modul gốc, và chỉ khi cần đến modul nào thì hệ thống mới xin cấp phát bộ nhớ và nạp modul đó vào[cite: 15]."
    },
    {
      "question": "Bộ nhớ ảo là gì và nó hoạt động như thế nào?",
      "answer": "Bộ nhớ ảo là một kỹ thuật cho phép nạp từng phần của chương trình vào bộ nhớ, trong đó một số trang của tiến trình có thể nằm trên đĩa[cite: 5]. Khi một trang được yêu cầu, nó sẽ được đưa từ bộ nhớ thứ cấp vào bộ nhớ vật lý[cite: 5]."
    },
    {
      "question": "Trong chiến lược cấp phát bộ nhớ Buddy Allocation, nguyên tắc thu hồi vùng nhớ là gì?",
      "answer": "Khi một vùng nhớ được giải phóng, hệ thống có thể kết hợp hai vùng kề nhau có cùng kích thước và tiếp tục kết hợp liên tiếp cho tới khi tạo ra vùng trống lớn nhất có thể[cite: 6]."
    },
    {
      "question": "Kể tên các chiến lược quản lý bộ nhớ được đề cập.",
      "answer": "Các chiến lược quản lý bộ nhớ bao gồm: chiến lược phân chương cố định, chiến lược phân chương động, chiến lược phân đoạn, chiến lược phân trang, và chiến lược kết hợp phân đoạn-phân trang[cite: 7]."
    },
    {
      "question": "Trong chiến lược phân đoạn, làm thế nào để tính địa chỉ vật lý từ địa chỉ logic có dạng <đoạn, offset>?",
      "answer": "Để tính địa chỉ vật lý, hệ thống sẽ lấy địa chỉ bắt đầu của đoạn trong bộ nhớ và cộng với giá trị offset. Ví dụ, địa chỉ <3, 345> được tính bằng cách lấy địa chỉ bắt đầu của Đoạn 3 là 3200 cộng với offset 345 để ra địa chỉ 3545[cite: 10]."
    },
    {
      "question": "Nhược điểm của cấu trúc nạp động là gì?",
      "answer": "Nhược điểm của cấu trúc nạp động bao gồm tốc độ thực hiện chậm, yêu cầu người sử dụng phải nạp và xóa các modul, và giảm tính lưu động[cite: 13]."
    },
    {
      "question": "Việc xác định địa chỉ trong chương trình có thể được thực hiện ở những giai đoạn nào?",
      "answer": "Việc xác định địa chỉ có thể được thực hiện tại ba giai đoạn: giai đoạn dịch[cite: 16], thời điểm nạp[cite: 16], hoặc trong khi thực hiện[cite: 17]."
    }
  ],
  "2d1f518956cdc4b3cf6a9447714cfcd0": [
    {
      "question": "Lời gọi hệ thống `Read()` yêu cầu những gì để thực hiện thao tác đọc file?",
      "answer": "Lời gọi hệ thống `Read()` yêu cầu tên file và một vùng đệm để ghi kết quả đọc được vào[cite: 24]."
    },
    {
      "question": "Con trỏ đọc (read pointer) có vai trò gì?",
      "answer": "Hệ thống lưu một con trỏ đọc (read pointer) để chỉ ra vị trí được đọc, và con trỏ này sẽ thay đổi sau mỗi thao tác đọc dữ liệu[cite: 24]."
    },
    {
      "question": "Làm thế nào để thu gọn một file mà vẫn giữ nguyên các thuộc tính của nó?",
      "answer": "Để thu gọn file, hệ thống sẽ tìm kiếm file trong thư mục, đặt kích thước file về 0 và giải phóng vùng nhớ dành cho file[cite: 27]."
    },
    {
      "question": "Sector trên đĩa mềm được xác định như thế nào?",
      "answer": "Một sector trên đĩa mềm có thể được xác định qua tọa độ 3 chiều (Header, Track, Sector) hoặc qua số hiệu sector, là vị trí tương đối so với sector đầu tiên của đĩa[cite: 23]."
    },
    {
      "question": "Cấu trúc vật lý của một đĩa cứng bao gồm những thành phần chính nào?",
      "answer": "Một đĩa cứng gồm nhiều mặt đĩa; các rãnh có cùng bán kính trên các mặt đĩa tạo thành một cylinder; và mỗi mặt của mỗi cylinder lại được chia thành các sector[cite: 28]."
    },
    {
      "question": "Hệ thống sử dụng loại con trỏ nào cho cả thao tác đọc và ghi?",
      "answer": "Hệ thống sử dụng một con trỏ chung cho cả thao tác đọc và ghi, được gọi là con trỏ file[cite: 21]."
    },
    {
      "question": "Trong việc định vị thông tin trên đĩa mềm, tọa độ 3 chiều được chuyển đổi sang tọa độ 1 chiều như thế nào?",
      "answer": "Tọa độ 3 chiều (Header, Track, Sector) được chuyển đổi thành số hiệu sector, là vị trí tương đối so với sector đầu tiên[cite: 23]. Ví dụ, Sector <0, 0, 3> trở thành sector #2[cite: 23]."
    },
    {
      "question": "Thao tác thay đổi vị trí trong file (seek) có yêu cầu hoạt động vào/ra không?",
      "answer": "Không, thao tác thay đổi vị trí trong file không yêu cầu một hoạt động vào/ra mà chỉ thay đổi giá trị của con trỏ file cho thích hợp[cite: 26]."
    },
    {
      "question": "Con trỏ ghi (write pointer) được sử dụng để làm gì?",
      "answer": "Hệ thống sử dụng một con trỏ ghi (write pointer) để chỉ ra vị trí ghi dữ liệu vào file, và con trỏ này sẽ thay đổi sau mỗi thao tác ghi[cite: 29]."
    },
    {
      "question": "Sau khi nhận lời gọi `Read()`, hệ thống làm gì để tìm thấy dữ liệu của file?",
      "answer": "Hệ thống dùng tên file để tìm kiếm file trong thư mục file, sau đó dựa vào trường vị trí để tìm vị trí của file trên thiết bị lưu trữ[cite: 20]."
    }
  ],
  "74040f5628748874779838fa7a292b09": [
    {
      "question": "Phân biệt giữa tiến trình (process) và chương trình (program).",
      "answer": "Chương trình là một thực thể thụ động chứa các chỉ thị điều khiển máy tính, trong khi tiến trình là trạng thái động của một chương trình khi đang được thực thi[cite: 48]."
    },
    {
      "question": "Nhiệm vụ của hệ điều hành trong việc quản lý tiến trình là gì?",
      "answer": "Nhiệm vụ của hệ điều hành trong việc quản lý tiến trình bao gồm: tạo và hủy tiến trình, ngưng và thực hiện lại tiến trình, cung cấp cơ chế đồng bộ và giao tiếp giữa các tiến trình, và cung cấp cơ chế kiểm soát bế tắc[cite: 34]."
    },
    {
      "question": "Kể tên các loại hệ điều hành dựa trên cách chúng hoạt động.",
      "answer": "Các loại hệ điều hành bao gồm: hệ thống xử lý theo lô đơn chương trình, hệ thống xử lý theo lô đa chương trình, hệ thống phân chia thời gian, hệ thống song song, hệ thống phân tán, và hệ thống xử lý thời gian thực[cite: 44]."
    },
    {
      "question": "Hệ thống xử lý theo lô đa chương trình (multiprogrammed batch system) hoạt động như thế nào?",
      "answer": "Hệ thống này cho phép thực hiện nhiều chương trình đồng thời[cite: 51]. Khi một chương trình phải thực hiện thao tác vào ra, bộ xử lý (processor) sẽ được chuyển giao cho một chương trình khác đang ở trạng thái sẵn sàng, giúp hạn chế thời gian rỗi của processor[cite: 51]."
    },
    {
      "question": "Đặc điểm của hệ điều hành trên máy tính cá nhân trong giai đoạn đầu (thập niên 1980) là gì?",
      "answer": "Trong giai đoạn đầu (thập niên 1980), do tài nguyên phần cứng bị giới hạn, hệ điều hành trên máy tính cá nhân đã trở thành một thư viện các thủ tục cung cấp sẵn và chỉ cho phép chạy một chương trình tại một thời điểm (ví dụ như DOS)[cite: 39]."
    },
    {
      "question": "Hệ thống song song kiểu đa xử lý không đối xứng (ASMP) được mô tả như thế nào?",
      "answer": "Trong hệ thống đa xử lý không đối xứng (ASMP), có một bộ xử lý chính kiểm soát toàn bộ hệ thống, và các bộ xử lý khác thực hiện theo lệnh của bộ xử lý chính[cite: 43]. Mô hình này hoạt động theo dạng quan hệ chủ-tớ, trong đó bộ xử lý chính sẽ lập lịch cho các bộ xử lý khác[cite: 43]."
    },
    {
      "question": "Tại sao tính an toàn là một tính chất quan trọng của hệ điều hành?",
      "answer": "Tính an toàn rất quan trọng, đặc biệt với hệ điều hành đa nhiệm, để đảm bảo dữ liệu và chương trình được bảo vệ khỏi bị thay đổi ngoài ý muốn và để hạn chế các truy nhập bất hợp pháp[cite: 50]."
    },
    {
      "question": "Hệ thống phân tán (distributed system) đối mặt với những vấn đề gì?",
      "answer": "Các hệ thống phân tán phải đối mặt với các vấn đề như độ trễ truyền thông, băng thông, độ tin cậy, và các mối đe dọa từ virus[cite: 42]."
    },
    {
      "question": "Một tiến trình có thể bao gồm những gì?",
      "answer": "Một tiến trình bao gồm mã lệnh chương trình có thể thực thi, dữ liệu của chương trình, ngăn xếp, con trỏ ngăn xếp, các thanh ghi, và các thông tin khác cần thiết cho việc thực thi chương trình[cite: 48]."
    },
    {
      "question": "Trong hệ thống đa tiến trình phân chia thời gian, bảng tiến trình (process table) dùng để làm gì?",
      "answer": "Do hệ điều hành trong hệ thống đa tiến trình phân chia thời gian phải dừng một tiến trình để bắt đầu một tiến trình khác theo chu kỳ, nó cần một bảng tiến trình (process table) để lưu thông tin của các tiến trình đó[cite: 36]."
    }
  ],
  "a3aa8203ae0398a1ef263322bcadebc3": [
    {
      "question": "Hệ điều hành sử dụng hai phương pháp nào để biết khi nào một thiết bị vào/ra hoàn thành yêu cầu?",
      "answer": "Hệ điều hành sử dụng hai phương pháp: Ngắt (I/O interrupts), trong đó thiết bị ngoại vi sẽ phát ra tín hiệu ngắt để báo cho CPU[cite: 66], và Thăm dò (polling), trong đó hệ điều hành sẽ kiểm tra thanh ghi trạng thái của thiết bị theo chu kỳ[cite: 67]."
    },
    {
      "question": "Bộ điều khiển thiết bị (Device Controller) là gì?",
      "answer": "Đó là các mạch điện tử kết nối thiết bị ngoại vi với hệ thống máy tính[cite: 64], vì bộ xử lý (processor) không điều khiển trực tiếp các thiết bị này[cite: 64]."
    },
    {
      "question": "Ngắt (interrupt) là gì?",
      "answer": "Ngắt là hiện tượng dừng đột xuất một chương trình đang chạy để chuyển sang thực hiện một chương trình khác nhằm phản ứng với một sự kiện nào đó xảy ra[cite: 69]."
    },
    {
      "question": "Mục đích chính của việc điều phối truy nhập đĩa là gì?",
      "answer": "Mục đích chính của việc điều phối truy nhập đĩa là để cực tiểu hóa thời gian định vị[cite: 59], tức là thời gian tương ứng với khoảng cách dịch chuyển của đầu đọc/ghi[cite: 59]."
    },
    {
      "question": "Khi hệ thống phát hiện lỗi vào ra, nó sẽ cố gắng khắc phục bằng cách nào đầu tiên?",
      "answer": "Khi phát hiện lỗi, hệ thống sẽ cố gắng khắc phục bằng cách thực hiện lại thao tác nhiều lần[cite: 56]."
    },
    {
      "question": "Nguyên tắc hoạt động của thuật toán C-SCAN là gì?",
      "answer": "Trong thuật toán C-SCAN, đầu từ di chuyển từ cylinder ngoài cùng vào trong cùng, phục vụ các yêu cầu gặp trên đường đi[cite: 61]. Khi tới cylinder trong cùng, nó sẽ quay ngược lại cylinder ngoài cùng mà không phục vụ yêu cầu nào trên đường quay về, điều này giúp thu được thời gian đợi đồng nhất hơn[cite: 61]."
    },
    {
      "question": "Thuật toán LOOK khác với thuật toán SCAN như thế nào?",
      "answer": "Thuật toán LOOK là một phiên bản của SCAN/C-SCAN, trong đó đầu đọc không di chuyển tới các cylinder ngoài cùng hoặc trong cùng, mà chỉ di chuyển đến các yêu cầu xa nhất về hai phía rồi quay lại ngay[cite: 68]."
    },
    {
      "question": "CPU làm việc với các thanh ghi của bộ điều khiển thiết bị thông qua đâu?",
      "answer": "CPU sử dụng các không gian địa chỉ đặc biệt được gọi là các cổng vào/ra để làm việc với các thanh ghi riêng của mỗi bộ điều khiển thiết bị[cite: 63]."
    },
    {
      "question": "Hệ thống sẽ làm gì khi phát hiện một lỗi vào/ra?",
      "answer": "Khi phát hiện lỗi, hệ thống trước tiên sẽ cố gắng khắc phục bằng cách thực hiện lại thao tác nhiều lần[cite: 56]. Nếu lỗi vẫn tồn tại, hệ thống sẽ cố gắng khôi phục lại thông tin ban đầu hoặc thông báo lỗi[cite: 56, 57]."
    },
    {
      "question": "Theo quan điểm lập trình, một thiết bị vào/ra được xem như là gì?",
      "answer": "Theo quan điểm lập trình, một thiết bị vào/ra được xem như một giao diện phần mềm để nhận lệnh, thực hiện và trả kết quả về[cite: 62]."
    }
  ],
  "ea73ad6304ed438f7e7d4c59ddd227a1": [
    {
      "question": "Bốn điều kiện cần thiết để xảy ra bế tắc (deadlock) là gì?",
      "answer": "Bốn điều kiện cần để xảy ra bế tắc bao gồm: 1) Tồn tại tài nguyên găng được sử dụng theo mô hình không phân chia được[cite: 85], 2) Một tiến trình chiếm giữ các tài nguyên đã được cung cấp trong khi chờ đợi[cite: 86], 3) Tài nguyên không thể được trưng dụng[cite: 87], và 4) Tồn tại một chu trình chờ đợi vòng tròn[cite: 88]."
    },
    {
      "question": "Nhược điểm chính của mô hình luồng ở mức người dùng (User-Level Threads) là gì?",
      "answer": "Nhược điểm chính của mô hình luồng ở mức người dùng là khi một luồng rơi vào trạng thái chờ đợi, tất cả các luồng khác trong cùng một tiến trình cũng bị chờ đợi theo, dẫn đến không tận dụng được ưu điểm của mô hình lập trình đa luồng[cite: 92]."
    },
    {
      "question": "Kể tên ba phương pháp chính để xử lý bế tắc.",
      "answer": "Ba phương pháp chính để xử lý bế tắc là: Phòng ngừa[cite: 77], Phòng tránh[cite: 77], và Nhận biết và Khắc phục[cite: 78]."
    },
    {
      "question": "Thuật toán Người quản lý nhà băng (Banker's Algorithm) hoạt động dựa trên nguyên tắc nào để phòng tránh bế tắc?",
      "answer": "Khi một tiến trình yêu cầu tài nguyên, thuật toán Người quản lý nhà băng sẽ kiểm tra xem việc đáp ứng yêu cầu đó có giữ cho hệ thống ở trạng thái an toàn hay không[cite: 75]. Nếu hệ thống vẫn an toàn, tài nguyên sẽ được cung cấp; ngược lại, tiến trình phải đợi[cite: 75]."
    },
    {
      "question": "Điều phối CPU không trưng dụng (non-preemptive) xảy ra trong những trường hợp nào?",
      "answer": "Điều phối CPU không trưng dụng (non-preemptive) xảy ra khi một tiến trình chuyển từ trạng thái thực hiện sang trạng thái chờ đợi hoặc khi tiến trình đó kết thúc[cite: 81]."
    },
    {
      "question": "Trong đồ thị cung cấp tài nguyên, điều gì cho thấy hệ thống đã rơi vào trạng thái bế tắc?",
      "answer": "Sự xuất hiện của một chu trình trên đồ thị cung cấp tài nguyên cho thấy rằng hệ thống đang bị bế tắc[cite: 94]."
    },
    {
      "question": "Kỹ thuật SPOOLing giúp phòng ngừa bế tắc cho các tài nguyên như máy in bằng cách nào?",
      "answer": "Kỹ thuật SPOOLing giúp phòng ngừa bế tắc bằng cách đảm bảo chỉ có một tiến trình chuyên dụng, ví dụ như printer daemon, mới làm việc trực tiếp với máy in, qua đó bế tắc cho tài nguyên máy in bị hủy bỏ[cite: 82]."
    },
    {
      "question": "Tại sao các phép xử lý P(S) và V(S) trên đèn báo (semaphore) phải là các phép toán không phân chia được (atomic)?",
      "answer": "Các phép xử lý P(S) và V(S) trên đèn báo phải là các phép toán không phân chia được, vì bản thân chúng cũng là các tài nguyên găng và cần được điều độ để tránh xung đột[cite: 72]."
    },
    {
      "question": "Khi sử dụng thuật toán dựa vào đồ thị cung cấp tài nguyên để phòng tránh bế tắc, cung đòi hỏi (claim edge) thể hiện điều gì?",
      "answer": "Cung đòi hỏi (claim edge), được biểu diễn bằng Pi →Rj, cho biết rằng tiến trình Pi có thể yêu cầu tài nguyên Rj trong tương lai[cite: 83]."
    },
    {
      "question": "Trong phương pháp khóa trong (lock-in), một tiến trình làm gì để vào đoạn găng?",
      "answer": "Một tiến trình muốn vào đoạn găng sẽ kiểm tra một byte khóa chung[cite: 89]. Nếu khóa đang mở, tiến trình sẽ đóng khóa lại và được quyền vào; nếu khóa đang đóng, tiến trình sẽ phải đợi[cite: 89]."
    }
  ]
}