chunk_id,document_id,order_index,page,end_page,section,text_len,text
1e8e6c622bfb571b0b783d8347182318:0,1e8e6c622bfb571b0b783d8347182318,0,1,,,143,Hệ Điều Hành (Nguyên lý các hệ điều hành) Đỗ Quốc Huy huydq@soict.hust.edu.vn Bộ môn Khoa Học Máy Tính Viện Công Nghệ Thông Tin và Truyền Thông
1e8e6c622bfb571b0b783d8347182318:1,1e8e6c622bfb571b0b783d8347182318,1,2,,,855,l Mục đích của hệ thống máy tính: thực hiện chương trình l Chương trình và dữ liệu (toàn bộ hoặc một phần) phải nằm trong bộ nhớ chính trong khi thực hiện l Byte tích cực:Những byte nội dung đang được thực hiện tại thời điểm quan sát l Phần chương trình chưa đưa vào bộ nhớ chính được lưu trên bộ nhớ thứ cấp (VD: đĩa cứng)⇒ Bộ nhớ ảo l Cho phép lập trình viên không lo lắng về giới hạn bộ nhớ vật lý l Để s/d CPU hiệu quả và tăng tốc độ đáp ứng của hệ thống: l Cần luân chuyển CPU thường xuyên giữa các tiến trình Điều phối CPU (Phần 3- Chương 2) l Cần nhiều tiến trình sẵn sàng trong bộ nhớ l Hệ số song song của hệ thống: Số tiến trình đồng thời tồn tại trong hệ thống l Tồn tại nhiều chiến lược quản lý bộ nhớ khác nhau l Nhiều chiến lược đòi hỏi trợ giúp từ phần cứng l Thiết kế phần cứng có thể được tích hợp chặt chẽ với HDH Chương 3 Quản lý bộ nhớ
1e8e6c622bfb571b0b783d8347182318:2,1e8e6c622bfb571b0b783d8347182318,2,3,,,111,①Tổng quan ②Các chiến lược quản lý bộ nhớ ③Bộ nhớ ảo ④Quản lý bộ nhớ trong VXL họ Intel Chương 3 Quản lý bộ nhớ
1e8e6c622bfb571b0b783d8347182318:3,1e8e6c622bfb571b0b783d8347182318,3,4,,,112,lVí dụ lBộ nhớ và chương trình lLiên kết địa chỉ lCác cấu trúc chương trình Chương 3 Quản lý bộ nhớ 1. Tổng quan
1e8e6c622bfb571b0b783d8347182318:4,1e8e6c622bfb571b0b783d8347182318,4,5,,,74,Chương 3: Quản lý bộ nhớ 1. Tổng quan 1.1 Ví dụ Quá trình biên dịch file C
1e8e6c622bfb571b0b783d8347182318:5,1e8e6c622bfb571b0b783d8347182318,5,6,,,74,Chương 3: Quản lý bộ nhớ 1. Tổng quan 1.1 Ví dụ Quá trình biên dịch file C
1e8e6c622bfb571b0b783d8347182318:6,1e8e6c622bfb571b0b783d8347182318,6,7,,,74,Chương 3: Quản lý bộ nhớ 1. Tổng quan 1.1 Ví dụ Quá trình biên dịch file C
1e8e6c622bfb571b0b783d8347182318:7,1e8e6c622bfb571b0b783d8347182318,7,8,,,74,Chương 3: Quản lý bộ nhớ 1. Tổng quan 1.1 Ví dụ Quá trình biên dịch file C
1e8e6c622bfb571b0b783d8347182318:8,1e8e6c622bfb571b0b783d8347182318,8,9,,,74,Chương 3: Quản lý bộ nhớ 1. Tổng quan 1.1 Ví dụ Quá trình biên dịch file C
1e8e6c622bfb571b0b783d8347182318:9,1e8e6c622bfb571b0b783d8347182318,9,10,,,355,"Toto project file main.c #include <stdio.h> extern int x, y; extern void toto(); int main(int argc, char *argv[]){ toto(); printf(""KQ: %d \n"",x * y); return 0; } file M1.c int y = 10; file M2.c int x; extern int y; void toto(){ x = 10 * y; } Kết quả KQ: 1000 Chương 3: Quản lý bộ nhớ 1. Tổng quan 1.1 Ví dụ Ví dụ : Tạo chương trình thực thi từ nhiều modul"
1e8e6c622bfb571b0b783d8347182318:10,1e8e6c622bfb571b0b783d8347182318,10,11,,,369,"extern int x,y; extern void toto(); int main(){ toto() printf() } main.c int y=10; M1.c int x; extern int y; toto() M2.c Compiler (tcc -c) x y toto printf main.o [y←10] M1.o [x] y [toto] M2.o Thư viện [printf] Link (tlink) Header [y←10] [x] [printf] - - [toto] xy toto printf x y Chương 3: Quản lý bộ nhớ 1. Tổng quan 1.1 Ví dụ Quá trình biên dịch toto project toto.exe"
1e8e6c622bfb571b0b783d8347182318:11,1e8e6c622bfb571b0b783d8347182318,11,12,,,112,lVí dụ lBộ nhớ và chương trình lLiên kết địa chỉ lCác cấu trúc chương trình Chương 3 Quản lý bộ nhớ 1. Tổng quan
1e8e6c622bfb571b0b783d8347182318:12,1e8e6c622bfb571b0b783d8347182318,12,13,,,594,"l Bộ nhớ là tài nguyên quan trọng của hệ thống l Chương trình phải nằm trong bộ nhớ trong để thực hiện l Bộ nhớ được đặc trưng bởi kích thước và tốc độ truy nhập l Bộ nhớ được phân cấp theo tốc độ truy nhập Loại bộ nhớ Kích thước Tốc độ Thanh ghi (Registers) Cache trên VXL Cache mức 2 Bộ nhớ chính Bộ nhớ lưu trữ (Disk) Băng từ, đĩa quang bytes Kilo Bytes KiloByte-MegaByte MegaByte-GigaByte GigaByte-Terabytes Không giới hạn Tốc độ CPU(ηs) 10 nano seconds 100 nanoseconds e Micro-seconds Mili-Seconds 10 Seconds Chương 3: Quản lý bộ nhớ 1. Tổng quan 1.2 Bộ nhớ và chương trình Phân cấp bộ nhớ"
1e8e6c622bfb571b0b783d8347182318:13,1e8e6c622bfb571b0b783d8347182318,13,14,,,262,"00000 00001 FFFFE FFFFF Memory l Dùng lưu trữ dữ liệu và chương trình l Là mảng các ô nhớ kiểu bytes, words l Mỗi ô nhớ có một địa chỉ riêng l Địa chỉ vật lý: địa chỉ x/hiện ở chân VXL Chương 3: Quản lý bộ nhớ 1. Tổng quan 1.2 Bộ nhớ và chương trình Bộ nhớ chính"
1e8e6c622bfb571b0b783d8347182318:14,1e8e6c622bfb571b0b783d8347182318,14,15,,,483,"l Tồn tại trên thiết bị lưu trữ ngoài l Là các file nhị phân thực thi được l Vùng tham số file l Lệnh máy (mã nhị phân), l Vùng dữ liệu (biến toàn cục), . . l Phải được đưa vào bộ nhớ trong và được đặt trong một tiến trình để thực hiện (tiến trình thực hiện chương trình) l Hàng đợi vào (input queue) l Tập các tiến trình ở bộ nhớ ngoài (thông thường: disk) l Đợi để được đưa vào bộ nhớ trong và thực hiên Chương 3: Quản lý bộ nhớ 1. Tổng quan 1.2 Bộ nhớ và chương trình Chương trình"
1e8e6c622bfb571b0b783d8347182318:15,1e8e6c622bfb571b0b783d8347182318,15,16,,,870,"l Nạp chương trình vào bộ nhớ l Đọc và phân tích (dịch) file thực thi (VD file *.com, file *.exe) l Xin vùng nhớ để nạp chương trình từ file trên đĩa l Thiết lập các tham số, các thanh ghi tới giá trị thích hợp l Thực thi chương trình l CPU lấy các lệnh trong bộ nhớ tại vị trí được xác định bởi bộ đếm chương trình (Program counter) l Cặp thanh ghi CS:IP với VXL họ Intel (Ví dụ : 80x86) l CPU giải mã lệnh l Có thể lấy thêm toán hạng từ bộ nhớ l Thực hiện lệnh với toán hạng l Nếu cần thiết, lưu kết quả vào bộ nhớ tại một địa chỉ xác định l Thực hiện xong l Giải phóng vùng không gian nhớ dành cho chương trình l Vấn đề l Chương trình có thể được nạp vào vị trí bất kỳ trong bộ nhớ l Khi thực hiện chương trình sinh ra chuỗi địa chỉ bộ nhớ l Truy nhập địa chỉ bộ nhớ như thế nào? Chương 3: Quản lý bộ nhớ 1. Tổng quan 1.2 Bộ nhớ và chương trình Thực hiện chương trình"
1e8e6c622bfb571b0b783d8347182318:16,1e8e6c622bfb571b0b783d8347182318,16,17,,,112,lVí dụ lBộ nhớ và chương trình lLiên kết địa chỉ lCác cấu trúc chương trình Chương 3 Quản lý bộ nhớ 1. Tổng quan
1e8e6c622bfb571b0b783d8347182318:17,1e8e6c622bfb571b0b783d8347182318,17,18,,,299,Bộ nhớ trong Chương trình nguồn Dịch Nạp Chương trình trong bộ nhớ Các modul đối tượng khác Thư viện hệ thống Thư viện hệ thống được nạp động 20/ 96 Liên kết Modul đối tượng Modul thực hiện Liên kết động Chương 3: Quản lý bộ nhớ 1. Tổng quan 1.3 Liên kết địa chỉ Các bước xử lý chương trình ứng dụng
1e8e6c622bfb571b0b783d8347182318:18,1e8e6c622bfb571b0b783d8347182318,18,19,,,774,"l Địa chỉ biểu tượng (symbolic) l Là tên của đối tượng trong chương trình nguồn l Ví dụ: counter, x, y,... l Địa chỉ tương đối l Sinh ra từ địa chỉ biểu tượng trong giai đoạn dịch (compiler) l Là vị trí tương đối của đối tượng kể từ đầu modul l Byte thứ 10 kể từ đầu modul l EB08 ⇒ JMP +08: Nhảy tới vị trí cách vị trí hiện tại 8 ô l Địa chỉ tuyệt đối l Sinh ra từ địa chỉ tương đối trong giai đoạn nạp chương trình thực thi vào bộ nhớ để thực hiện l Với PC: địa chỉ tương đối <Seg :Ofs>→ Seg * 16+Ofs l Là địa chỉ của đối tượng trong bộ nhớ vật lý-địa chỉ vật lý l Ví dụ: JMP 010A⇒ Nhảy tới ô nhớ có vị trí 010Ah tại cùng đoạn mã lệnh (CS) l Nếu CS=1555h, sẽ đi tới vị trí: 1555h*10h+010Ah =1560Ah Chương 3: Quản lý bộ nhớ 1. Tổng quan 1.3 Liên kết địa chỉ Các kiểu địa chỉ"
1e8e6c622bfb571b0b783d8347182318:19,1e8e6c622bfb571b0b783d8347182318,19,20,,,804,Xác định địa chỉ câu lệnh và dữ liệu trong bộ nhớ có thể thực hiện tại các giai đoạn khác nhau khi xử lý chương trình ứng dụng l Giai đoạn dịch: l Sử dụng khi biết chương trình sẽ nằm ở đâu trong bộ nhớ l Khi dịch sẽ sinh ra mã (địa chỉ) tuyệt đối l Phải dịch lại khi vị trí bắt đầu thay đổi l Thời điểm nạp: l Sử dụng khi không biết c/trình sẽ nằm ở đâu trong bộ nhớ l Các đối tượng được dịch ra sẽ mang địa chỉ tương đối l Xác định địa chỉ được hoãn lại tới khi khi nạp chương trình vào bộ nhớ l Trong khi thực hiện: l S/dụng khi các tiến trình có thể thay đổi vị trí trong khi t/hiện l Xác định địa chỉ được hoãn lại tới khi thực thi chương trình l Thường đòi hỏi trợ giúp từ phần cứng l Được sử dụng trong nhiều hệ điều hành Chương 3: Quản lý bộ nhớ 1. Tổng quan 1.3 Liên kết địa chỉ Xác định địa chỉ
1e8e6c622bfb571b0b783d8347182318:20,1e8e6c622bfb571b0b783d8347182318,20,21,,,423,"l Địa chỉ logic (địa chỉ ảo) l Được sinh ra trong tiến trình, (CPU đưa ra) l Được khối quản lý bộ nhớ (MMU) chuyển sang địa chỉ vật lý khi truy nhập tới đối tượng trong chương trình l Địa chỉ vật lý l Địa chỉ của một phần tử (byte/word) của bộ nhớ l Tương ứng với địa chỉ logic được CPU đưa ra l Chương trình làm việc với địa chỉ logic Chương 3: Quản lý bộ nhớ 1. Tổng quan 1.3 Liên kết địa chỉ Địa chỉ vật lý-địa chỉ logic"
1e8e6c622bfb571b0b783d8347182318:21,1e8e6c622bfb571b0b783d8347182318,21,22,,,142,lVí dụ lBộ nhớ và chương trình lLiên kết địa chỉ lCác cấu trúc chương trình Chương 3 Quản lý bộ nhớ 1. Tổng quan 1.4 Các cấu trúc chương trình
1e8e6c622bfb571b0b783d8347182318:22,1e8e6c622bfb571b0b783d8347182318,22,23,,,162,25/ 96 ① Cấu trúc tuyến tính ② Cấu trúc nạp động ③ Cấu trúc liên kết động ④ Cấu trúc Overlays Chương 3: Quản lý bộ nhớ 1. Tổng quan 1. 4 Các cấu trúc chương trình
1e8e6c622bfb571b0b783d8347182318:23,1e8e6c622bfb571b0b783d8347182318,23,24,,,352,"M0 M1 M2 M3 Biên tập M0 M1 M2 M3 l Sau khi biên tập, các modul được tập hợp thành một chương trình hoàn thiện l Chứa đầy đủ các thông tin để có thể thực hiện được l Các biến trỏ ngoài đã thay bằng giá trị cụ thể l Để thực hiện, chỉ cần định vị một lần trong bộ nhớ Chương 3: Quản lý bộ nhớ 1. Tổng quan 1.4 Các cấu trúc chương trình Cấu trúc tuyến tính"
1e8e6c622bfb571b0b783d8347182318:24,1e8e6c622bfb571b0b783d8347182318,24,25,,,397,"27/ 96 l Ưu điểm l Đơn giản, dễ tổ chức biên tập và định vị chương trình l Thời gian thực hiện nhanh l Tính lưu động cao l Nhược điểm l Lãng phí bộ nhớ l Không phải toàn bộ chương trình đều cần thiết cho thực hiện chương trình l Không thực hiện được chương trình có kích thước lớn hơn kích thước bộ nhớ vật lý Chương 3: Quản lý bộ nhớ 1. Tổng quan 1.4 Các cấu trúc chương trình Cấu trúc tuyến tính"
1e8e6c622bfb571b0b783d8347182318:25,1e8e6c622bfb571b0b783d8347182318,25,26,,,142,M0 M1 M2 M3 Hệ điều hành l Mỗi modul được biên tập riêng Chương 3: Quản lý bộ nhớ 1. Tổng quan 1.4 Các cấu trúc chương trình Cấu trúc nạp động
1e8e6c622bfb571b0b783d8347182318:26,1e8e6c622bfb571b0b783d8347182318,26,27,,,192,"M0 M1 M2 M3 Hệ điều hành M0 l Mỗi modul được biên tập riêng l Khi thực hiện, hệ thống sẽ định vị modul gốc Chương 3: Quản lý bộ nhớ 1. Tổng quan 1.4 Các cấu trúc chương trình Cấu trúc nạp động"
1e8e6c622bfb571b0b783d8347182318:27,1e8e6c622bfb571b0b783d8347182318,27,28,,,251,"M0 M1 M2 M3 Hệ điều hành M0 M1 l Mỗi modul được biên tập riêng l Khi thực hiện, hệ thống sẽ định vị modul gốc l Cần tới modul nào sẽ xin bộ nhớ và giải nạp modul vào Chương 3: Quản lý bộ nhớ 1. Tổng quan 1.4 Các cấu trúc chương trình Cấu trúc nạp động"
1e8e6c622bfb571b0b783d8347182318:28,1e8e6c622bfb571b0b783d8347182318,28,29,,,254,"M0 M1 M2 M3 Hệ điều hành M0 M1 M2 l Mỗi modul được biên tập riêng l Khi thực hiện, hệ thống sẽ định vị modul gốc l Cần tới modul nào sẽ xin bộ nhớ và giải nạp modul vào Chương 3: Quản lý bộ nhớ 1. Tổng quan 1.4 Các cấu trúc chương trình Cấu trúc nạp động"
1e8e6c622bfb571b0b783d8347182318:29,1e8e6c622bfb571b0b783d8347182318,29,30,,,352,"M0 M1 M2 M3 Hệ điều hành M0 M1 M2 l Mỗi modul được biên tập riêng l Khi thực hiện, hệ thống sẽ định vị modul gốc l Cần tới modul nào sẽ xin bộ nhớ và giải nạp modul vào l Khi sử dụng xong một modul, hoặc khi thiếu vùng nhớ sẽ đưa nhưng modul không cần thiết ra ngoài Chương 3: Quản lý bộ nhớ 1. Tổng quan 1.4 Các cấu trúc chương trình Cấu trúc nạp động"
1e8e6c622bfb571b0b783d8347182318:30,1e8e6c622bfb571b0b783d8347182318,30,31,,,349,"M0 M1 M2 M3 Hệ điều hành M0 M3 l Mỗi modul được biên tập riêng l Khi thực hiện, hệ thống sẽ định vị modul gốc l Cần tới modul nào sẽ xin bộ nhớ và giải nạp modul vào l Khi sử dụng xong một modul, hoặc khi thiếu vùng nhớ sẽ đưa nhưng modul không cần thiết ra ngoài Chương 3: Quản lý bộ nhớ 1. Tổng quan 1.4 Các cấu trúc chương trình Cấu trúc nạp động"
1e8e6c622bfb571b0b783d8347182318:31,1e8e6c622bfb571b0b783d8347182318,31,32,,,414,Ưu điểm l Có thể sử dụng vùng nhớ nhiều hơn phần dành cho chương trình l Hiệu quả sử dụng bộ nhớ cao nếu quản lý tốt Nhược điểm l Tốc độ thực hiện chậm l Sai lầm sẽ dẫn tới lãng phí bộ nhớ và tăng thời gian thực hiện l Yêu cầu người sử dụng phải nạp và xóa các modul l Người dùng phải nắm rõ hệ thống l Giảm tính lưu động 29/ 96 Chương 3: Quản lý bộ nhớ 1. Tổng quan 1.4 Các cấu trúc chương trình Cấu trúc nạp động
1e8e6c622bfb571b0b783d8347182318:32,1e8e6c622bfb571b0b783d8347182318,32,33,,,431,"M toto() toto() M toto l Các liên kết sẽ hoãn lại cho tới khi thực hiện chương trình l Một phần của đoạn mã (stub) được sử dụng để tìm kiếm thủ tục tương ứng trong thư viện trong bộ nhớ l Khi tìm thấy, stub sẽ được thay thế với địa chỉ của thủ tục và thực hiện thủ tục l Hữu ích cho xây dựng thư viện Hệ điều hành Chương 3: Quản lý bộ nhớ 1. Tổng quan 1.4 Các cấu trúc chương trình Cấu trúc liên kết động (DLL:Dynamic-link library)"
1e8e6c622bfb571b0b783d8347182318:33,1e8e6c622bfb571b0b783d8347182318,33,34,,,782,"l Modul được chia thành các mức l Mức 0 chứa modul gốc, nạp và định vị chương trình l Mức 1 chứa các Modul được gọi từ những modul ở mức 0 và không đồng thời tồn tại l . . . l Bộ nhớ cũng được chia thành mức ứng với mức chương trình l Kích thước bằng kích thước của modul lớn nhất cùng mức l Để có cấu trúc Overlay, cần cung cấp thêm các thông tin l Chương trình bao nhiêu mức, mỗi mức gồm những modul nào l Thông tin cung cấp lưu trong file (sơ đồ overlay) l Modul mức 0 được biên tập thành file thực thi riêng l Khi thực hiện chương trình l Nạp modul mức 0 như chương trình tuyến tính l Cần tới modul khác, sẽ nạp modul vào mức bộ nhớ tương ứng l Nếu có modul đồng mức tồn tại, đưa ra bên ngoài Chương 3: Quản lý bộ nhớ 1. Tổng quan 1.4 Các cấu trúc chương trình Cấu trúc Overlays"
1e8e6c622bfb571b0b783d8347182318:34,1e8e6c622bfb571b0b783d8347182318,34,35,,,85,Chương 3: Quản lý bộ nhớ 1. Tổng quan 1.4 Các cấu trúc chương trình Cấu trúc Overlays
1e8e6c622bfb571b0b783d8347182318:35,1e8e6c622bfb571b0b783d8347182318,35,36,,,114,M0 80K 80K 120K Bộ nhớ trong Chương 3: Quản lý bộ nhớ 1. Tổng quan 1.4 Các cấu trúc chương trình Cấu trúc Overlays
1e8e6c622bfb571b0b783d8347182318:36,1e8e6c622bfb571b0b783d8347182318,36,37,,,117,M0 80K M1 80K 120K Bộ nhớ trong Chương 3: Quản lý bộ nhớ 1. Tổng quan 1.4 Các cấu trúc chương trình Cấu trúc Overlays
1e8e6c622bfb571b0b783d8347182318:37,1e8e6c622bfb571b0b783d8347182318,37,38,,,121,M0 80K M1 80K M11 120K Bộ nhớ trong Chương 3: Quản lý bộ nhớ 1. Tổng quan 1.4 Các cấu trúc chương trình Cấu trúc Overlays
1e8e6c622bfb571b0b783d8347182318:38,1e8e6c622bfb571b0b783d8347182318,38,39,,,125,80K 80K 120K M0 M1 M11 M11 Bộ nhớ trong Chương 3: Quản lý bộ nhớ 1. Tổng quan 1.4 Các cấu trúc chương trình Cấu trúc Overlays
1e8e6c622bfb571b0b783d8347182318:39,1e8e6c622bfb571b0b783d8347182318,39,40,,,121,M0 80K M1 80K M12 120K Bộ nhớ trong Chương 3: Quản lý bộ nhớ 1. Tổng quan 1.4 Các cấu trúc chương trình Cấu trúc Overlays
1e8e6c622bfb571b0b783d8347182318:40,1e8e6c622bfb571b0b783d8347182318,40,41,,,124,80K 80K 120K M0 M1 M12 M1 Bộ nhớ trong Chương 3: Quản lý bộ nhớ 1. Tổng quan 1.4 Các cấu trúc chương trình Cấu trúc Overlays
1e8e6c622bfb571b0b783d8347182318:41,1e8e6c622bfb571b0b783d8347182318,41,42,,,125,M 1 M0 80K M2 80K M12 120K Bộ nhớ trong Chương 3: Quản lý bộ nhớ 1. Tổng quan 1.4 Các cấu trúc chương trình Cấu trúc Overlays
1e8e6c622bfb571b0b783d8347182318:42,1e8e6c622bfb571b0b783d8347182318,42,43,,,635,"l Cho phép dùng chương trình có kích thước lớn hơn kích thước hệ điều hành dành cho l Yêu cầu người sử dụng cung cấp các thông tin phụ l Hiệu quả sử dụng phụ thuộc vào các thông tin được cung cấp l Hiệu quả sử dụng bộ nhớ phụ thuộc cách tổ chức các modul trong chương trình l Nếu tồn tại một modul có kích thước lớn hơn các modul khác cùng mức rất nhiều ⇒Hiệu quả giảm rõ rệt l Quá trình nạp các modul là động, nhưng chương trình có tính chất tĩnh ⇒Không thay đổi trong các lần thực hiện l Cung cấp thêm bộ nhớ tự do, hiệu quả vẫn không đổi Chương 3: Quản lý bộ nhớ 1. Tổng quan 1.4 Các cấu trúc chương trình Cấu trúc Overlays:Nhận xét"
1e8e6c622bfb571b0b783d8347182318:43,1e8e6c622bfb571b0b783d8347182318,43,44,,,53,34/ 96 Chương 3: Quản lý bộ nhớ 1. Tổng quan Kết luận
1e8e6c622bfb571b0b783d8347182318:44,1e8e6c622bfb571b0b783d8347182318,44,45,,,111,①Tổng quan ②Các chiến lược quản lý bộ nhớ ③Bộ nhớ ảo ④Quản lý bộ nhớ trong VXL họ Intel Chương 3 Quản lý bộ nhớ
1e8e6c622bfb571b0b783d8347182318:45,1e8e6c622bfb571b0b783d8347182318,45,46,,,203,lChiến lược phân chương cố định lChiến lược phân chương động lChiến lược phân đoạn lChiến lược phân trang lChiến lược kết hợp phân đoạn-phân trang Chương 3 Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ
1e8e6c622bfb571b0b783d8347182318:46,1e8e6c622bfb571b0b783d8347182318,46,47,,,529,Hệ điều hành Chương1 Chương2 Chương3 Process Size time P1 120 20 P2 80 15 P3 70 5 P4 50 5 P5 140 12 Hàng đợi l Bộ nhớ được chia thành n phần l Mỗi phần gọi là một chương (partition) l kích thước: không nhất thiết phải bằng nhau l được sử dụng như một vùng nhớ độc lập l Tại một thời điểm chỉ cho phép một chương trình tồn tại l Các chương trình nằm trong vùng nhớ cho tới khi kết thúc l Ví dụ: Xét hệ thống: 0 150 300 500 600 Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.1 Chiến lược phân chương cố định Nguyên tắc
1e8e6c622bfb571b0b783d8347182318:47,1e8e6c622bfb571b0b783d8347182318,47,48,,,660,"l Đơn giản, dễ tổ chức bảo vệ l Chương trình và vùng nhớ có một khóa bảo vệ l So sánh 2 khóa với nhau khi nạp chương trình l Giảm thời gian tìm kiếm l Phải sao các modul điều khiển ra làm nhiều bản và lưu ở nhiều nơi l Hệ số song song không thể vượt quá n l Bị phân đoạn bộ nhớ l Kích thước chương trình lớn hơn kích thước chương lớn nhất l Tổng bộ nhớ tự do còn lớn, nhưng không dùng để nạp các chương trình khác ⇒Sửa lại cấu trúc chương, kết hợp một số chương kề nhau l Áp dụng l Thường dùng cho quản lý các đĩa dung lượng lớn l Hệ điều hành OS/360 của IBM Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.1 Chiến lược phân chương cố định Nhận xét"
1e8e6c622bfb571b0b783d8347182318:48,1e8e6c622bfb571b0b783d8347182318,48,49,,,203,lChiến lược phân chương cố định lChiến lược phân chương động lChiến lược phân đoạn lChiến lược phân trang lChiến lược kết hợp phân đoạn-phân trang Chương 3 Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ
1e8e6c622bfb571b0b783d8347182318:49,1e8e6c622bfb571b0b783d8347182318,49,50,,,749,Chỉ có một danh sách quản lý bộ nhớ tự do l Thời điểm ban đầu toàn bộ bộ nhớ là tự do với các tiến trình ⇒ vùng trống lớn nhất (hole) l Khi một tiến trình yêu cầu bộ nhớ l Tìm trong DS vùng trống một phần tử đủ lớn cho yêu cầu l Nếu tìm thấy l Vùng trống được chia thành 2 phần l Một phần cung cấp theo yêu cầu l Một phần trả lại danh sách vùng trống tự do l Nếu không tìm thấy l Phải chờ tới khi có được một vùng trống thỏa mãn l Cho phép tiến trình khác trong hàng đợi thực hiện (nếu độ ưu tiên đảm bảo) l Khi một tiến trình kết thúc l Vùng nhớ chiếm được trả về DS quản lý vùng trống tự do l Kết hợp với các vùng trống khác liên kề nếu cần thiết Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.2 Chiến lược phân chương động Nguyên tắc
1e8e6c622bfb571b0b783d8347182318:50,1e8e6c622bfb571b0b783d8347182318,50,51,,,228,0 400 2560 Process Size time P1 600 10 P2 1000 5 P3 300 20 P4 700 8 P5 500 15 File đợi 0 400 2560 ? Hệ điều hành Hệ điều hành Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.2 Chiến lược phân chương động Bộ nhớ chính
1e8e6c622bfb571b0b783d8347182318:51,1e8e6c622bfb571b0b783d8347182318,51,52,,,297,Có nhiều chiến lược lựa chọn vùng trống cho yêu cầu First Fit : Vùng trống đầu tiên thỏa mãn Best Fit : Vùng trống vừa vặn nhất Worst Fit : Vùng trống kích thước lớn nhất Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.2 Chiến lược phân chương động Chiến lược lựa chọn vùng trống tự do
1e8e6c622bfb571b0b783d8347182318:52,1e8e6c622bfb571b0b783d8347182318,52,53,,,322,"l Giả sử các vùng bộ nhớ còn trống có kích thước 100K, 500K, 200K, 300K, and 600K (theo thứ tự), l First-fit, Best-fit, and Worst-fit Sẽ nạp các tiến trình 212K, 417K, 112K, and 426K như thế nào? Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.2 Chiến lược phân chương động Chiến lược lựa chọn vùng trống tự do"
1e8e6c622bfb571b0b783d8347182318:53,1e8e6c622bfb571b0b783d8347182318,53,54,,,470,Nguyên tắc: Chia đôi liên tiếp vùng trống tự do cho tới khi thu được vùng trống nhỏ nhất thỏa mãn Cung cấp cho yêu cầu n bytes l Chia vùng trống tìm được thành 2 khối bằng nhau (gọi là buddies) l Tiếp tục chia vùng trống phía trên thành 2 phần cho tới khi đạt vùng trống nhỏ nhất kích thước lớn hơn n Ví dụ l Vùng trống 16K Bytes l Yêu cầu 735 Bytes Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.2 Chiến lược phân chương động Buddy Allocation: Cung cấp nhớ
1e8e6c622bfb571b0b783d8347182318:54,1e8e6c622bfb571b0b783d8347182318,54,55,,,470,Nguyên tắc: Chia đôi liên tiếp vùng trống tự do cho tới khi thu được vùng trống nhỏ nhất thỏa mãn Cung cấp cho yêu cầu n bytes l Chia vùng trống tìm được thành 2 khối bằng nhau (gọi là buddies) l Tiếp tục chia vùng trống phía trên thành 2 phần cho tới khi đạt vùng trống nhỏ nhất kích thước lớn hơn n Ví dụ l Vùng trống 16K Bytes l Yêu cầu 735 Bytes Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.2 Chiến lược phân chương động Buddy Allocation: Cung cấp nhớ
1e8e6c622bfb571b0b783d8347182318:55,1e8e6c622bfb571b0b783d8347182318,55,56,,,470,Nguyên tắc: Chia đôi liên tiếp vùng trống tự do cho tới khi thu được vùng trống nhỏ nhất thỏa mãn Cung cấp cho yêu cầu n bytes l Chia vùng trống tìm được thành 2 khối bằng nhau (gọi là buddies) l Tiếp tục chia vùng trống phía trên thành 2 phần cho tới khi đạt vùng trống nhỏ nhất kích thước lớn hơn n Ví dụ l Vùng trống 16K Bytes l Yêu cầu 735 Bytes Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.2 Chiến lược phân chương động Buddy Allocation: Cung cấp nhớ
1e8e6c622bfb571b0b783d8347182318:56,1e8e6c622bfb571b0b783d8347182318,56,57,,,470,Nguyên tắc: Chia đôi liên tiếp vùng trống tự do cho tới khi thu được vùng trống nhỏ nhất thỏa mãn Cung cấp cho yêu cầu n bytes l Chia vùng trống tìm được thành 2 khối bằng nhau (gọi là buddies) l Tiếp tục chia vùng trống phía trên thành 2 phần cho tới khi đạt vùng trống nhỏ nhất kích thước lớn hơn n Ví dụ l Vùng trống 16K Bytes l Yêu cầu 735 Bytes Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.2 Chiến lược phân chương động Buddy Allocation: Cung cấp nhớ
1e8e6c622bfb571b0b783d8347182318:57,1e8e6c622bfb571b0b783d8347182318,57,58,,,470,Nguyên tắc: Chia đôi liên tiếp vùng trống tự do cho tới khi thu được vùng trống nhỏ nhất thỏa mãn Cung cấp cho yêu cầu n bytes l Chia vùng trống tìm được thành 2 khối bằng nhau (gọi là buddies) l Tiếp tục chia vùng trống phía trên thành 2 phần cho tới khi đạt vùng trống nhỏ nhất kích thước lớn hơn n Ví dụ l Vùng trống 16K Bytes l Yêu cầu 735 Bytes Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.2 Chiến lược phân chương động Buddy Allocation: Cung cấp nhớ
1e8e6c622bfb571b0b783d8347182318:58,1e8e6c622bfb571b0b783d8347182318,58,59,,,470,Nguyên tắc: Chia đôi liên tiếp vùng trống tự do cho tới khi thu được vùng trống nhỏ nhất thỏa mãn Cung cấp cho yêu cầu n bytes l Chia vùng trống tìm được thành 2 khối bằng nhau (gọi là buddies) l Tiếp tục chia vùng trống phía trên thành 2 phần cho tới khi đạt vùng trống nhỏ nhất kích thước lớn hơn n Ví dụ l Vùng trống 16K Bytes l Yêu cầu 735 Bytes Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.2 Chiến lược phân chương động Buddy Allocation: Cung cấp nhớ
1e8e6c622bfb571b0b783d8347182318:59,1e8e6c622bfb571b0b783d8347182318,59,60,,,449,"l Hệ thống duy trì các danh sách vùng trống kích thước 1, 2, . . . , 2n bytes l Với yêu cầu K, tìm phần tử nhỏ nhất kích thước lớn hơn K l Nếu phần tử nhỏ nhất lớn hơn 2K, chia liên tiếp tới khi được vùng nhỏ nhất kích thước lớn hơn K l Nhận xét: Với bộ nhớ kích thước n, cần duyệt log2n danh sách ⇒ Nhanh Ví dụ bộ nhớ 16K bytes Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.2 Chiến lược phân chương động Buddy Allocation: Cung cấp nhớ"
1e8e6c622bfb571b0b783d8347182318:60,1e8e6c622bfb571b0b783d8347182318,60,61,,,469,"l Hệ thống duy trì các danh sách vùng trống kích thước 1, 2, . . . , 2n bytes l Với yêu cầu K, tìm phần tử nhỏ nhất kích thước lớn hơn K l Nếu phần tử nhỏ nhất lớn hơn 2K, chia liên tiếp tới khi được vùng nhỏ nhất kích thước lớn hơn K l Nhận xét: Với bộ nhớ kích thước n, cần duyệt log2n danh sách ⇒ Nhanh Ví dụ bộ nhớ 16K bytes l Yêu cầu 735 bytes Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.2 Chiến lược phân chương động Buddy Allocation: Cung cấp nhớ"
1e8e6c622bfb571b0b783d8347182318:61,1e8e6c622bfb571b0b783d8347182318,61,62,,,490,"l Hệ thống duy trì các danh sách vùng trống kích thước 1, 2, . . . , 2n bytes l Với yêu cầu K, tìm phần tử nhỏ nhất kích thước lớn hơn K l Nếu phần tử nhỏ nhất lớn hơn 2K, chia liên tiếp tới khi được vùng nhỏ nhất kích thước lớn hơn K l Nhận xét: Với bộ nhớ kích thước n, cần duyệt log2n danh sách ⇒ Nhanh Ví dụ bộ nhớ 16K bytes l Yêu cầu 735 bytes l Yêu cầu 1205 bytes Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.2 Chiến lược phân chương động Buddy Allocation: Cung cấp nhớ"
1e8e6c622bfb571b0b783d8347182318:62,1e8e6c622bfb571b0b783d8347182318,62,63,,,511,"l Hệ thống duy trì các danh sách vùng trống kích thước 1, 2, . . . , 2n bytes l Với yêu cầu K, tìm phần tử nhỏ nhất kích thước lớn hơn K l Nếu phần tử nhỏ nhất lớn hơn 2K, chia liên tiếp tới khi được vùng nhỏ nhất kích thước lớn hơn K l Nhận xét: Với bộ nhớ kích thước n, cần duyệt log2n danh sách ⇒ Nhanh Ví dụ bộ nhớ 16K bytes l Yêu cầu 735 bytes l Yêu cầu 1205 bytes l Yêu cầu 2010 bytes Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.2 Chiến lược phân chương động Buddy Allocation: Cung cấp nhớ"
1e8e6c622bfb571b0b783d8347182318:63,1e8e6c622bfb571b0b783d8347182318,63,64,,,257,l Có thể kết hợp 2 vùng kề nhau có cùng kích thước l Tiếp tục kết hợp liên tiếp cho tới khi tạo ra vùng trống lớn nhất có thể Ví dụ Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.2 Chiến lược phân chương động Buddy Allocation : Thu hồi vùng nhớ
1e8e6c622bfb571b0b783d8347182318:64,1e8e6c622bfb571b0b783d8347182318,64,65,,,293,l Có thể kết hợp 2 vùng kề nhau có cùng kích thước l Tiếp tục kết hợp liên tiếp cho tới khi tạo ra vùng trống lớn nhất có thể Ví dụ l Giải phóng vùng nhớ thứ nhất (1K) Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.2 Chiến lược phân chương động Buddy Allocation : Thu hồi vùng nhớ
1e8e6c622bfb571b0b783d8347182318:65,1e8e6c622bfb571b0b783d8347182318,65,66,,,327,l Có thể kết hợp 2 vùng kề nhau có cùng kích thước l Tiếp tục kết hợp liên tiếp cho tới khi tạo ra vùng trống lớn nhất có thể Ví dụ l Giải phóng vùng nhớ thứ nhất (1K) l Kết hợp 2 vùng 1K thành vùng 2K Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.2 Chiến lược phân chương động Buddy Allocation : Thu hồi vùng nhớ
1e8e6c622bfb571b0b783d8347182318:66,1e8e6c622bfb571b0b783d8347182318,66,67,,,362,l Có thể kết hợp 2 vùng kề nhau có cùng kích thước l Tiếp tục kết hợp liên tiếp cho tới khi tạo ra vùng trống lớn nhất có thể Ví dụ l Giải phóng vùng nhớ thứ nhất (1K) l Kết hợp 2 vùng 1K thành vùng 2K l Giải phóng vùng nhớ thứ hai (2K) Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.2 Chiến lược phân chương động Buddy Allocation : Thu hồi vùng nhớ
1e8e6c622bfb571b0b783d8347182318:67,1e8e6c622bfb571b0b783d8347182318,67,68,,,396,l Có thể kết hợp 2 vùng kề nhau có cùng kích thước l Tiếp tục kết hợp liên tiếp cho tới khi tạo ra vùng trống lớn nhất có thể Ví dụ l Giải phóng vùng nhớ thứ nhất (1K) l Kết hợp 2 vùng 1K thành vùng 2K l Giải phóng vùng nhớ thứ hai (2K) l Kết hợp 2 vùng 2K thành vùng 4K Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.2 Chiến lược phân chương động Buddy Allocation : Thu hồi vùng nhớ
1e8e6c622bfb571b0b783d8347182318:68,1e8e6c622bfb571b0b783d8347182318,68,69,,,430,l Có thể kết hợp 2 vùng kề nhau có cùng kích thước l Tiếp tục kết hợp liên tiếp cho tới khi tạo ra vùng trống lớn nhất có thể Ví dụ l Giải phóng vùng nhớ thứ nhất (1K) l Kết hợp 2 vùng 1K thành vùng 2K l Giải phóng vùng nhớ thứ hai (2K) l Kết hợp 2 vùng 2K thành vùng 4K l Giải phóng vùng nhớ thứ ba (2K) Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.2 Chiến lược phân chương động Buddy Allocation : Thu hồi vùng nhớ
1e8e6c622bfb571b0b783d8347182318:69,1e8e6c622bfb571b0b783d8347182318,69,70,,,464,l Có thể kết hợp 2 vùng kề nhau có cùng kích thước l Tiếp tục kết hợp liên tiếp cho tới khi tạo ra vùng trống lớn nhất có thể Ví dụ l Giải phóng vùng nhớ thứ nhất (1K) l Kết hợp 2 vùng 1K thành vùng 2K l Giải phóng vùng nhớ thứ hai (2K) l Kết hợp 2 vùng 2K thành vùng 4K l Giải phóng vùng nhớ thứ ba (2K) l Kết hợp 2 vùng 2K thành vùng 4K Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.2 Chiến lược phân chương động Buddy Allocation : Thu hồi vùng nhớ
1e8e6c622bfb571b0b783d8347182318:70,1e8e6c622bfb571b0b783d8347182318,70,71,,,498,l Có thể kết hợp 2 vùng kề nhau có cùng kích thước l Tiếp tục kết hợp liên tiếp cho tới khi tạo ra vùng trống lớn nhất có thể Ví dụ l Giải phóng vùng nhớ thứ nhất (1K) l Kết hợp 2 vùng 1K thành vùng 2K l Giải phóng vùng nhớ thứ hai (2K) l Kết hợp 2 vùng 2K thành vùng 4K l Giải phóng vùng nhớ thứ ba (2K) l Kết hợp 2 vùng 2K thành vùng 4K l Kết hợp 2 vùng 4K thành vùng 8K Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.2 Chiến lược phân chương động Buddy Allocation : Thu hồi vùng nhớ
1e8e6c622bfb571b0b783d8347182318:71,1e8e6c622bfb571b0b783d8347182318,71,72,,,533,l Có thể kết hợp 2 vùng kề nhau có cùng kích thước l Tiếp tục kết hợp liên tiếp cho tới khi tạo ra vùng trống lớn nhất có thể Ví dụ l Giải phóng vùng nhớ thứ nhất (1K) l Kết hợp 2 vùng 1K thành vùng 2K l Giải phóng vùng nhớ thứ hai (2K) l Kết hợp 2 vùng 2K thành vùng 4K l Giải phóng vùng nhớ thứ ba (2K) l Kết hợp 2 vùng 2K thành vùng 4K l Kết hợp 2 vùng 4K thành vùng 8K l Kết hợp 2 vùng 8K thành vùng 16K Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.2 Chiến lược phân chương động Buddy Allocation : Thu hồi vùng nhớ
1e8e6c622bfb571b0b783d8347182318:72,1e8e6c622bfb571b0b783d8347182318,72,73,,,942,"Sau một thời gian hoạt động, các vùng trống nằm rải rác khắp nơi gây ra hiện tượng thiếu bộ nhớ. ⇒Cần phải bố trí lại bộ nhớ l Dịch chuyển các tiến trình l Vấn đề không đơn giản vì các đối tượng bên trong khi chuyển sang vị trí mới sẽ mang địa chỉ khác đi l Sử dụng thanh ghi dịch chuyển (relocation register) chứa giá trị bằng độ dịch chuyển của tiến trình l Vấn đề lựa chọn phương pháp để chi phí nhỏ nhất l Dịch chuyển tất cả về một phía ⇒ vùng trống lớn nhất l Dịch chuyển để tạo ra ngay lập tức một vùng trống vừa vặn l Phương pháp tráo đổi (swapping) l Lựa chọn thời điểm dừng tiến trình đang thực hiện l Đưa tiến trình và trạng thái tương ứng ra bên ngoài l Giải phóng vùng nhớ để kết hợp với các phần tử liền kề l Tái định vị vào vị trí cũ và khôi phục trạng thái cũ l Dùng thanh ghi dịch chuyển nếu đưa vào vị trí khác Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.2 Chiến lược phân chương động Vấn đề bố trí lại bộ nhớ"
1e8e6c622bfb571b0b783d8347182318:73,1e8e6c622bfb571b0b783d8347182318,73,74,,,680,"l Không phải sao lưu modul điều khiển ra nhiều nơi l Tăng/giảm hệ số song song tùy theo số lượng và kích thước chương trình l Không thực hiện được chương trình có kích thước lớn hơn kích thước bộ nhớ vật lý l Gây ra hiện tượng rác l Bộ nhớ không được sử dụng, nhưng cũng không nằm trong DS quản lý bộ nhớ tự do l Do lỗi hệ điều hành l Do phần mềm phá hoại l Gây ra hiện tượng phân đoạn ngoài l Vùng nhớ tự do được quản lý đầy đủ, nhưng nằm rải rác nên không sử dụng được l Gây ra hiện tượng phân đoạn trong l Vùng nhớ dành cho chương trình nhưng không được chương trình sử dụng tới Nhận xét Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.2 Chiến lược phân chương động"
1e8e6c622bfb571b0b783d8347182318:74,1e8e6c622bfb571b0b783d8347182318,74,75,,,203,lChiến lược phân chương cố định lChiến lược phân chương động lChiến lược phân đoạn lChiến lược phân trang lChiến lược kết hợp phân đoạn-phân trang Chương 3 Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ
1e8e6c622bfb571b0b783d8347182318:75,1e8e6c622bfb571b0b783d8347182318,75,76,,,656,"l Chương trình thường gồm các modul l Một chương trình chính (main program) l Tập các chương trình con l Các biến, các cấu trúc dữ liệu,. . . l Các modul, đối tượng trong c/trình được xác định bằng tên l Hàm sqrt(), thủ tục printf() . . . l x, y, counter, Buffer. . . l Các p/tử trong modul được x/định theo độ lệch với vị trí đầu l Câu lệnh thư 10 của hàm sqrt(). . . l Phần tử thứ 2 của mảng Buffer. . . Chương trình được tổ chức như thế nào trong bộ nhớ? l Stack nằm trên hay Data nằm trên trong bộ nhớ? l Địa chỉ vật lý các đối tượng . . .? ⇒Không quan tâm Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.3 Chiến lược phân đoạn Chương trình"
1e8e6c622bfb571b0b783d8347182318:76,1e8e6c622bfb571b0b783d8347182318,76,77,,,510,"subroutines array main program data stack Không gian địa chỉ logic Khi đưa c/trình vào bộ nhớ để thực hiện C/trình gồm nhiều đoạn khác nhau l Mỗi đoạn là một khối logic, ứng với một modul l Mã lệnh: main(), thủ tục, hàm. . . l Dữ liệu: Đối tượng toàn cục, cục bộ l Các đoạn khác: stack, mảng. . . l Mỗi đoạn chiếm một vùng liên tục l Có vị trí bắt đầu và kích thước l Có thể nằm tại bất cứ đâu trong bộ nhớ Quan điểm người dùng Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.3 Chiến lược phân đoạn"
1e8e6c622bfb571b0b783d8347182318:77,1e8e6c622bfb571b0b783d8347182318,77,78,,,624,"Khi đưa c/trình vào bộ nhớ để thực hiện C/trình gồm nhiều đoạn khác nhau l Mỗi đoạn là một khối logic, ứng với một modul l Mã lệnh: main(), thủ tục, hàm. . . l Dữ liệu: Đối tượng toàn cục, cục bộ l Các đoạn khác: stack, mảng. . . l Mỗi đoạn chiếm một vùng liên tục l Có vị trí bắt đầu và kích thước l Có thể nằm tại bất cứ đâu trong bộ nhớ l Đối tượng trong đoạn được xác định bởi vị trí tương đối so với đầu đoạn l Lệnh thứ 5 của chương trình chính l Phần tử đầu tiên của stack. . . l Vị trí các đối tượng trong bộ nhớ? Quan điểm người dùng Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.3 Chiến lược phân đoạn"
1e8e6c622bfb571b0b783d8347182318:78,1e8e6c622bfb571b0b783d8347182318,78,79,,,200,subroutine Đoạn 2 array Đoạn 3 main program Đoạn 0 data Đoạn 4 stack Đoạn 1 Ví dụ Không gian địa chỉ logic Bộ nhớ HĐH Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.3 Chiến lược phân đoạn
1e8e6c622bfb571b0b783d8347182318:79,1e8e6c622bfb571b0b783d8347182318,79,80,,,224,subroutine Đoạn 2 array Đoạn 3 main program Đoạn 0 data Đoạn 4 stack Đoạn 1 HĐH Đoạn 0 Đoạn 3 1400 4300 Ví dụ Không gian địa chỉ logic Bộ nhớ Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.3 Chiến lược phân đoạn
1e8e6c622bfb571b0b783d8347182318:80,1e8e6c622bfb571b0b783d8347182318,80,81,,,165,HĐH Đoạn 0 1400 4300 Ví dụ Bộ nhớ Lệnh thứ 5 P/tử thứ 11 5x4 11x2 Đoạn 3 1420 4322 Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.3 Chiến lược phân đoạn
1e8e6c622bfb571b0b783d8347182318:81,1e8e6c622bfb571b0b783d8347182318,81,82,,,713,"Mark Address Length . . . . . . . . . . . . . . . . . . Cấu trúc phân đoạn Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.3 Chiến lược phân đoạn 0 ... n l Chương trình là tập hợp các đoạn (modul,segment) l Tên đoạn (số hiệu đoạn), độ dài của đoạn l Mỗi đoạn có thể được biên tập riêng. l Dịch và biên tập chương trình tạo ra bảng quản lý đoạn (SCB: Segement Control Block) l Mỗi phần tử của bảng ứng với một đoạn của chương trình l Dấu hiệu (Mark(0/1)): Đoạn đã tồn tại trong bộ nhớ l Địa chỉ (Address): Vị trí cơ sở (base) của đoạn trong bộ nhớ l Độ dài (Length): Độ dài của đoạn l Địa chỉ truy nhập: tên (số hiệu) đoạn và độ lệch trong đoạn Vấn đề: Chuyển đổi từ địa chỉ 2 chiều ⇒ địa chỉ một chiều"
1e8e6c622bfb571b0b783d8347182318:82,1e8e6c622bfb571b0b783d8347182318,82,83,,,253,subroutine Đoạn 2 array Đoạn 3 main program Đoạn 0 data Đoạn 4 stack Đoạn 1 Ví dụ Không gian địa chỉ logic Bộ nhớ HĐH Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.3 Chiến lược phân đoạn M A L 0 - 1000 0 - 400 0 - 400 0 - 1100 0 - 1000 SCB
1e8e6c622bfb571b0b783d8347182318:83,1e8e6c622bfb571b0b783d8347182318,83,84,,,333,subroutine Đoạn 2 array Đoạn 3 main program Đoạn 0 data Đoạn 4 stack Đoạn 1 Ví dụ Không gian địa chỉ logic Bộ nhớ HĐH Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.3 Chiến lược phân đoạn M A L 1 1400 1000 1 6300 400 0 - 400 1 3200 1100 1 4700 1000 SCB Đoạn 0 Đoạn 3 Đoạn 4 Đoạn 1 1400 2400 3200 4300 4700 5700 6300 6700
1e8e6c622bfb571b0b783d8347182318:84,1e8e6c622bfb571b0b783d8347182318,84,85,,,402,"subroutine Đoạn 2 array Đoạn 3 main program Đoạn 0 data Đoạn 4 stack Đoạn 1 Ví dụ Không gian địa chỉ logic Bộ nhớ HĐH Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.3 Chiến lược phân đoạn M A L 1 1400 1000 1 6300 400 0 - 400 1 3200 1100 1 4700 1000 SCB Đoạn 0 Đoạn 3 Đoạn 4 Đoạn 1 1400 2400 3200 4300 4700 5700 6300 6700 Địa chỉ <3,345> = ? Đoạn 3 bắt đầu tại 3200 P/tử 345 Offset 345 3545"
1e8e6c622bfb571b0b783d8347182318:85,1e8e6c622bfb571b0b783d8347182318,85,86,,,357,"subroutine Đoạn 2 array Đoạn 3 main program Đoạn 0 data Đoạn 4 stack Đoạn 1 Ví dụ Không gian địa chỉ logic Bộ nhớ HĐH Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.3 Chiến lược phân đoạn M A L 1 1400 1000 1 6300 400 0 - 400 1 3200 1100 1 4700 1000 SCB Đoạn 0 Đoạn 3 Đoạn 4 Đoạn 1 1400 2400 3200 4300 4700 5700 6300 6700 Địa chỉ <4,185> = ?4885"
1e8e6c622bfb571b0b783d8347182318:86,1e8e6c622bfb571b0b783d8347182318,86,87,,,377,"subroutine Đoạn 2 array Đoạn 3 main program Đoạn 0 data Đoạn 4 stack Đoạn 1 Ví dụ Không gian địa chỉ logic Bộ nhớ HĐH Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.3 Chiến lược phân đoạn M A L 1 1400 1000 1 6300 400 0 - 400 1 3200 1100 1 4700 1000 SCB Đoạn 0 Đoạn 3 Đoạn 4 Đoạn 1 1400 2400 3200 4300 4700 5700 6300 6700 Địa chỉ <2,120> = ? Jmp <2:120> Đoạn 2 2800"
1e8e6c622bfb571b0b783d8347182318:87,1e8e6c622bfb571b0b783d8347182318,87,88,,,380,"subroutine Đoạn 2 array Đoạn 3 main program Đoạn 0 data Đoạn 4 stack Đoạn 1 Ví dụ Không gian địa chỉ logic Bộ nhớ HĐH Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.3 Chiến lược phân đoạn M A L 1 1400 1000 1 6300 400 1 2800 400 1 3200 1100 1 4700 1000 SCB Đoạn 0 Đoạn 3 Đoạn 4 Đoạn 1 1400 2400 3200 4300 4700 5700 6300 6700 Địa chỉ <2,120> = ? Jmp <2:120> Đoạn 2 2800"
1e8e6c622bfb571b0b783d8347182318:88,1e8e6c622bfb571b0b783d8347182318,88,89,,,383,"subroutine Đoạn 2 array Đoạn 3 main program Đoạn 0 data Đoạn 4 stack Đoạn 1 Ví dụ Không gian địa chỉ logic Bộ nhớ HĐH Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.3 Chiến lược phân đoạn M A L 1 1400 1000 1 6300 400 1 2800 400 1 3200 1100 1 4700 1000 SCB Đoạn 0 Đoạn 3 Đoạn 4 Đoạn 1 1400 2400 3200 4300 4700 5700 6300 6700 Địa chỉ <2,120> = 2920 Jmp <2:120> Đoạn 2 2800"
1e8e6c622bfb571b0b783d8347182318:89,1e8e6c622bfb571b0b783d8347182318,89,90,,,395,"subroutine Đoạn 2 array Đoạn 3 main program Đoạn 0 data Đoạn 4 stack Đoạn 1 Ví dụ Không gian địa chỉ logic Bộ nhớ HĐH Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.3 Chiến lược phân đoạn M A L 1 1400 1000 1 6300 400 1 2800 400 1 3200 1100 1 4700 1000 SCB Đoạn 0 Đoạn 3 Đoạn 4 Đoạn 1 1400 2400 3200 4300 4700 5700 6300 6700 Địa chỉ <2,450> = ? Jmp <2:120> Đoạn 2 2800 Lỗi truy nhập!"
1e8e6c622bfb571b0b783d8347182318:90,1e8e6c622bfb571b0b783d8347182318,90,91,,,891,"Chuyển đổi địa chỉ Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.3 Chiến lược phân đoạn l Khi thực hiện chương trình l Bảng quản lý đoạn được nạp vào bộ nhớ l STBR (Segment-table base register): Vị trí SCB trong bộ nhớ l STLR (Segment-table length register): Số phần tử của SCB l Truy nhập tới địa chỉ logic < s, d > ① s ≥ STLR : Lỗi ② STBR + s * K : Vị trí phần tử s trong SCB ③ Kiểm tra trường dấu hiệu M của phần tử SCBs l M = 0: Đoạn s chưa tồn tại trong bộ nhớ ⇒ Lỗi truy nhập ⇒ Hệ điều hành phải nạp đoạn l Xin vùng nhớ có kích thước được ghi trong trường L l Tìm modul tương ứng ở bộ nhớ ngoài và nạp và định vị vào vùng nhớ xin được l Sửa lại trường địa chỉ A và trường dấu hiệu M(M = 1) l Truy nhập bộ nhớ như trường hợp không gặp lỗi truy nhập l M = 1 :Đoạn s đã tồn tại trong bộ nhớ l d ≥ Ls: Lỗi truy nhập (vượt quá kích thước đoạn) l d + As: Địa chỉ vật lý cần tìm"
1e8e6c622bfb571b0b783d8347182318:91,1e8e6c622bfb571b0b783d8347182318,91,92,,,118,Chuyển đổi địa chỉ: Sơ đồ truy nhập Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.3 Chiến lược phân đoạn
1e8e6c622bfb571b0b783d8347182318:92,1e8e6c622bfb571b0b783d8347182318,92,93,,,561,Tiến trình 1 Data (Read only) sqrt() S0 S3 S0 Nhận xét: ưu điểm Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.3 Chiến lược phân đoạn l Sơ đồ nạp modul không cần sự tham gia của người sử dụng l Dễ dàng thực hiện nhiệm vụ bảo vệ đoạn l Kiểm tra lỗi truy nhập bộ nhớ l Địa chỉ không hợp lệ :vươt quá kích thước đoạn l Kiểm tra tính chất truy nhập l Đoạn mã: chỉ đọc -> Viết vào đoạn mã: lỗi truy nhập l Kiểm tra quyền truy nhập modul l Thêm trường quyền truy nhập(user/system) vào SCB l Cho phép sử dụng chung đoạn (VD Soạn thảo văn bản) Tiến trình 2
1e8e6c622bfb571b0b783d8347182318:93,1e8e6c622bfb571b0b783d8347182318,93,94,,,290,"Dùng chung đoạn : Vấn đề chính Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.3 Chiến lược phân đoạn l Đoạn dùng chung phải cùng số hiệu trong SCB l Call (0, 120) ? l Read (1, 245) ? l Giải quyết bằng cách truy nhập gián tiếp l JMP + 08 l Thanh ghi đoạn chứa số hi đoạn (ES:BX)"
1e8e6c622bfb571b0b783d8347182318:94,1e8e6c622bfb571b0b783d8347182318,94,95,,,696,"Nhận xét : Nhược điểm Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.3 Chiến lược phân đoạn l Hiệu quả sử dụng phụ thuộc vào cấu trúc chương trình l Bị phân mảnh bộ nhớ l Phân phối vùng nhớ theo các chiến lược first fit /best fit... l Cần phải bố trí lại bộ nhớ (dịch chuyển, swapping) l Có thể dựa vào bảng SCB l M ← 0 : Đoạn chưa được nạp vào l Vùng nhớ được xác định bởi A và L được trả về DS tự do l Vấn đề lựa chọn modul cần đưa ra l Đưa ra modul tồn tại lâu nhất l Đưa ra modul có lần sử dụng cuối cách xa nhất l Đưa ra modul có tần xuất sử dụng thấp nhất ⇒Cần phương tiên ghi lại số lần và thời điểm truy nhập đoạn l Giải pháp: phân phối bộ nhớ theo các đoạn bằng nhau (page)?"
1e8e6c622bfb571b0b783d8347182318:95,1e8e6c622bfb571b0b783d8347182318,95,96,,,203,lChiến lược phân chương cố định lChiến lược phân chương động lChiến lược phân đoạn lChiến lược phân trang lChiến lược kết hợp phân đoạn-phân trang Chương 3 Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ
1e8e6c622bfb571b0b783d8347182318:96,1e8e6c622bfb571b0b783d8347182318,96,97,,,933,"Nguyên tắc Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.4 Chiến lược phân trang l Bộ nhớ vật lý được chia thành từng khối có kích thước bằng nhau: trang vật lý (frames – khung trang) l Trang vật lý được đánh số 0, 1, 2, . . . : địa chỉ vật lý của trang l Trang được dùng làm đơn vị phân phối nhớ l Bộ nhớ logic (chương trình) được chia thành từng trang có kích thước bằng trang vật lý: trang logic (pages) l Khi thực hiện chương trình l Nạp trang logic (từ bộ nhớ ngoài) vào trang vật lý l Xây dựng một bảng quản lý trang (PCB: Page Control Block) dùng để xác định mối quan hệ giữa trang vật lý và trang logic l Mỗi phần tử của PCB ứng với một trang chương trình l Cho biết trang vật lý chứa trang logic tương ứng l Ví dụ PCB[8] = 4 ⇒ ? l Địa chỉ truy nhập được chia thành l Số hiệu trang (p) : Chỉ số trong PCB để tìm đ/chỉ cơ sở trang l Độ lệch trong trang (d): Kết hợp địa chỉ cơ sở của trang để tìm ra đ/chỉ vật lý"
1e8e6c622bfb571b0b783d8347182318:97,1e8e6c622bfb571b0b783d8347182318,97,98,,,196,6 5 4 3 2 1 0 3 2 1 0 Trang0 Trang1 Trang2 Trang3 Ví dụ Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.4 Chiến lược phân trang 7 Bộ nhớ logic Bộ nhớ vật lý 2 1 6 0 5 1 2 3 PCB Trang 0
1e8e6c622bfb571b0b783d8347182318:98,1e8e6c622bfb571b0b783d8347182318,98,99,,,196,6 5 4 3 2 1 0 3 2 1 0 Trang0 Trang1 Trang2 Trang3 Ví dụ Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.4 Chiến lược phân trang 7 Bộ nhớ logic Bộ nhớ vật lý 2 1 6 0 5 1 2 3 PCB Trang 1
1e8e6c622bfb571b0b783d8347182318:99,1e8e6c622bfb571b0b783d8347182318,99,100,,,196,6 5 4 3 2 1 0 3 2 1 0 Trang0 Trang1 Trang2 Trang3 Ví dụ Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.4 Chiến lược phân trang 7 Bộ nhớ logic Bộ nhớ vật lý 2 1 6 0 5 1 2 3 PCB Trang 2
1e8e6c622bfb571b0b783d8347182318:100,1e8e6c622bfb571b0b783d8347182318,100,101,,,196,6 5 4 3 2 1 0 3 2 1 0 Trang0 Trang1 Trang2 Trang3 Ví dụ Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.4 Chiến lược phân trang 7 Bộ nhớ logic Bộ nhớ vật lý 2 1 6 0 5 1 2 3 PCB Trang 3
1e8e6c622bfb571b0b783d8347182318:101,1e8e6c622bfb571b0b783d8347182318,101,102,,,792,"Ghi chú Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.4 Chiến lược phân trang l Dung lượng trang luôn là lũy thừa của 2 l Cho phép ghép giữa số hiệu trang vật lý và độ lệch trong trang l Ví dụ: Bộ nhớ n bit, kích thước trang 2k số hiệu trang độ lệch l Không cần thiết nạp toàn bộ trang logic vào l Số trang vật lý phụ thuộc k/thước bộ nhớ, số trang logic tùy ý l PCB cần trường dấu hiệu (Mark) cho biết trang đã được nạp vào bộ nhớ chưa l M = 0 Trang chưa tồn tại l M = 1 Trang đã được đưa vào bộ nhớ vật lý l Phân biệt chiến lược phân trang - phân đoạn l Chiến lược phân đoạn l Các modul phụ thuộc cấu trúc logic của chương trình l Chiến lược phân trang l Các khối có kích thước độc lập kích thước chương trình l Kích thước khối phụ thuộc phần cứng (VD: 29 → 213 bytes) n − k k"
1e8e6c622bfb571b0b783d8347182318:102,1e8e6c622bfb571b0b783d8347182318,102,103,,,241,"Ví dụ Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.4 Chiến lược phân trang Bộ nhớ vật lý 2 1 6 0 5 1 2 3 PCB Bộ nhớ logic Truy nhập địa chỉ logic [ 6 ] ? Địa chỉ [ 6 ]: Trang 1, độ lệch 2 Địa chỉ <1,2> = 6*4 + 2 = 26 (624) g g"
1e8e6c622bfb571b0b783d8347182318:103,1e8e6c622bfb571b0b783d8347182318,103,104,,,228,Thực hiện chương trình → Nạp chương trình vào bộ nhớ Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.4 Chiến lược phân trang l Nếu đủ trang vật lý tự do ⇒ nạp toàn bộ l Nếu không đủ trang vật lý tự do ⇒ nạp từng phần
1e8e6c622bfb571b0b783d8347182318:104,1e8e6c622bfb571b0b783d8347182318,104,105,,,733,"Thực hiện chương trình → Truy nhập bộ nhớ Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.4 Chiến lược phân trang l Nạp chương trình l Xây dựng bảng quản lý trang và luôn giữ trong bộ nhớ l PTBR (Page-table base register) trỏ tới PCB. l PTLR(Page-table length register) kích thước PCB. l Thực hiện truy nhập l Địa chỉ truy nhập được chia thành dạng <p, d> l PTBR + p ∗ K : Địa chỉ phần tử p của PCB trong bộ nhớ l K Kích thước 1 phần tử của PCB l Kiểm tra Mp l Mp = 0 : Lỗi trang, sinh một ngắt để tiến hành nạp trang l Xin trang vật lý tự do (Hết trang tự do?) l Tìm kiếm trang logic ở bộ nhớ ngoài và nạp trang l Sửa lại trường địa chỉ A và dấu hiệu M l Mp = 1 : Trang đã tồn tại, l Lấy Ap ghép với d ra địa chỉ cần tìm"
1e8e6c622bfb571b0b783d8347182318:105,1e8e6c622bfb571b0b783d8347182318,105,106,,,126,65/ 96 Chuyển đổi địa chỉ: Sơ đồ truy nhập Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.4 Chiến lược phân trang
1e8e6c622bfb571b0b783d8347182318:106,1e8e6c622bfb571b0b783d8347182318,106,107,,,654,Nạp trang và thay thế trang Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.4 Chiến lược phân trang l Nhận xét l Số trang vật lý dành cho chương trình lớn l Thực hiện nhanh nhưng hệ số song song giảm l Số trang vật lý dành cho chương trình bé l Hệ số song song cao nhưng thực hiện chậm do hay thiếu trang ⇒ Hiệu quả phụ thuộc các chiến lược nạp trang và thay thế trang l Các chiến lược nạp trang l Nạp tất cả: Nạp toàn bộ chương trình l Nạp trước: Dự báo trang cần thiết tiếp theo l Nạp theo yêu cầu: Chỉ nạp khi cần thiết l Các chiến lược thay thế trang l FIFO First In First Out l LRU Least Recently Used l LFU Least Frequently Used l . . .
1e8e6c622bfb571b0b783d8347182318:107,1e8e6c622bfb571b0b783d8347182318,107,108,,,553,Ưu điểm Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.4 Chiến lược phân trang l Tăng tốc độ truy nhập l Hai lần truy nhập bộ nhớ (vào PCB và vào địa chỉ cần tìm) l Thực hiện phép ghép thay vì phép cộng l Không tồn tại hiện tượng phân đoạn ngoài l Hệ số song song cao l Chỉ cần một vài trang của chương trình trong bộ nhớ l Cho phép viết chương trình lớn tùy ý l Dễ dàng thực hiện nhiệm vụ bảo vệ l Địa chỉ truy nhập hợp lệ (vượt quá kích thước) l Tính chất truy nhập (đọc/ghi) l Quyền truy nhập (user/system) l Cho phép sử dụng chung trang
1e8e6c622bfb571b0b783d8347182318:108,1e8e6c622bfb571b0b783d8347182318,108,109,,,243,Dùng chung trang : Soạn thảo văn bản Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.4 Chiến lược phân trang l Mỗi trang 50K l 3 trang mã l 1 trang dữ liệu l 40 người dùng l Không dùng chung l Cần 8000K l Dùng chung l Chỉ cần 2150K
1e8e6c622bfb571b0b783d8347182318:109,1e8e6c622bfb571b0b783d8347182318,109,110,,,631,"Dùng chung trang : Nguyên tắc Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.4 Chiến lược phân trang l Cần thiết trong môi trường hoạt động phân chia l Giảm kích thước vùng nhớ cho tất cả các tiến trình l Phần mã dùng chung l Chỉ một phiên bản phân chia giữa các tiến trình trong bộ nhớ l Ví dụ: Soạn thảo văn bản, chương trình dịch.... l Vấn đề: Mã dùng chung không đổi l Trang dùng chung phải cùng vị trí trong không gian logic của tất cả tiến trình ⇒ Cùng số hiệu trong bảng quản lý trang l Phần mã và dữ liệu riêng biệt l Riêng biệt cho các tiến trình l Có thể nằm ở vị trí bất kỳ trong bộ nhớ logic của tiến trình"
1e8e6c622bfb571b0b783d8347182318:110,1e8e6c622bfb571b0b783d8347182318,110,111,,,515,"Nhược điểm Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.4 Chiến lược phân trang l Tồn tại hiện tượng phân đoạn trong l Luôn xuất hiện ở trang cuối cùng l Giảm hiện tượng phân đoạn trang bởi giảm kích thước trang ? l Hay gặp lỗi trang l Bảng quản lý trang lớn l Đòi hỏi hỗ trợ của phần cứng l Chi phí cho chiến lược phân trang lớn l Khi chương trình lớn, bảng quản lý trang nhiều phần tử l Chương trình 230, k/thước trang 212-> PCB có 220 phần tử l Tốn bộ nhớ lưu trữ PCB l Giải quyết: Trang nhiều mức"
1e8e6c622bfb571b0b783d8347182318:111,1e8e6c622bfb571b0b783d8347182318,111,112,,,470,"Trang nhiều mức Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.4 Chiến lược phân trang Nguyên tắc: Bảng quản lý trang được phân trang Ví dụ trang 2 mức l Máy 32 bít địa chỉ (232); trang kích thước 4K (212) được chia l Số hiệu trang -20 bit l Độ lệch trong trang -12 bit l Bảng trang được phân trang. Số hiệu trang được chia thành l Bảng trang ngoài (thư mục trang) - 10 bit l Độ lệch trong một thư mục trang – 10 bit l Địa chỉ truy nhập có dạng <p1, p2, d >"
1e8e6c622bfb571b0b783d8347182318:112,1e8e6c622bfb571b0b783d8347182318,112,113,,,118,Trang nhiều mức: Ví dụ trang 2 mức Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.4 Chiến lược phân trang
1e8e6c622bfb571b0b783d8347182318:113,1e8e6c622bfb571b0b783d8347182318,113,114,,,401,"Trang nhiều mức: Truy nhập bộ nhớ Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.4 Chiến lược phân trang l Khi thực hiện : Hệ thống nạp thư mục trang vào bộ nhớ l Bảng trang và trang không sử dụng không cần nạp vào bộ nhớ l Cần 3 lần truy nhập tới bộ nhớ l Vấn đề: Với hệ thống 64 bit l Trang 3, 4,... mức l Cần 4, 5,... lần truy nhập bô nhớ ⇒ chậm l Giải quyết: Bộ đệm chuyển hóa địa chỉ"
1e8e6c622bfb571b0b783d8347182318:114,1e8e6c622bfb571b0b783d8347182318,114,115,,,457,"Bộ đệm chuyển hóa địa chỉ Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2.4 Chiến lược phân trang TLB: translation look-aside buffers l Tập thanh ghi liên kết (associative registers) l Truy nhập song song l Mỗi phần tử gồm l Khóa: Page number l Giá trị: Frame number l TLB chứa đ/chỉ những trang mới truy nhập l Khi có y/cầu <p,d> l Tìm p trong TLB l Không có, tìm p trong PCB rồi đưa < p, f > vào TLB 98% truy nhập bộ nhớ được thực hiện qua TLB"
1e8e6c622bfb571b0b783d8347182318:115,1e8e6c622bfb571b0b783d8347182318,115,116,,,203,lChiến lược phân chương cố định lChiến lược phân chương động lChiến lược phân đoạn lChiến lược phân trang lChiến lược kết hợp phân đoạn-phân trang Chương 3 Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ
1e8e6c622bfb571b0b783d8347182318:116,1e8e6c622bfb571b0b783d8347182318,116,117,,,756,"Nguyên tắc Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2. 5 Chiến lược kết hợp phân đoạn-phân trang l Chương trình được biên tập theo chế độ phân đoạn l Tạo ra bảng quản lý đoạn SCB l Mỗi phần tử của bảng quản lý đoạn ứng với một đoạn, gồm 3 trường M, A, L l Mỗi đoạn được biên tập riêng theo chế độ phân trang l Tạo ra bảng quản lý trang cho từng đoạn l Địa chỉ truy nhập: bộ 3 < s, p, d > l Thực hiện truy nhập địa chỉ l STBR + s ⇒: địa chỉ phần tử s l Kiểm tra trường dấu hiệu Ms, nạp PCBs nếu cần l As + p ⇒ Địa chỉ phần tử p của PCBs l Kiểm tra trường dấu hiệu Mp, nạp PCBs nếu cần l Ghép Ap với d ra được địa chỉ cần tìm l Được sử dụng trong VXL Intel 80386, MULTICS . . . l Quản lý bộ nhớ của VXL họ intel l Chế độ thực l Chế độ bảo vệ"
1e8e6c622bfb571b0b783d8347182318:117,1e8e6c622bfb571b0b783d8347182318,117,118,,,125,Sơ đồ truy nhập bộ nhớ Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2. 5 Chiến lược kết hợp phân đoạn-phân trang
1e8e6c622bfb571b0b783d8347182318:118,1e8e6c622bfb571b0b783d8347182318,118,119,,,286,Phân đoạn M A L 0 − 2340 1 2140 5730 0 − 4264 0 − 1766 Bảng: SCB M A L 0 − 3 0 5 6 0 − 5 0 − 2 Bảng: SCB M A 0 − 1 8 0 − 0 − 0 − 0 − Bảng: PCB2 Tổng kết Chương 3: Quản lý bộ nhớ 2. Các chiến lược quản lý bộ nhớ 2. 5 Chiến lược kết hợp phân đoạn-phân trang Kết hợp Phân đoạn – Phân trang
1e8e6c622bfb571b0b783d8347182318:119,1e8e6c622bfb571b0b783d8347182318,119,120,,,111,①Tổng quan ②Các chiến lược quản lý bộ nhớ ③Bộ nhớ ảo ④Quản lý bộ nhớ trong VXL họ Intel Chương 3 Quản lý bộ nhớ
1e8e6c622bfb571b0b783d8347182318:120,1e8e6c622bfb571b0b783d8347182318,120,121,,,90,①Giới thiệu ②Các chiến lược đổi trang Chương 3: Quản lý bộ nhớ 3. Bộ nhớ ảo 3.1 Giới thiệu
1e8e6c622bfb571b0b783d8347182318:121,1e8e6c622bfb571b0b783d8347182318,121,122,,,730,"Đặt vấn đề Chương 3: Quản lý bộ nhớ 3. Bộ nhớ ảo 3.1 Giới thiệu l Câu lệnh phải nằm trong bộ nhớ khi thực hiện ! l Toàn bộ chương trình phải nằm trong bộ nhớ ? l Cấu trúc động; cấu trúc Overlays... : Nạp từng phần l Đòi hỏi sự chú ý đặc biệt từ lập trình viên ⇒Không cần thiết l Đoạn chương trình xử lý báo lỗi l Lỗi ít xảy tra, ít được thực hiện l Phần khai không dùng tới l Khai báo ma trận 100x100, sử dụng 10x 10 l Thực hiện c/trình chỉ có 1 phần nằm trong bộ nhớ cho phép l Viết chương trình trong không gian địa chỉ áo (virtual address space) l lớn tùy ý l Nhiều chương trình đồng thời tồn tại ⇒ tăng hiệu suất sử dụng CPU l Giảm yêu cầu vào/ra cho việc nạp và hoán đổi chương trình l Kích thước phần hoán đổi (swap) nhỏ hơn"
1e8e6c622bfb571b0b783d8347182318:122,1e8e6c622bfb571b0b783d8347182318,122,123,,,321,Khái niệm bộ nhớ ảo Chương 3: Quản lý bộ nhớ 3. Bộ nhớ ảo 3.1 Giới thiệu l Dùng bộ nhớ thứ cấp (HardDisk) lưu trữ phần chương trình chưa đưa vào bộ nhớ vật lý l Phân tách bộ nhớ logic (của người dùng) với bộ nhớ vật lý l Cho phép thể ánh xạ vùng nhớ logic lớn vào bộ nhớ vật lý nhỏ l Cài đặt theo l Phân trang l Phân đoạn
1e8e6c622bfb571b0b783d8347182318:123,1e8e6c622bfb571b0b783d8347182318,123,124,,,303,"Nạp từng phần của trang chương trình vào bộ nhớ Chương 3: Quản lý bộ nhớ 3. Bộ nhớ ảo 3.1 Giới thiệu l Trang của tiến trình: l bộ nhớ vật lý, l một số trang nằm trên đĩa(bộ nhớ ảo) l Biểu diễn nhờ sử dụng một bit trong bảng quản lý trang l Khi yêu cầu trang, đưa trang từ bộ nhớ thứ cấp -> bộ nhớ vật lý"
1e8e6c622bfb571b0b783d8347182318:124,1e8e6c622bfb571b0b783d8347182318,124,125,,,120,"Xử lý lỗi trang Chương 3: Quản lý bộ nhớ 3. Bộ nhớ ảo 3.1 Giới thiệu Nếu không có frames tự do, phải tiến hành đổi trang"
1e8e6c622bfb571b0b783d8347182318:125,1e8e6c622bfb571b0b783d8347182318,125,126,,,233,Đổi trang Chương 3: Quản lý bộ nhớ 3. Bộ nhớ ảo 3.1 Giới thiệu ① Xác định vị trí trang logic trên đĩa ② Lựa chọn trang vật lý l Ghi ra đĩa l Sửa lại bit valid- invalid ③ Nạp trang logic vào trang vật lý được chọn ④ Restart tiến trình
1e8e6c622bfb571b0b783d8347182318:126,1e8e6c622bfb571b0b783d8347182318,126,127,,,104,①Giới thiệu ②Các chiến lược đổi trang Chương 3: Quản lý bộ nhớ 3. Bộ nhớ ảo 3.2 Các chiến lược đổi trang
1e8e6c622bfb571b0b783d8347182318:127,1e8e6c622bfb571b0b783d8347182318,127,128,,,367,Các chiến lược Chương 3: Quản lý bộ nhớ 3. Bộ nhớ ảo 3.2 Các chiến lược đổi trang l FIFO (First In First Out): Vào trước ra trước l OPT/MIN: Thuật toán thay thế trang tối ưu l LRU (Least Recently Used): Trang có lần sử dụng cuối cách đây lâu nhất l LFU (Least Frequently used):Tần xuất sử dụng thấp nhất l MFU (Most Frequently used): Tần xuất sử dụng cao nhất l . . .
1e8e6c622bfb571b0b783d8347182318:128,1e8e6c622bfb571b0b783d8347182318,128,129,,,485,"Ví dụ FIFO Chương 3: Quản lý bộ nhớ 3. Bộ nhớ ảo 3.2 Các chiến lược đổi trang Nhận xét l Hiệu quả khi chương trình có cấu trúc tuyến tính. l Kém hiểu quả khi chương trình theo nguyên tắc lập trình cấu trúc l Đơn giản dễ thực hiện l Dùng hàng đợi lưu các trang của chương trình trong bộ nhớ l Chèn ở cuối hàng, Thay thế trang ở đầu hàng l Tăng trang vật lý, không đảm bảo giảm số lần gặp lỗi trang l Dãy truy nhập: 1 2 3 4 1 2 5 1 2 3 4 5 l 3 frames: 9 lỗi trang; 4 frames: 10 lỗi trang"
1e8e6c622bfb571b0b783d8347182318:129,1e8e6c622bfb571b0b783d8347182318,129,130,,,213,OPT OPT Chương 3: Quản lý bộ nhớ 3. Bộ nhớ ảo 3.2 Các chiến lược đổi trang Nguyên tắc: Đưa ra trang có lần sử dụng tiếp theo cách xa nhất l Số lần gặp lỗi trang ít nhất l Khó dự báo được diễn biến của chương trình
1e8e6c622bfb571b0b783d8347182318:130,1e8e6c622bfb571b0b783d8347182318,130,131,,,416,L ✞ RU LRU Chương 3: Quản lý bộ nhớ 3. Bộ nhớ ảo 3.2 Các chiến lược đổi trang Nguyên tắc: Đưa ra trang có lần sử dụng cuối cách xa nhất l Hiệu quả cho chiến lược thay thế trang l Đảm bảo giảm số lỗi trang khi tăng số trang vật lý l Tập các trang trong bộ nhớ có n frames luôn là tập con của các trang trong bộ nhớ có n + 1 frames l Y/cầu sự trợ giúp kỹ thuật để chỉ ra thời điểm truy nhập cuối l Cài đặt như thế nào?
1e8e6c622bfb571b0b783d8347182318:131,1e8e6c622bfb571b0b783d8347182318,131,132,,,696,"LRU: Cài đặt Chương 3: Quản lý bộ nhớ 3. Bộ nhớ ảo 3.2 Các chiến lược đổi trang l Bộ đếm l Thêm một trường ghi thời điểm truy nhập vào mỗi phần tử của PCB l Thêm vào khối điều khiển (C.U) đồng hồ/bộ đếm l Khi có yêu cầu truy nhâp trang l Tăng bộ đếm l Chép nội dung bộ đếm vào trường thời điểm truy nhập tại phần tử tương ứng trong PCB l Cần có thủ tục cập nhật PCB (ghi vào trường thời điểm) và thủ tục tìm kiếm trang có giá trị trường thời điểm nhỏ nhất l Hiện tượng tràn số !? l Dãy số (Stack) l Dùng dãy số ghi số trang l Truy nhập tới một trang, cho phần tử tương ứng lên đầu dãy l Thay thế trang: Phần tử cuối dãy l Thường cài đặt dưới dạng DSLK 2 chiều l 4 phép gán con trỏ ⇒ tốn thời gian"
1e8e6c622bfb571b0b783d8347182318:132,1e8e6c622bfb571b0b783d8347182318,132,133,,,487,"Thuật toán dựa trên bộ đếm Chương 3: Quản lý bộ nhớ 3. Bộ nhớ ảo 3.2 Các chiến lược đổi trang Sử dụng bộ đếm (một trường của PCB) ghi nhận số lần truy nhập tới trang l LFU: Trang có bộ đếm nhỏ nhất bị thay thế l Trang truy nhập nhiều đến l Trang quan trọng ⇒ hợp lý l Trang khởi tạo, chỉ được dùng ở giai đoạn đầu ⇒ không hợp lý ⇒Dịch bộ đếm một bit (chia đôi) theo thời gian l MFU: Trang có bộ đếm lớn nhất l Trang có bộ đếm nhỏ nhất, vừa mới được nạp vào và vẫn chưa được sử dụng nhiều"
1e8e6c622bfb571b0b783d8347182318:133,1e8e6c622bfb571b0b783d8347182318,133,134,,,111,①Tổng quan ②Các chiến lược quản lý bộ nhớ ③Bộ nhớ ảo ④Quản lý bộ nhớ trong VXL họ Intel Chương 3 Quản lý bộ nhớ
1e8e6c622bfb571b0b783d8347182318:134,1e8e6c622bfb571b0b783d8347182318,134,135,,,715,"Các chế độ Chương 3: Quản lý bộ nhớ 4. Quản lý bộ nhớ trong vi xử lý họ Intel l Intel 8086, 8088 l Chỉ có một chế độ quản lý: Chế độ thực (Real Mode) l Quản lý vùng nhớ lên đến 1MB ( 20bit ) l Xác định địa chỉ ô nhớ bằng 2 giá trị 16 bit: Segment, Offset l Thanh ghi đoạn: CS, SS, DS, ES, l Thanh ghi độ lệch: IP, SP, BP... l Địa chỉ vật lý: Seg SHL 4 + Ofs l Intel 80286 l Chế độ thực, tương thích với 8086 l Chế độ bảo vệ (Protected mode), l Sử dụng phương pháp phân đoạn l Khai thác được bộ nhớ vật lý 16M (24bit ) l Intel 80386, Intel 80486, Pentium,.. l Chế độ thực, tương thích với 8086 l Chế độ bảo vệ :Kết hợp phân đoạn, phân trang l Chế độ ảo (Virtual mode) l Cho phép thực hiện mã 8086 trong chế độ bảo vệ"
1e8e6c622bfb571b0b783d8347182318:135,1e8e6c622bfb571b0b783d8347182318,135,136,,,113,"Chế độ bảo vệ trong Intel 386, 486, Pentium,.. Chương 3: Quản lý bộ nhớ 4. Quản lý bộ nhớ trong vi xử lý họ Intel"
1e8e6c622bfb571b0b783d8347182318:136,1e8e6c622bfb571b0b783d8347182318,136,137,,,410,2 Kết luận Chương 3: Quản lý bộ nhớ ① Tổng quan 1. Ví dụ 2. Bộ nhớ và chương trình 3. Liên kết địa chỉ 4. Các cấu trúc chương trình ② Các chiến lược quản lý bộ nhớ 1. Chiến lược phân chương cố định 2. Chiến lược phân chương động 3. Chiến lược phân đoạn 4. Chiến lược phân trang 5. Chiến lược kết hợp phân đoạn-phân trang ③ Bộ nhớ ảo 1. Giới thiệu 2. Các chiến lược đổi trang ④ Quản lý bộ nhớ trong VXL họ Intel
