chunk_id,document_id,order_index,page,end_page,section,text_len,text
ea73ad6304ed438f7e7d4c59ddd227a1:0,ea73ad6304ed438f7e7d4c59ddd227a1,0,1,,,143,Hệ Điều Hành (Nguyên lý các hệ điều hành) Đỗ Quốc Huy huydq@soict.hust.edu.vn Bộ môn Khoa Học Máy Tính Viện Công Nghệ Thông Tin và Truyền Thông
ea73ad6304ed438f7e7d4c59ddd227a1:1,ea73ad6304ed438f7e7d4c59ddd227a1,1,2,,,51,① Định nghĩa tiến trình Chương 2 Quản lý tiến trình
ea73ad6304ed438f7e7d4c59ddd227a1:2,ea73ad6304ed438f7e7d4c59ddd227a1,2,3,,,747,"Tiến trình (nhắc lại) lKhi chương trình đang thực hiện l Được cung cấp tài nguyên (CPU, bộ nhớ, thiết bị vào/ra. . .) để hoàn thành công việc l Tài nguyên được cấp khi: l Bắt đầu chương trình l Trong khi chương trình đang thực hiện lGọi là tiến trình (process) lHệ thống bao gồm tập các tiến trình thực hiện đồng thời l Tiến trình hệ điều hành Thực hiện mã lệnh hệ thống l Tiến trình người dùng Thực hiện mã lệnh người dùng lTiến trình có thể chứa một hoặc nhiều tiểu trình lTrách nhiệm của Hệ điều hành: l Đảm bảo họat động của tiến trình và tiểu trình (luồng) l Tạo/xóa tiến trình (người dùng, hệ thống) l Điều phối tiến trình l Cung cấp cơ chế đồng bộ, truyền thông và ngăn ngừa tình trạng bế tắc giữa các tiến trình Chương 2 Quản lý tiến trình"
ea73ad6304ed438f7e7d4c59ddd227a1:3,ea73ad6304ed438f7e7d4c59ddd227a1,3,4,,,138,Chương 2 Quản lí tiến trình ① Tiến trình ② Luồng (Thread) ③ Điều phối CPU ④ Tài nguyên găng và điều độ tiến trình ⑤ Bế tắc và xử lý bế tắc
ea73ad6304ed438f7e7d4c59ddd227a1:4,ea73ad6304ed438f7e7d4c59ddd227a1,4,5,,,208,Chương 2 Quản lí tiến trình 1. Tiến trình 1.1. Khái niệm tiến trình lKhái niệm tiến trình lĐiều phối tiến trình (Process Scheduling) lThao tác trên tiến trình lHợp tác tiến trình lTruyền thông liên tiến trình
ea73ad6304ed438f7e7d4c59ddd227a1:5,ea73ad6304ed438f7e7d4c59ddd227a1,5,6,,,554,"Chương 2 Quản lí tiến trình 1. Tiến trình 1.1. Khái niệm tiến trình * Trạng thái hệ thống l Vi xử lý: Giá trị các thanh ghi l Bộ nhớ: Nội dung các ô nhớ l Thiết bị ngoại vi: Trạng thái thiết bị l Thực hiện chương trình ⇒Trạng thái hệ thống thay đổi l Thay đổi rời rạc, theo từng câu lệnh được thực hiện l Tiến trình là một dãy thay đổi trạng thái của hệ thống l Xuất phát từ một trạng thái ban đầu l Chuyển từ trạng thái này sang trạng thái khác được thực hiện theo yêu cầu nằm trong chương trình của người sử dụng Tiến trình là sự thực hiện chương trình"
ea73ad6304ed438f7e7d4c59ddd227a1:6,ea73ad6304ed438f7e7d4c59ddd227a1,6,7,,,837,"Chương 2 Quản lí tiến trình 1. Tiến trình 1.1. Khái niệm tiến trình l Chương trình: thực thể thụ động (nội dung file trên đĩa) l Mã chương trình: Lệnh máy (CD2190EA...) l Dữ liệu: l Biến được lưu trữ và sử dụng trong bộ nhớ l Biến toàn cục l Biến được cung cấp động (malloc, new,..) l Biến stack (tham số hàm, biến cục bộ) l Thư viện liên kết động (DLL) l Không được dịch & liên kết cùng với chương trình Khi chương trình đang thực hiện, tài nguyên tối thiểu cần có l Bộ nhớ cho mã chương trình và dữ liệu l Các thanh ghi của VXL phục vụ cho quá trình thực hiện l Tiến trình: thực thể chủ động (bộ đếm lệnh, tập tài nguyên) Một chương trình có thể l Chỉ là một phần của trạng thái tiến trình l Một chương trình, nhiều tiến trình( bộ dữ liệu khác nhau) VD: gcc hello.c || gcc baitap.c l Gọi tới nhiều tiến trình Tiến trình >< chương trình"
ea73ad6304ed438f7e7d4c59ddd227a1:7,ea73ad6304ed438f7e7d4c59ddd227a1,7,8,,,102,Chương 2 Quản lí tiến trình 1. Tiến trình 1.1. Khái niệm tiến trình Dịch và thực hiên một chương trình
ea73ad6304ed438f7e7d4c59ddd227a1:8,ea73ad6304ed438f7e7d4c59ddd227a1,8,9,,,781,"Chương 2 Quản lí tiến trình 1. Tiến trình 1.1. Khái niệm tiến trình l Hệ điều hành tạo một tiến trình và phân phối vùng nhớ cho nó l Bộ thực hiện (loader/exec) l Đọc và dịch (interprets) file thực thi (header file) l Thiết lập không gian địa chỉ cho tiến trình để chứa mã lệnh và dữ liệu từ file thực thi l Đặt các tham số dòng lệnh, biến môi trường (argc, argv, envp) vào stack l Thiết lập các thanh ghi của VXL tới các giá trị thích hợp và gọi hàm ""_start()"" (hàm của hệ điều hành) l Chương trình bắt đầu thực hiện tại ""_start()"". Hàm này gọi tới hàm main()(hàm của chương trình) ⇒""Tiến trình"" đang thực hiện, không còn đề cập đến ""chương trình"" nữa l Khi hàm main() kết thúc, OS gọi tới hàm ""_exit()"" để hủy bỏ tiến trình và thu hồi tài nguyên Dịch và thực hiên một chương trình"
ea73ad6304ed438f7e7d4c59ddd227a1:9,ea73ad6304ed438f7e7d4c59ddd227a1,9,10,,,549,"Chương 2 Quản lí tiến trình 1. Tiến trình 1.1. Khái niệm tiến trình Khi thực hiện, tiến trình thay đổi trạng thái l Khởi tạo (New) Tiến trình đang được khởi tạo l Sẵn sàng (Ready) Tiến trình đang đợi sử dụng processor vật lý l Thực hiện (Running) Các câu lệnh của tiến trình đang được thực hiện l Chờ đợi (Waiting) Tiến trình đang chờ đợi một sự kiện nào đó xuất hiện (sự hoàn thành thao tác vào/ra) l Kết thúc (Terminated) Tiến trình thực hiện xong Trạng thái của tiến trình là một phần trong hoạt động hiện tại của tiến trình Trạng thái tiến trình"
ea73ad6304ed438f7e7d4c59ddd227a1:10,ea73ad6304ed438f7e7d4c59ddd227a1,10,11,,,267,Chương 2 Quản lí tiến trình 1. Tiến trình 1.1. Khái niệm tiến trình Lưu đồ thay đổi trạng thái tiến trình (Silberschatz 2002) Hệ thống có một processor l Có duy nhất một tiến trình ở trạng thái thực hiện l Có thể có nhiều tiến trình ở trạng thái chờ đợi hoặc sẵn sàng
ea73ad6304ed438f7e7d4c59ddd227a1:11,ea73ad6304ed438f7e7d4c59ddd227a1,11,12,,,488,Chương 2 Quản lí tiến trình 1. Tiến trình 1.1. Khái niệm tiến trình Khối điều khiển tiến trình (PCB: Process Control Block) l Trạng thái tiến trình l Bộ đếm lệnh l Các thanh ghi của CPU l Thông tin dùng để điều phối tiến trình l Thông tin quản lý bộ nhớ l Thông tin tài nguyên có thể sử dụng l Thông tin thống kê l Con trỏ tới một PCB khác l . . . l Mỗi tiến trình được thể hiện trong hệ thống bởi một khối điều khiển tiến trình l PCB: cấu trúc thông tin cho phép xác định duy nhất một tt
ea73ad6304ed438f7e7d4c59ddd227a1:12,ea73ad6304ed438f7e7d4c59ddd227a1,12,13,,,88,Chương 2 Quản lí tiến trình 1. Tiến trình 1.1. Khái niệm tiến trình Danh sách tiến trình
ea73ad6304ed438f7e7d4c59ddd227a1:13,ea73ad6304ed438f7e7d4c59ddd227a1,13,14,,,365,Chương 2 Quản lí tiến trình 1. Tiến trình 1.1. Khái niệm tiến trình Tiến trình đơn luồng và tiến trình đa luồng l Tiến trình đơn luồng : Là chương trình thực hiện chỉ một luồng thực thi ⇒ Cho phép thực hiện chỉ một nhiệm vụ tại một thời điểm l Tiến trình đa luồng : Là tiến trình có nhiều luồng thực thi ⇒ Cho phép thực hiện nhiều hơn một nhiệm vụ tại một thời điểm
ea73ad6304ed438f7e7d4c59ddd227a1:14,ea73ad6304ed438f7e7d4c59ddd227a1,14,15,,,213,Chương 2 Quản lí tiến trình 1. Tiến trình 1.1. Điều phối tiến trình * Khái niệm tiến trình * Điều phối tiến trình (Process Scheduling) * Thao tác trên tiến trình * Hợp tác tiến trình * Truyền thông liên tiến trình
ea73ad6304ed438f7e7d4c59ddd227a1:15,ea73ad6304ed438f7e7d4c59ddd227a1,15,16,,,341,Chương 2 Quản lí tiến trình 1. Tiến trình 1.2. Điều phối tiến trình Giới thiệu Mục đích Sử dụng tối đa thời gian của CPU ⇒ Cần có nhiều tiến trình trong hệ thống Vấn đề Luân chuyển CPU giữa các tiến trình ⇒ Phải có hàng đợi cho các tiến trình Hệ thống một processor ⇒ Một tiến trình thực hiện ⇒ Các tiến trình khác phải đợi tới khi CPU tự do
ea73ad6304ed438f7e7d4c59ddd227a1:16,ea73ad6304ed438f7e7d4c59ddd227a1,16,17,,,390,"Chương 2 Quản lí tiến trình 1. Tiến trình 1.2. Điều phối tiến trình Các hàng đợi tiến trình I Hệ thống có nhiều hàng đợi dành cho tiến trình l Job-queue Tập các tiến trình trong hệ thống l Ready-Queue Tập các tiến trình tồn tại trong bộ nhớ, đang sẵn sàng và chờ đợi để được thực hiện l Device queues Tập các tiến trình đang chờ đợi một thiết bị vào ra. Phân biệt hàng đợi cho từng thiết bị"
ea73ad6304ed438f7e7d4c59ddd227a1:17,ea73ad6304ed438f7e7d4c59ddd227a1,17,18,,,247,"Chương 2 Quản lí tiến trình 1. Tiến trình 1.2. Điều phối tiến trình Các hàng đợi tiến trình II l Các tiến trình di chuyển giữa hàng đợi khác nhau l Tiến trình mới tạo, được đặt trong hàng đợi sẵn sàng, và đợi cho tới khi được lựa chọn để thực hiện"
ea73ad6304ed438f7e7d4c59ddd227a1:18,ea73ad6304ed438f7e7d4c59ddd227a1,18,19,,,633,"Chương 2 Quản lí tiến trình 1. Tiến trình 1.2. Điều phối tiến trình Các hàng đợi tiến trình III l Tiến trình đã được chọn và đang thực hiên ① Đưa ra một yêu cầu vào ra: đợi trong một hàng đợi thiết bị ② Tạo một tiến trình con và đợi tiến trình con kết thúc ③ Hết thời gian sử dụng CPU, phải quay lại hàng đợi sẵn sàng l Trường hợp (1&2) sau khi sự kiện chờ đợi hoàn thành, l Tiến trình sẽ chuyển từ trạng thái đợi sang trạng thái sẵn sàng l Tiến trình quay lại hàng đợi sẵn sàng l Tiến trình tiếp tục chu kỳ (sẵn sàng, thực hiện, chờ đợi) cho tới khi kết thúc l Xóa khỏi tất cả các hàng đợi l PCB và tài nguyên đã cấp được giải phóng"
ea73ad6304ed438f7e7d4c59ddd227a1:19,ea73ad6304ed438f7e7d4c59ddd227a1,19,20,,,244,Chương 2 Quản lí tiến trình 1. Tiến trình 1.2. Điều phối tiến trình Bộ điều phối (Scheduler) Lựa chọn tiến trình trong các hàng đợi l Điều phối công việc (Job scheduler; Long-term scheduler) l Điều phối CPU (CPU scheduler; Short-term scheduler)
ea73ad6304ed438f7e7d4c59ddd227a1:20,ea73ad6304ed438f7e7d4c59ddd227a1,20,21,,,711,"Chương 2 Quản lí tiến trình 1. Tiến trình 1.2. Điều phối tiến trình Điều phối công việc l Chọn các tiến trình từ hàng đợi tiến trình được lưu trong các vùng đệm (đĩa từ) và đưa vào bộ nhớ để thực hiện l Thực hiện không thường xuyên (đơn vị giây/phút) l Điều khiển mức độ đa chương trình (số t/trình trong bộ nhớ) l Khi mức độ đa chương trình ổn định, điều phối công việc được gọi chỉ khi có tiến trình rời khỏi hệ thống l Vấn đề lựa chọn công việc l Tiến trình thiên về vào/ra: sử dụng ít thời gian CPU l Tiến trình thiên về tính toán: sử dụng nhiều thời gian CPU l Cần lựa chọn lẫn cả 2 loại tiến trình ⇒ tt vào ra: hàng đợi sẵn sàng rỗng, lãng phí CPU ⇒ tt tính toán: hàng đợi thiết bị rỗng, lãng phí thiết bị"
ea73ad6304ed438f7e7d4c59ddd227a1:21,ea73ad6304ed438f7e7d4c59ddd227a1,21,22,,,668,"Chương 2 Quản lí tiến trình 1. Tiến trình 1.2. Điều phối tiến trình Điều phối CPU l Lựa chọn một tiến trình từ hàng đợi các tiến trình đang sẵn sàng thực hiện và phân phối CPU cho nó l Được thực hiện thường xuyên (VD: 100ms/lần) l Tiến trình thực hiện vài ms rồi thực hiện vào ra l Lựa chọn tiến trình mới, đang sẵn sàng l Phải thực hiện nhanh l 10ms để quyết định ⇒10/(110)=9% thời gian CPU lãng phí l Vấn đề luân chuyển CPU từ tiến trình này tới tiến trình khác l Phải lưu trạng thái của tiến trình cũ (PCB) và khôi phục trạng thái cho tiến trình mới l Thời gian luân chuyển là lãng phí l Có thể được hỗ trợ bởi phần cứng l Vấn đề lựa chọn tiến trình (điều phối CPU)"
ea73ad6304ed438f7e7d4c59ddd227a1:22,ea73ad6304ed438f7e7d4c59ddd227a1,22,23,,,331,"Chương 2 Quản lí tiến trình 1. Tiến trình 1.2. Điều phối tiến trình Hoán chuyển tiến trình (Medium-term scheduler) l Nhiệm vụ l Đưa t/trình ra khỏi bộ nhớ (làm giảm mức độ đa chương trình) l Sau đó đưa tiến trình quay trở lại (có thể ở vị trí khác) và tiếp tục thực hiện l Mục đích: Giải phóng vùng nhớ, tạo vùng nhớ tự do rộng hơn"
ea73ad6304ed438f7e7d4c59ddd227a1:23,ea73ad6304ed438f7e7d4c59ddd227a1,23,24,,,359,Chương 2 Quản lí tiến trình 1. Tiến trình 1.2. Điều phối tiến trình Chuyển ngữ cảnh (context switch) l Chuyển CPU từ tiến trình này sang tiến trình khác (hoán đổi tiến trình thực hiện) l Thực hiện khi xuất hiện tín hiệu ngắt (ngắt thời gian) hoặc tiến trình đưa ra lời gọi hệ thống (thực hiện và ra) l Lưu đồ của chuyển CPU giữa các t/trình(Silberschatz 2002)
ea73ad6304ed438f7e7d4c59ddd227a1:24,ea73ad6304ed438f7e7d4c59ddd227a1,24,25,,,217,Chương 2 Quản lí tiến trình 1. Tiến trình 1.3. Thao tác trên tiến trình * Khái niệm tiến trình * Điều phối tiến trình (Process Scheduling) * Thao tác trên tiến trình * Hợp tác tiến trình * Truyền thông liên tiến trình
ea73ad6304ed438f7e7d4c59ddd227a1:25,ea73ad6304ed438f7e7d4c59ddd227a1,25,26,,,135,Chương 2 Quản lí tiến trình 1. Tiến trình 1.3. Thao tác trên tiến trình l Tạo tiến trình l Kết thúc tiến trình Thao tác trên tiến trình
ea73ad6304ed438f7e7d4c59ddd227a1:26,ea73ad6304ed438f7e7d4c59ddd227a1,26,27,,,675,"Chương 2 Quản lí tiến trình 1. Tiến trình 1.3. Thao tác trên tiến trình l Tiến trình có thể tạo nhiều tiến trình mới cùng hoạt động (CreateProcess(), fork()) l Tiến trình tạo: tiến trình cha l Tiến trình được tạo: tiến trình con l Tiến trình con có thể tạo tiến trình con khác ⇒Cây tiến trình l Vấn đề phân phối tài nguyên l Tiến trình con lấy tài nguyên từ hệ điều hành l Tiến trình con lấy tài nguyên từ tiến trình cha l Tất cả các tài nguyên l Một phần tài nguyên của tiến trình cha (ngăn ngừa việc tạo quá nhiều tiến trình con) l Vấn đề thực hiện l Tiến trình cha tiếp tục thực hiện đồng thời với tiến trình con l Tiến trình cha đợi tiến trình con kết thúc Tạo tiến trình"
ea73ad6304ed438f7e7d4c59ddd227a1:27,ea73ad6304ed438f7e7d4c59ddd227a1,27,28,,,780,Chương 2 Quản lí tiến trình 1. Tiến trình 1.3. Thao tác trên tiến trình l Hoàn thành câu lệnh cuối và yêu cầu HĐH xóa nó (exit) l Gửi trả dữ liệu tới tiến trình cha l Các tài nguyên đã cung cấp được trả lại hệ thống l Tiến trình cha có thể kết thúc sự thực hiện của tiến trình con l Tiến trình cha phải biết định danh tiến trình con ⇒ tiến trình con phải gửi định danh cho tiến trình cha khi được khởi tạo l Sử dụng lời gọi hệ thống (abort) l Tiến trình cha kết thúc tiến trình con khi l Tiến trình con sử dụng vượt quá mức tài nguyên được cấp l Nhiệm vụ cung cấp cho tiến trình con không còn cần thiết nữa l Tiến trình cha kết thúc và hệ điều hành không cho phép tiến trình con tồn tại khi tiến trình cha kết thúc ⇒Cascading termination. VD: kết thúc hệ thống Kết thúc tiến trình
ea73ad6304ed438f7e7d4c59ddd227a1:28,ea73ad6304ed438f7e7d4c59ddd227a1,28,29,,,836,"Chương 2 Quản lí tiến trình 1. Tiến trình 1.3. Thao tác trên tiến trình l CreateProcess(. . .) l LPCTSTR Tên của chương trình được thực hiện l LPTSTR Tham số dòng lệnh l LPSECURITY_ATTRIBUTES Thuộc tính an ninh t/trình l LPSECURITY_ATTRIBUTES Thuộc tính an ninh luồng l BOOL Cho phép kế thừa các thẻ thiết bị (TRUE/FALSE) l DWORD Cờ tạo tiến trình (VD CREATE_NEW_CONSOLE) l LPVOID Trỏ tới khối môi trường l LPCTSTR Đường dẫn đầy đủ đến chương trình l LPSTARTUPINFO Cấu trúc thông tin cho tiến trình mới l LPPROCESS_INFORMATION Thông tin về tiến trình mới l TerminateProcess(HANDLE hProcess, UINT uExitCode) l hProcess Thẻ tiến trình bị kết thúc đóng l uExitCode Mã kết thúc tiến trình l WaitForSingleObject(HANDLE hHandle, DWORD dwMs) l hHandle Thẻ đối tượng l dwMs Thời gian chờ đợi (INFINITE) Một số hàm với tiến trình trong WIN32 API"
ea73ad6304ed438f7e7d4c59ddd227a1:29,ea73ad6304ed438f7e7d4c59ddd227a1,29,30,,,211,Chương 2 Quản lí tiến trình 1. Tiến trình 1.4. Hợp tác tiến trình * Khái niệm tiến trình * Điều phối tiến trình (Process Scheduling) * Thao tác trên tiến trình * Hợp tác tiến trình * Truyền thông liên tiến trình
ea73ad6304ed438f7e7d4c59ddd227a1:30,ea73ad6304ed438f7e7d4c59ddd227a1,30,31,,,211,Chương 2 Quản lí tiến trình 1. Tiến trình 1.4. Hợp tác tiến trình * Khái niệm tiến trình * Điều phối tiến trình (Process Scheduling) * Thao tác trên tiến trình * Hợp tác tiến trình * Truyền thông liên tiến trình
ea73ad6304ed438f7e7d4c59ddd227a1:31,ea73ad6304ed438f7e7d4c59ddd227a1,31,32,,,716,Chương 2 Quản lí tiến trình 1. Tiến trình 1.4. Hợp tác tiến trình l Các tiến trình tuần tự l Điểm bắt đầu của tiến trình này nằm sau điểm kết thúc của tiến trình kia l Các tiến trình song song l Điểm bắt đầu của tiến trình này nằm giữa điểm bắt đầu và kết thúc của tiến trình kia l Độc lập: Không ảnh hưởng tới hoặc bị ảnh hưởng bởi tiến trình khác đang thực hiện trong hệ thống l Có hợp tác: Ảnh hưởng tới hoặc chịu ảnh hưởng bởi tiến trình khác đang thực hiện trong hệ thống l Hợp tác tiến trình nhằm l Chia sẻ thông tin l Tăng tốc độ tính toán: l Module hóa l Tiện dụng l Hợp tác tiến trình đòi hỏi cơ chế cho phép l Truyền thông giữa các tiến trình l Đồng bộ hóa hoạt động của các tiến trình Phân loại tiến trình
ea73ad6304ed438f7e7d4c59ddd227a1:32,ea73ad6304ed438f7e7d4c59ddd227a1,32,33,,,526,"• Hệ thống gồm 2 tiến trình • Producer sản xuất ra các sản phẩm • Consumer tiêu thụ các sản phẩm được sản xuất ra • Ứng dụng • Chương trình in (producer) sản xuất ra các ký tự được tiêu thụ bởi bộ điều khiển máy in (consumer) • Trình dịch (producer) sản xuất ra mã hợp ngữ, trình hợp ngữ (consumer/producer) tiêu thụ mã hợp ngữ rồi sản xuất ra module đối tượng được bộ thực hiện (consumer) tiêu thụ Chương 2 Quản lí tiến trình 1. Tiến trình 1.4. Hợp tác tiến trình Bài toán người sản xuất (producer)-người tiêu thụ(consumer) I"
ea73ad6304ed438f7e7d4c59ddd227a1:33,ea73ad6304ed438f7e7d4c59ddd227a1,33,34,,,724,"• Producer và Consumer hoạt động đồng thời Sử dụng vùng đệm dùng chung (Buffer) chứa sản phẩm được điền vào bởi producer và được lấy ra bởi consumer • IN Vị trí trống kế tiếp trong vùng đệm; • OUT Vị trí đầy đầu tiên trong vùng đệm. • Counter Số sản phẩm trong vùng đệm • Producer và Consumer phải đồng bộ • Consumer không cố gắng tiêu thụ một sản phẩm chưa được sản xuất • Vùng đệm dung lượng vô hạn • Khi Buffer rỗng, Consumer phải đợi • Producer không phải đợi khi đặt sản phẩm vào buffer • Vùng đệm dung lượng hữu hạn • Khi Buffer rỗng, Consumer phải đợi • Producer phải đợi nếu vùng đệm đầy Chương 2 Quản lí tiến trình 1. Tiến trình 1.4. Hợp tác tiến trình Bài toán người sản xuất (producer)-người tiêu thụ(consumer) II"
ea73ad6304ed438f7e7d4c59ddd227a1:34,ea73ad6304ed438f7e7d4c59ddd227a1,34,35,,,465,while(1) { /*produce an item in nextProduced*/ while (Counter == BUFFER_SIZE) ; /*do nothing*/ Buffer[IN] = nextProduced; IN = (IN + 1) % BUFFER_SIZE; Counter++; } while(1){ while(Counter == 0) ; /*do nothing*/ nextConsumed = Buffer[OUT]; OUT =(OUT + 1) % BUFFER_SIZE; Counter--; /*consume the item in nextConsumed*/ } Chương 2 Quản lí tiến trình 1. Tiến trình 1.4. Hợp tác tiến trình Bài toán người sản xuất (producer)-người tiêu thụ(consumer) II Producer Consumer
ea73ad6304ed438f7e7d4c59ddd227a1:35,ea73ad6304ed438f7e7d4c59ddd227a1,35,36,,,221,Chương 2 Quản lí tiến trình 1. Tiến trình 1.5. Truyền thông liên tiến trình * Khái niệm tiến trình * Điều phối tiến trình (Process Scheduling) * Thao tác trên tiến trình * Hợp tác tiến trình * Truyền thông liên tiến trình
ea73ad6304ed438f7e7d4c59ddd227a1:36,ea73ad6304ed438f7e7d4c59ddd227a1,36,37,,,574,Chương 2 Quản lí tiến trình 1. Tiến trình 1.5. Truyền thông liên tiến trình • Dùng mô hình bộ nhớ phân chia • Các tiến trình chia sẻ vùng nhớ chính • Mã cài đặt được viết tường minh bởi người lập trình ứng dụng • Ví dụ: Bài toán Producer-Consumer • Dùng mô hình truyền thông liên tiến trình (Interprocess communication) • Là cơ chế cho phép các tiến trình truyền thông và đồ ng bộ các hoạt động • Thường được sử dụng trong các hệ phân tán khi các tiến trình truyền thông nằm trên các máy khác nhau (chat) • Đảm bảo bởi hệ thống truyền thông điệp Trao đổi giữa các tiến trình
ea73ad6304ed438f7e7d4c59ddd227a1:37,ea73ad6304ed438f7e7d4c59ddd227a1,37,38,,,575,"Chương 2 Quản lí tiến trình 1. Tiến trình 1.5. Truyền thông liên tiến trình • Cho phép các tiến trình trao đổi với nhau không qua sử dụng các biến phân chia • Yêu cầu 2 thao tác cơ bản • Send (msg) Các msg có kích thước cố định hoặc thay đổi • Cố định : dễ cài đặt mức hệ thống, nhiệm vụ lập trình khó • Thay đổi: cài đặt mức hệ thống phức tạp, lập trình đơn giản • Receive (msg) • Nếu 2 tiến trình P và Q muốn trao đổi, chúng cần • Thiết lập một liên kết truyền thông (vật lý/logic) giữa chúng • Trao đổi các messages nhờ các thao tác send/receive Hệ thống truyền thông điệp"
ea73ad6304ed438f7e7d4c59ddd227a1:38,ea73ad6304ed438f7e7d4c59ddd227a1,38,39,,,374,Chương 2 Quản lí tiến trình 1. Tiến trình 1.5. Truyền thông liên tiến trình lCác vấn đề cài đặt l Các liên kết được thiết lập như thế nào? l Một liên kết có thể dùng cho nhiều hơn 2 tiến trình? l Bao nhiêu liên kết có thể tồn tại giữa mọi cặp tiến trình? l Kích thước thông báo mà liên kết chấp nhận cố định/thay đổi? l Liên kết một hay hai chiều? Hệ thống truyền thông điệp
ea73ad6304ed438f7e7d4c59ddd227a1:39,ea73ad6304ed438f7e7d4c59ddd227a1,39,40,,,515,"Chương 2 Quản lí tiến trình 1. Tiến trình 1.5. Truyền thông liên tiến trình lCác tiến trình phải gọi tên tiến trình nhận/gửi một cách tường minh l send (P, message) - gửi một thống báo tới tiến trình P l receive(Q, message) - Nhận một thông báo từ tiến trình Q lTính chất của liên kết truyền thông l Các liên kết được thiết lập tự động l Một liên kết gắn chỉ với cặp tiến trình truyền thông l Chỉ tồn tại một liên kết giữa cặp tiến trình l Liên kết có thể là một chiều, nhưng thường hai chiều Truyền thông trực tiếp"
ea73ad6304ed438f7e7d4c59ddd227a1:40,ea73ad6304ed438f7e7d4c59ddd227a1,40,41,,,689,"Chương 2 Quản lí tiến trình 1. Tiến trình 1.5. Truyền thông liên tiến trình l Các thông điệp được gửi/nhận tới/từ các hòm thư (mailboxes), cổng (ports) l Mỗi hòm thư có định danh duy nhất l Các tiến trình có thể trao đổi nếu chúng dùng chung hòm thư l Tính chất các liên kết l Các liên kết được thiết lập chỉ khi các tiến trình dùng chung hòm thư l Một liên kết có thể được gắn với nhiều tiến trình l Mỗi cặp tiến trình có thể dùng chung nhiều liên kết truyền thông l Liên kết có thể một hay hai chiều l Các thao tác l Tạo hòm thư l Gửi/nhận thông báo qua hòm thư l send(A, msg): Gửi một msg tới hòm thư A l receive(A, msg): Nhận một msg từ hòm thư A lHủy bỏ hòm thư Truyền thông gián tiếp"
ea73ad6304ed438f7e7d4c59ddd227a1:41,ea73ad6304ed438f7e7d4c59ddd227a1,41,42,,,671,"Chương 2 Quản lí tiến trình 1. Tiến trình 1.5. Truyền thông liên tiến trình l Truyền thông điệp có thể phải chờ đợi (blocking), hoặc không chờ đợi (non blocking) l Blocking Truyền thông đồng bộ l Non-blocking Truyền thông không đồng bộ l Các thủ tục send() và receive() có thể bị chờ đợi hoặc không chờ đợi l Blocking send Tiến trình gửi thông báo và đợi cho tới khi msg được nhận bởi tiến trình nhận hoặc bởi hòm thư l Non blockking send Tiến trình gửi thông báo và tiếp tục làm việc l Blocking receive Tiến trình nhận phải đợi cho tới khi có thông báo l Non-blocking receive Tiến trình nhận trả về hoặc một thông báo có giá trị, hoặc một giá trị null Vấn đề đồng bộ hoá"
ea73ad6304ed438f7e7d4c59ddd227a1:42,ea73ad6304ed438f7e7d4c59ddd227a1,42,43,,,695,"Chương 2 Quản lí tiến trình 1. Tiến trình 1.5. Truyền thông liên tiến trình • Các thông điệp trao đổi giữa các tiến trình được lưu trong hàng đợi tạm thời • Hàng đợi có thể được cài đặt theo • Khả năng chứa 0 (Zero capacity): Độ dài hàng đợi là 0 • Không tồn tại thông điệp trong đường liên kết ⇒ Sender phải đợi cho t ới khi thông điệp được nhận • Khả năng chứa có giới hạn(Bound capacity) • Hàng đợi có độ dài n ⇒ chứa nhiều nhất n thông điệp • Nếu hàng đợi không đầy, thông điệp sẽ được lưu vào trong vùng đệm và Sender tiếp tục bình thường • Nếu hàng đợi đầy, sender phải đợi cho tới khi có chỗ trống • Khả năng chứa không giới hạn (Unbound capacity) • Sender không bao giờ phải đợi Vùng đệm"
ea73ad6304ed438f7e7d4c59ddd227a1:43,ea73ad6304ed438f7e7d4c59ddd227a1,43,44,,,124,Chương 2 Quản lí tiến trình 1. Tiến trình 1.5. Truyền thông liên tiến trình Windows XP Truyền thông điệp giữa các tiến trình
ea73ad6304ed438f7e7d4c59ddd227a1:44,ea73ad6304ed438f7e7d4c59ddd227a1,44,45,,,658,"Chương 2 Quản lí tiến trình 1. Tiến trình 1.5. Truyền thông liên tiến trình • Được xem như đầu mút cho truyền thông, qua đó các ứng dụng g ửi/nhận dữ liệu qua mạng • Truyền thông thực hiện giữa các cặp Sockets • Bao gồm cặp địa chỉ IP và cổng. Ví dụ: 161.25.19.8:1625 • Địa chỉ IP: Địa chỉ của máy trong mạng • Cổng (port): Định danh tiến trình tham gia trao đổi trên máy • Các loại sockets • Stream Socket: Dựa trên giao thức TCP/IP →Truyền dữ liệu tin cậy • Datagram Socket: Dựa trên giao thức UDP/IP →Truyền dữ liệu không tin cậy • Win32 API: Winsock • Windows Sockets Application Programming Interface Truyền thông trong hệ thống Client-Server với Socket"
ea73ad6304ed438f7e7d4c59ddd227a1:45,ea73ad6304ed438f7e7d4c59ddd227a1,45,46,,,112,Chương 2 Quản lí tiến trình 1. Tiến trình 1.5. Truyền thông liên tiến trình Thiết lập quá trình trao đổi dữ liệu
ea73ad6304ed438f7e7d4c59ddd227a1:46,ea73ad6304ed438f7e7d4c59ddd227a1,46,47,,,512,Chương 2 Quản lí tiến trình 1. Tiến trình 1.5. Truyền thông liên tiến trình Một số hàm trong Winsock API 32 socket()Tạo socket truyền dữ liệu bind() Định danh cho socket vừa tạo (gán cho một cổng) listen() Lắng nghe một kết nối accept() Chấp nhận một kết nối connect() kết nối với server. send() Gửi dữ liệu với stream socket. sendto() Gửi dữ liệu với datagram socket. receive() Nhận dữ liệu với stream socket. recvfrom() Nhận dữ liệu với datagram socket. closesocket() Kết thúc một socket đã tồn tại. ..........
ea73ad6304ed438f7e7d4c59ddd227a1:47,ea73ad6304ed438f7e7d4c59ddd227a1,47,48,,,165,Chương 2 Quản lí tiến trình 1. Tiến trình 1.5. Truyền thông liên tiến trình Bài tập Sử dụng Winsock xây dựng chương trình Client-Server Chương trình Chat. ..........
ea73ad6304ed438f7e7d4c59ddd227a1:48,ea73ad6304ed438f7e7d4c59ddd227a1,48,49,,,138,Chương 2 Quản lí tiến trình ① Tiến trình ② Luồng (Thread) ③ Điều phối CPU ④ Tài nguyên găng và điều độ tiến trình ⑤ Bế tắc và xử lý bế tắc
ea73ad6304ed438f7e7d4c59ddd227a1:49,ea73ad6304ed438f7e7d4c59ddd227a1,49,50,,,126,Chương 2 Quản lí tiến trình 2. Luồng 2.1. Giới thiệu lGiới thiệu lMô hình đa luồng lCài đặt luồng với Windows lVấn đề đa luồng
ea73ad6304ed438f7e7d4c59ddd227a1:50,ea73ad6304ed438f7e7d4c59ddd227a1,50,51,,,191,Chương 2 Quản lí tiến trình 2. Luồng 2.1. Giới thiệu lTính toán trên vector kích thước lớn For (k = 0;k < n;k++) { a[k] = b[k]*c[k]; } Với hệ thống nhiều vi xử lý Ví dụ: Tính toán trên vector
ea73ad6304ed438f7e7d4c59ddd227a1:51,ea73ad6304ed438f7e7d4c59ddd227a1,51,52,,,342,"Chương 2 Quản lí tiến trình 2. Luồng 2.1. Giới thiệu Ví dụ: Chat While (1) { ReadLine(Msg); Send(Q,Msg); Receive(Q,Msg); PrintLine(Msg); } While (1) { Receive(P,Msg); PrintLine(Msg); ReadLine(Msg); Send(P,Msg); } Vấn đề nhận Msg l Blocking Recieve l Non-blocking Receive Giải quyết Thực hiện song song Receive & Send Tiến trình P Tiến trình Q"
ea73ad6304ed438f7e7d4c59ddd227a1:52,ea73ad6304ed438f7e7d4c59ddd227a1,52,53,,,354,"Chương 2 Quản lí tiến trình 2. Luồng 2.1. Giới thiệu Chương trình - Tiến trình - Luồng l Chương trình: Dãy lệnh, các biến,.. l Tiến trình: Chương trình đang thực hiện: Stack, t/bị, VXL,.. l Luồng: C/trình đang thực hiện trong ngữ cảnh tiến trình l Nhiều processor → Nhiều luồng, mỗi luồng trên một VXL l Khác nhau về giá trị các thanh ghi, nội dung stack"
ea73ad6304ed438f7e7d4c59ddd227a1:53,ea73ad6304ed438f7e7d4c59ddd227a1,53,54,,,316,"Chương 2 Quản lí tiến trình 2. Luồng 2.1. Giới thiệu Tiến trình đơn luồng và đa luồng l Hệ điều hành truyền thống (MS-DOS, UNIX) l Tiến trình có một luồng điều khiển (heavyweight process) l Hệ điều hành hiện nay (Windows, Linux) l Tiến trình có thể gồm nhiều luồng l Có thể thực hiện nhiều nhiệm vụ tại một thời điểm"
ea73ad6304ed438f7e7d4c59ddd227a1:54,ea73ad6304ed438f7e7d4c59ddd227a1,54,55,,,91,Chương 2 Quản lí tiến trình 2. Luồng 2.1. Giới thiệu Ví dụ: Word processor (Tanenbaum 2001)
ea73ad6304ed438f7e7d4c59ddd227a1:55,ea73ad6304ed438f7e7d4c59ddd227a1,55,56,,,592,"Chương 2 Quản lí tiến trình 2. Luồng 2.1. Giới thiệu Khái niệm luồng l Là đơn vị sử dụng CPU cơ bản, gồm l Định danh luồng (ID Thread) l Bộ đếm chương trình (Program Counter) l Tập các thanh ghi (Registers) l Không gian stack l Chia sẻ cùng các luồng khác trong cùng một tiến trình l Đoạn mã lệnh l Đoạn dữ liệu (đối tượng toàn cục) l Các tài nguyên hệ điều hành khác (file đang mở) l Các luồng có thể thực hiện cùng đoạn mã với ngữ cảnh (Tập thanh ghi, Bộ đếm chương trình, stack) khác nhau l Còn được gọi là tiến trình nhẹ (LWP: Lightweight Process) l Một tiến trình có ít nhất là một luồng"
ea73ad6304ed438f7e7d4c59ddd227a1:56,ea73ad6304ed438f7e7d4c59ddd227a1,56,57,,,830,"Chương 2 Quản lí tiến trình 2. Luồng 2.1. Giới thiệu Phân biệt tiến trình và luồng Tiến trình có đoạn mã/dữ liệu/heap & các đoạn khác Các luồng trong phạm vi một tiến trình chia sẻ mã/dữ liệu/heap, vào/ra nhưng có stack và tập thanh ghi riêng Phải có ít nhất một luồng trong mỗi tiến trình Thao tác khởi tạo, luân chuyển tiến trình tốn kém Bảo vệ tốt do có không gian điạ chỉ riêng Khi tiến trình kết thúc, các tài nguyên được đòi lại và các luồng phải kết thúc theo Luồng không có đoạn dữ liệu hay heap riêng Luồng không đứng riêng mà nằm trong một tiến trình Có thể tồn tại nhiều luồng trong mỗi tiến trình. Luồng đầu là luồng chính và sở hữu không gian stack của tiến trình Thao tác khởi tạo và luân chuyển luồng không tốn kém Không gian điạ chỉ chung, cần phải bảo vệ Luồng kết thúc, stack của nó được thu hồi Luồng Tiến trình"
ea73ad6304ed438f7e7d4c59ddd227a1:57,ea73ad6304ed438f7e7d4c59ddd227a1,57,58,,,825,"Chương 2 Quản lí tiến trình 2. Luồng 2.1. Giới thiệu Lợi ích của lập trình đa luồng l Tăng tính đáp ứng với người dùng l Cho phép chương trình vẫn thực hiện ngay khi một phần đang chờ đợi (block) hoặc đang thực hiện tính toán tăng cường (lengthy operation) l Chia sẻ tài nguyên l Các luồng chia sẻ bộ nhớ và tài nguyên của tiến trình chứa nó l Tốt cho các thuật toán song song (sử dụng chung các CTDL) l Trao đổi giữa các luồng thông qua bộ nhớ chia sẻ l Cho phép một ứng dụng chứa nhiều luồng hoạt động trong cùng không gian địa chỉ l Tính kinh tế l Các thao tác khởi tạo, hủy bỏ và luân chuyển luồng ít tốn kém l Minh họa được tính song song trên bộ đơn VXL do thời gian luân chuyển CPU nhanh (Thực tế chỉ một luồng thực hiện) l Sử dụng kiến trúc nhiều vi xử lý l Các luồng chạy song song thực sự trên các bộ VXL khác nhau."
ea73ad6304ed438f7e7d4c59ddd227a1:58,ea73ad6304ed438f7e7d4c59ddd227a1,58,59,,,382,"Chương 2 Quản lí tiến trình 2. Luồng 2.1. Giới thiệu Lợi ích của lập trình đa luồng -> Ví dụ Tính toán trên vector for (k = 0;k < n;k++) { a[k] = b[k]*c[k]; } void fn(a,b) for(k = a; k < b; k ++){ a[k] = b[k] ∗ c[k]; } void main(){ CreateThread(fn(0, n/4)); CreateThread(fn(n/4, n/2)); CreateThread(fn(n/2, 3n/4)); CreateThread(fn(3n/4, n)); } Tính toán trên vector Mô hình đa luồng"
ea73ad6304ed438f7e7d4c59ddd227a1:59,ea73ad6304ed438f7e7d4c59ddd227a1,59,60,,,116,Chương 2 Quản lí tiến trình 2. Luồng 2.1. Giới thiệu Cài đặt luồng Trong không gian người dùng Trong không gian nhân
ea73ad6304ed438f7e7d4c59ddd227a1:60,ea73ad6304ed438f7e7d4c59ddd227a1,60,61,,,647,"Chương 2 Quản lí tiến trình 2. Luồng 2.1. Giới thiệu Luồng người dùng (User -Level Threads) l Quản lý các luồng được thực hiện bởi chương trình ứng dụng l Nhân hệ thống không biết gì về sự tồn tại luồng l Điều phối tiến trình như một đơn vị duy nhất l Gán cho mỗi tiến trình một trạng thái duy nhất l Sẵn sàng, chờ đợi, thực hiện,.. l Chương trình ứng dụng được lập trình theo mô hình đa luồng được hỗ trợ bởi thư viện luồng l Ưu điểm l Nhanh chóng trong tạo và quản lý luồng l Nhược điểm l Khi một luồng rơi vào trạng thái chờ đợi, tất cả các luồng trong cùng tiến trình bị chờ đợi theo ⇒Không tận dụng được ưu điểm của mô hình lập trình đa luồng"
ea73ad6304ed438f7e7d4c59ddd227a1:61,ea73ad6304ed438f7e7d4c59ddd227a1,61,62,,,552,"Chương 2 Quản lí tiến trình 2. Luồng 2.1. Giới thiệu Luồng mức hệ thống (Kernel - Level threads) l Nhân duy trì thông tin về tiến trình và các luồng l Quản lý luồng được thực hiện bởi nhân l Không tồn tại các mã quản lý luồng trong ứng dụng l Điều phối luồng được thực hiện bởi nhân, dựa trên các luồng l Nhược điểm: l Chậm trong tạo và quản lý luồng l Ưu điểm: l Một luồng chờ đợi vào ra, không ảnh hưởng tới luồng khác l Trong môi trường đa VXL, nhân có thể điều phối các luồng cho các VXL khác nhau l Hệ điều hành: Windows NT/2000/XP, Linux, OS/2,.."
ea73ad6304ed438f7e7d4c59ddd227a1:62,ea73ad6304ed438f7e7d4c59ddd227a1,62,63,,,131,Chương 2 Quản lí tiến trình 2. Luồng 2.2.Mô hình đa luồng lGiới thiệu lMô hình đa luồng lCài đặt luồng với Windows lVấn đề đa luồng
ea73ad6304ed438f7e7d4c59ddd227a1:63,ea73ad6304ed438f7e7d4c59ddd227a1,63,64,,,174,Chương 2 Quản lí tiến trình 2. Luồng 2.2. Mô hình đa luồng Giới thiệu l Nhiều hệ thống hỗ trợ cả luồng mức người dùng và luồng mức hệ thống ⇒ Nhiều mô hình đa luồng khác nhau
ea73ad6304ed438f7e7d4c59ddd227a1:64,ea73ad6304ed438f7e7d4c59ddd227a1,64,65,,,460,Chương 2 Quản lí tiến trình 2. Luồng 2.2. Mô hình đa luồng Mô hình nhiều-một l Ánh xạ nhiều luồng mức người dùng tới một luồng mức hệ thống l Quản lý luồng được thực hiện trong không gian người dùng l Hiệu quả l Cho phép tạo nhiều luồng tùy ý l Toàn bộ tiến trình sẽ bị khóa nếu một luồng bị khóa l Không thể chạy song song trên các máy nhiều vi xử lý (Chỉ một luồng có thểtruy nhập nhân tại một thời điểm) l Dùng trong hệ điều hành không hỗ trợ luồng hệ thống
ea73ad6304ed438f7e7d4c59ddd227a1:65,ea73ad6304ed438f7e7d4c59ddd227a1,65,66,,,452,Chương 2 Quản lí tiến trình 2. Luồng 2.2. Mô hình đa luồng Mô hình một-một l Ánh xạ mỗi luồng mức người dùng tới một luồng hệ thống l Cho phép thực hiện luồng khác khi một luồng bị chờ đợi l Cho phép chạy song song đa luồng trên máy nhiều vi xử lý l Tạo luồng mức người dùng đòi hỏi tạo một luồng mức hệ thống tương ứng l Ảnh hướng tới hiệu năng của ứng dụng l Chi phi cao ⇒ Giới hạn số luồng được hệ thống hỗ trợ l Được sử dụng trong Window NT/2000/XP
ea73ad6304ed438f7e7d4c59ddd227a1:66,ea73ad6304ed438f7e7d4c59ddd227a1,66,67,,,513,"Chương 2 Quản lí tiến trình 2. Luồng 2.2. Mô hình đa luồng Mô hình nhiều nhiều l Nhiều luồng mức người dùng ánh xạ tới một số nhỏ luồng mức hệ thống l Số lượng luồng nhân có thể được xác định theo máy hoặc theo ứng dụng l VD: Được cấp nhiều luồng nhân hơn trên hệ thống nhiều VXL l Có được ưu điểm của 2 mô hình trên l Cho phép tạo nhiều luồng mức ứng dụng theo yêu cầu l Các luồng nhân tương ứng có thể chạy song song trên hệ nhiều VXL l Một luồng bị khóa, nhân có thể cho phép luồng khác thực hiện l Ví dụ: UNIX"
ea73ad6304ed438f7e7d4c59ddd227a1:67,ea73ad6304ed438f7e7d4c59ddd227a1,67,68,,,141,Chương 2 Quản lí tiến trình 2. Luồng 2.3. Cài đặt luồng với Windows lGiới thiệu lMô hình đa luồng lCài đặt luồng với Windows lVấn đề đa luồng
ea73ad6304ed438f7e7d4c59ddd227a1:68,ea73ad6304ed438f7e7d4c59ddd227a1,68,69,,,741,"Chương 2 Quản lí tiến trình 2. Luồng 2.3. Cài đặt luồng với Windows Một số hàm với luồng trong WIN32 API l HANDLE CreateThread(. . .); l LPSECURITY_ATTRIBUTESlpThreadAttributes, ⇒Trỏ tới cấu trúc an ninh: thẻ trả về có thể được kế thừa? l DWORD dwStackSize, ⇒Kích thước ban đầu của stack cho luồng mới l LPTHREAD_START_ROUTINE lpStartAddress, ⇒Trỏ tới hàm được thực hiện bởi luồng mới l LPVOID lpParameter, ⇒Trỏ tới các biến được gửi tới luồng mới (tham số của hàm) l DWORD dwCreationFlags, ⇒Phương pháp tạo luồng l CREATE_SUSPENDED : Luồng ở trạng thái tạm ngừng l 0: Luồng được thực hiện ngay lập tức l LPDWORD lpThreadId ⇒Biến ghi nhận định danh luồng mới l Kết quả trả về: Thẻ của luồng mới hoặc giá trị NULL nếu không tạo được luồng mới"
ea73ad6304ed438f7e7d4c59ddd227a1:69,ea73ad6304ed438f7e7d4c59ddd227a1,69,70,,,455,"Chương 2 Quản lí tiến trình 2. Luồng 2.3. Cài đặt luồng với Windows Ví dụ #include <windows.h> #include <stdio.h> void Routine(int *n){ printf(""My argument is %d\n"", &n); } int main(){ int i, P[5]; DWORD Id; HANDLE hHandles[5]; for (i=0;i < 5;i++) { P[i] = i; hHandles[i] = CreateThread(NULL,0, (LPTHREAD_START_ROUTINE)Routine,&P[i],0,&Id); printf(""Thread %d was created\n"",Id); } for (i=0;i < 5;i++) WaitForSingleObject(hHandles[i],INFINITE); return 0; }"
ea73ad6304ed438f7e7d4c59ddd227a1:70,ea73ad6304ed438f7e7d4c59ddd227a1,70,71,,,369,"Chương 2 Quản lí tiến trình 2. Luồng 2.3. Cài đặt luồng với Windows Luồng trong Windows XP Thread bao gồm l Thread ID l Registers l user stack dùng trong user mode, kernel stack dùng trong kernel mode. l Vùng lưu trữ riêng được dùng bởi các thư viện khi thực hiện (run- time) và thư viện liên kết động executive thread block Kernel thread block Thread environment block"
ea73ad6304ed438f7e7d4c59ddd227a1:71,ea73ad6304ed438f7e7d4c59ddd227a1,71,72,,,130,Chương 2 Quản lí tiến trình 2. Luồng 2.4.Vấn đề đa luồng lGiới thiệu lMô hình đa luồng lCài đặt luồng với Windows lVấn đề đa luồng
ea73ad6304ed438f7e7d4c59ddd227a1:72,ea73ad6304ed438f7e7d4c59ddd227a1,72,73,,,461,"Chương 2 Quản lí tiến trình 2. Luồng 2.4. Vấn đề đa luồng Ví dụ #include <windows.h> #include <stdio.h> int x = 0, y = 1; void T1(){ while(1){ x = y + 1; printf(""%4d"", x); } } void T2(){ while(1){ y = 2; y = y * 2; } } int main(){ HANDLE h1, h2; DWORD Id; h1=CreateThread(NULL,0,(LPTHREAD_START_ROUTINE)T1,NULL,0,&Id); h2=CreateThread(NULL,0,(LPTHREAD_START_ROUTINE)T2,NULL,0,&Id); WaitForSingleObject(h1,INFINITE); WaitForSingleObject(h2,INFINITE); return 0; }"
ea73ad6304ed438f7e7d4c59ddd227a1:73,ea73ad6304ed438f7e7d4c59ddd227a1,73,74,,,75,Chương 2 Quản lí tiến trình 2. Luồng 2.4. Vấn đề đa luồng Kết quả thực hiện
ea73ad6304ed438f7e7d4c59ddd227a1:74,ea73ad6304ed438f7e7d4c59ddd227a1,74,75,,,229,Chương 2 Quản lí tiến trình 2. Luồng 2.4. Vấn đề đa luồng Giải thích Kết quả thực hiện các luồng song song phụ thuộc trật tự truy nhập biến dùng chung giữa chúng Thread T1 Thread T2 t x = y + 1 y = 2 y = y * 2 x = y + 1 x = y + 1
ea73ad6304ed438f7e7d4c59ddd227a1:75,ea73ad6304ed438f7e7d4c59ddd227a1,75,76,,,138,Chương 2 Quản lí tiến trình ① Tiến trình ② Luồng (Thread) ③ Điều phối CPU ④ Tài nguyên găng và điều độ tiến trình ⑤ Bế tắc và xử lý bế tắc
ea73ad6304ed438f7e7d4c59ddd227a1:76,ea73ad6304ed438f7e7d4c59ddd227a1,76,77,,,164,Chương 2 Quản lí tiến trình 3. Điều phối CPU 3.1. Các khái niệm cơ bản lCác khái niệm cơ bản lTiêu chuẩn điều phối lCác thuật toán điều phối lCPU Điều phối đa xử lý
ea73ad6304ed438f7e7d4c59ddd227a1:77,ea73ad6304ed438f7e7d4c59ddd227a1,77,78,,,755,"Chương 2 Quản lí tiến trình 3. Điều phối CPU 3.1. Các khái niệm cơ bản l Hệ thống có một processor → Chỉ có một tiến trình được thực hiện tại một thời điểm l Tiến trình được thực hiện (chiếm dụng VXL) cho tới khi phải chờ đợi một thao tác vào ra l Hệ đơn chương trình: CPU không được sử dụng ⇒Lãng phí l Hệ đa chương trình: cố gắng sử dụng CPU (đang rảnh rỗi) cho các tiến trình khác (đang chờ đợi) l Cần nhiều tiến trình sẵn sàng trong bộ nhớ tại một thời điểm l Khi một tiến trình phải chờ, hệ điều hành lấy lại processor để phân cho tiến trình khác l Điều phối processor quan trọng với hệ điều hành đa nhiệm l Luân chuyển CPU giữa các tiến trình → khai thác hệ thống hiệu quả hơn l Điều phối processor là nền tảng trong thiết kế hệ điều hành Giới thiệu"
ea73ad6304ed438f7e7d4c59ddd227a1:78,ea73ad6304ed438f7e7d4c59ddd227a1,78,79,,,611,Chương 2 Quản lí tiến trình 3. Điều phối CPU 3.1. Các khái niệm cơ bản l Tiến trình là chuỗi luân phiên giữa chu kỳ tính toán và chờ đợi vào/ra l Bắt đầu bởi chu kỳ tính toán l Tiếp theo chu kỳ đợi vào/ra l Tính toán→ đợi vào/ra → tính toán → đợi vào/ra → . . . l Kết thúc: Tính toán (yêu cầu hệ thống kết thúc thực hiện) l Phân biệt các kiểu tiến trình l Dựa trên sự phân bổ thời gian cho các chu kỳ CPU & vào/ra l Tiến trình tính toán (CPU-bound process) có vài chu kỳ CPU dài l Tiến trình vào ra (I/0-bound process) có nhiều chu kỳ CPU ngắn l Để chọn giải thuật điều phối thích hợp Chu kỳ thực hiện CPU - I/O
ea73ad6304ed438f7e7d4c59ddd227a1:79,ea73ad6304ed438f7e7d4c59ddd227a1,79,80,,,726,"Chương 2 Quản lí tiến trình 3. Điều phối CPU 3.1. Các khái niệm cơ bản l Lựa chọn một trong số các tiến trình đang sẵn sàng trong bộ nhớ và cung cấp CPU cho nó l Các tiến trình phải sắp hàng trong hàng đợi l Hàng đợi FIFO, Hàng đợi ưu tiên, DSLK đơn giản . . . l Quyết định điều phối CPU xảy ra khi tiến trình 1) Chuyển từ trạng thái thực hiện sang trạng thái chờ đợi (y/c vào/ra) 2) Chuyển từ trạng thái thực hiện sang trạng thái sẵn sàng (hết thời gian sử dụng CPU → ngắt thời gian) 3) Chuyển từ trạng thái chờ đợi sang trạng thái sẵn sàng (hoàn thành vào/ra) 4) Tiến trình kết thúc l Ghi chú l Trường hợp 1&4 ⇒Điều phối không trưng dụng (non-preemptive) l Trường hợp khác ⇒Điều phối trưng dụng (preemptive) Bộ điều phối CPU"
ea73ad6304ed438f7e7d4c59ddd227a1:80,ea73ad6304ed438f7e7d4c59ddd227a1,80,81,,,748,"Chương 2 Quản lí tiến trình 3. Điều phối CPU 3.1. Các khái niệm cơ bản l Điều phối không trưng dụng l Tiến trình chiếm CPU cho tới khi giải phóng bởi l Kết thúc nhiệm vụ l Chuyển sang trạng thái chờ đợi l Không đòi hỏi phần cứng đặc biệt (đồng hồ ) l Ví dụ: DOS, Win 3.1, Macintosh l Điều phối trưng dụng l Tiến trình chỉ được phép thực hiện trong khoảng thời gian l Hết thời gian, ngắt thời gian xuất hiện, bộ điều vận (dispatcher) quyết định phục hồi lại tiến trình hay chọn tiến trình khác l Bảo vệ CPU khỏi các tiến trình ""đói-CPU"" l Vấn đề dữ liệu dùng chung l Tiến trình 1 đang cập nhật DL thì bị mất CPU l Tiến trình 2, được giao CPU và đọc DL đang cập nhật l Ví dụ: Hệ điều hành đa nhiệm WinNT, UNIX Điều phối trưng dụng và không trưng dụng"
ea73ad6304ed438f7e7d4c59ddd227a1:81,ea73ad6304ed438f7e7d4c59ddd227a1,81,82,,,164,Chương 2 Quản lí tiến trình 3. Điều phối CPU 3.2. Tiêu chuẩn điều phối lCác khái niệm cơ bản lTiêu chuẩn điều phối lCác thuật toán điều phối lCPU Điều phối đa xử lý
ea73ad6304ed438f7e7d4c59ddd227a1:82,ea73ad6304ed438f7e7d4c59ddd227a1,82,83,,,719,Chương 2 Quản lí tiến trình 3. Điều phối CPU 3.2. Tiêu chuẩn điều phối l Sử dụng CPU (Lớn nhất) l Mục đích của điều độ là làm CPU hoạt động nhiều nhất có thể l Độ sử dụng CPU thay đổi từ 40% (hệ thống tải nhẹ) đến 90% (hệ thống tải nặng). l Thông lượng (throughput) (Lớn nhất) l Số lượng tiến trình hoàn thành trong một đơn vị thời gian l Các tiến trình dài: 1 tiến trình/giờ l Các tiến trình ngắn: 10 tiến trình/giây l Thời gian hoàn thành (Nhỏ nhất) l Khoảng thời gian từ thời điểm gửi đến hệ thống tới khi quá trình hoàn thành l Thời gian chờ đợi để đưa tiến trình vào bộ nhớ l Thời gian chờ đợi trong hàng đợi sẵn sàng l Thời gian chờ đợi trong hàng đợi thiết bị l Thời gian thực hiện thực tế Tiêu chuẩn điều phối I
ea73ad6304ed438f7e7d4c59ddd227a1:83,ea73ad6304ed438f7e7d4c59ddd227a1,83,84,,,609,Chương 2 Quản lí tiến trình 3. Điều phối CPU 3.2. Tiêu chuẩn điều phối l Thời gian chờ đợi (Nhỏ nhất) l Tổng thời gian chờ trong hàng đợi sẳn sàng (Giải thuật điều độ CPU không ảnh hưởng tới các tiến trình đang thực hiện hay đang đợi thiết bị vào ra) l Thời gian đáp ứng (Nhỏ nhất) l Từ lúc gửi câu hỏi cho tới khi câu trả lời đầu tiên được tạo ra l Tiến trình có thể tạo kết quả ra từng phần l Tiến trình vẫn tiếp tục tính toán kết quả mới trong khi kết quả cũ được gửi tới người dùng Tiêu chuẩn điều phối II l Giả thiết: Các tiến trình chỉ có một chu kỳ tính toán (ms) l Đo đạc: Thời gian chờ đợi trung bình
ea73ad6304ed438f7e7d4c59ddd227a1:84,ea73ad6304ed438f7e7d4c59ddd227a1,84,85,,,168,Chương 2 Quản lí tiến trình 3. Điều phối CPU 3.3. Các thuật toán điều phối lCác khái niệm cơ bản lTiêu chuẩn điều phối lCác thuật toán điều phối lCPU Điều phối đa xử lý
ea73ad6304ed438f7e7d4c59ddd227a1:85,ea73ad6304ed438f7e7d4c59ddd227a1,85,86,,,386,"Chương 2 Quản lí tiến trình 3. Điều phối CPU 3.3. Các thuật toán điều phối l Nguyên tắc: Tiến trình được quyền sử dụng CPU theo trình tự xuất hiện Tiến trình sở hữu CPU tới khi kết thúc hoặc chờ đợi vào ra l Ví dụ l Đặc điểm l Đơn giản, dễ thực hiện l Tiến trình ngắn phải chờ đợi như tiến trình dài l Nếu P1 thực hiện sau cùng ? Đến trước phục vụ trước (FCFS: First Come, First Served)"
ea73ad6304ed438f7e7d4c59ddd227a1:86,ea73ad6304ed438f7e7d4c59ddd227a1,86,87,,,544,Chương 2 Quản lí tiến trình 3. Điều phối CPU 3.3. Các thuật toán điều phối l Nguyên tắc: Mỗi tiến trình lưu trữ thời gian của chu kỳ sử dụng CPU tiếp theo l Tiến trình có thời gian sử dụng CPU ngắn nhất sẽ sở hữu CPU l Hai phương pháp l Không trưng dụng CPU l Có trưng dụng CPU (SRTF: Shortest Remaining Time First) l Ví dụ l Đặc điểm l SJF (SRTF) là tối ưu: Thời gian chờ đợi trung bình nhỏ nhất l Không thể biết chính xác thời gian của chu kỳ sử dụng CPU l Dự báo dựa trên những giá trị trước đó Công việc ngắn trước (SJF: Shortest Job First)
ea73ad6304ed438f7e7d4c59ddd227a1:87,ea73ad6304ed438f7e7d4c59ddd227a1,87,88,,,517,"Chương 2 Quản lí tiến trình 3. Điều phối CPU 3.3. Các thuật toán điều phối l Mỗi tiến trình gắn với một sô hiệu ưu tiên (số nguyên) l CPU sẽ được phân phối cho tiến trình có độ ưu tiên cao nhất l SJF: độ ưu tiên gắn liền với thời gian thực hiện l Hai phương pháp l Không trưng dụng CPU l Có trưng dụng CPU l Ví dụ l Vấn đề ""Nạn đói"": Tiến trình có độ ưu tiên thấp phải chờ đợi lâu (thậm chí không được thực hiện) l Giải pháp tăng dần độ ưu tiên tt theo t/gian trong hệ thống Điều phối có ưu tiên (Priority Scheduling)"
ea73ad6304ed438f7e7d4c59ddd227a1:88,ea73ad6304ed438f7e7d4c59ddd227a1,88,89,,,495,"Chương 2 Quản lí tiến trình 3. Điều phối CPU 3.3. Các thuật toán điều phối l Nguyên tắc l Mỗi tiến trình được cấp một lượng tử thời gian τ để thực hiện l Khi hết thời gian, tiến trình bị trưng dụng processor và được đưa vào cuối hàng đợi sẵn sàng l Nếu có n tiến trình, thời gian chờ đợi nhiều nhất (n − 1)τ l Ví dụ Lượng tử thời gian τ = 4 l Vấn đề: Lựa chọn lượng tử thời gian τ l τ lớn: FCFS l τ nhỏ: Hãy phải luân chuyển CPU l Thông thường τ = 10-100ms Vòng tròn (RR: Round Robin Scheduling)"
ea73ad6304ed438f7e7d4c59ddd227a1:89,ea73ad6304ed438f7e7d4c59ddd227a1,89,90,,,113,Chương 2 Quản lí tiến trình 3. Điều phối CPU 3.3. Các thuật toán điều phối Vòng tròn (RR: Round Robin Scheduling)
ea73ad6304ed438f7e7d4c59ddd227a1:90,ea73ad6304ed438f7e7d4c59ddd227a1,90,91,,,804,"Chương 2 Quản lí tiến trình 3. Điều phối CPU 3.3. Các thuật toán điều phối l Hàng đợi sẵn sàng được phân chia thành nhiều hàng đợi nhỏ l Tiến trình được ấn định cố định cho một hàng đợi l Dựa vào tính chất như độ ưu tiên, kiểu tiến trình.. l Mỗi hàng đợi sử dụng thuật toán điều độ riêng l Cần điều phối giữa các hàng đợi l Điều phối có trưng dụng, độ ưu tiên cố định l Tiến trình hàng đợi độ ưu tiên thấp chỉ được thực hiện khi các hàng đợi có độ ưu tiên cao rỗng l Tiến trình độ ưu tiên mức cao, trưng dụng tiến trình độ ưu tiên mức thấp l Có thể gặp tình trạng starvation l Phân chia thời gian giữa các hàng đợi l Hàng đợi cho foreground process, chiếm 80% thời gian CPU cho RR l Hàng đợi cho background process, chiếm 20% thời gian CPU cho FCFS Điều phối hàng đợi đa mức (Multilevel Queue Scheduling)"
ea73ad6304ed438f7e7d4c59ddd227a1:91,ea73ad6304ed438f7e7d4c59ddd227a1,91,92,,,108,Chương 2 Quản lí tiến trình 3. Điều phối CPU 3.3. Các thuật toán điều phối Điều phối hàng đợi đa mức (Ví dụ)
ea73ad6304ed438f7e7d4c59ddd227a1:92,ea73ad6304ed438f7e7d4c59ddd227a1,92,93,,,734,"Chương 2 Quản lí tiến trình 3. Điều phối CPU 3.3. Các thuật toán điều phối l Cho phép các tiến trình được dịch chuyển giữa các hàng đợi l Phân chia tiến trình theo đặc điểm sử dụng VXL l Nếu dùng quá nhiều thời gian của VXL → Chuyển xuống hàng đợi có độ ưu tiên thấp l Tiến trình vào ra nhiều → hàng đợi có độ ưu tiên cao l Tiến trình đợi quá lâu tại hàng đợi có độ ưu tiên thấp → Chuyển lên hàng đợi độ ưu tiên cao l Ngăn ngừa tình trạng ""đói CPU"" l Được định nghĩa bởi các tham số l Số hàng đợi l Thuật toán điều độ cho mỗi hàng đợi l Điều kiện để tiến trình được chuyển lên/xuống hàng đợi có độ ưu tiên cao/thấp hơn l Phương pháp xác định một hàng đợi khi tiến trình cần phục vụ Hàng đợi hồi tiếp đa mức (Multilevel Feedback Queue)"
ea73ad6304ed438f7e7d4c59ddd227a1:93,ea73ad6304ed438f7e7d4c59ddd227a1,93,94,,,107,Chương 2 Quản lí tiến trình 3. Điều phối CPU 3.3. Các thuật toán điều phối l Ví dụ Hàng đợi hồi tiếp đa mức
ea73ad6304ed438f7e7d4c59ddd227a1:94,ea73ad6304ed438f7e7d4c59ddd227a1,94,95,,,162,Chương 2 Quản lí tiến trình 3. Điều phối CPU 3.4. Điều phối đa xử lý lCác khái niệm cơ bản lTiêu chuẩn điều phối lCác thuật toán điều phối lCPU Điều phối đa xử lý
ea73ad6304ed438f7e7d4c59ddd227a1:95,ea73ad6304ed438f7e7d4c59ddd227a1,95,96,,,591,Chương 2 Quản lí tiến trình 3. Điều phối CPU 3.4. Điều phối đa xử lý l Điều phối phức tạp hơn so với trường hợp có một VXL l Vấn đề chia sẻ tải l Mỗi VXL có một hàng đợi sẵn sàng riêng l Tồn tại VXL rảnh rỗi với hàng đợi rỗng trong khi VXL khác phải tính toán nhiều l Hàng đợi sẵn sàng dùng chung l Vấn đề dùng chung cấu trúc dữ liêu (hàng đợi) : →Một tiến trình được lựa chọn bởi 2 processors hoặc →Một tiến trình bị thất lạc trên hàng đợi l Đa xử lý không đối xứng l Chỉ có một processor truy nhập hàng đợi hủy bỏ vấn đề dùng chung cơ sở dữ liệu l Có thể tắc nghẽn tại một processor Vấn đề
ea73ad6304ed438f7e7d4c59ddd227a1:96,ea73ad6304ed438f7e7d4c59ddd227a1,96,97,,,105,Chương 2 Quản lí tiến trình 3. Điều phối CPU lViết chương trình mô phỏng hàng đợi hồi tiếp đa mức Bài tập
ea73ad6304ed438f7e7d4c59ddd227a1:97,ea73ad6304ed438f7e7d4c59ddd227a1,97,98,,,138,Chương 2 Quản lí tiến trình ① Tiến trình ② Luồng (Thread) ③ Điều phối CPU ④ Tài nguyên găng và điều độ tiến trình ⑤ Bế tắc và xử lý bế tắc
ea73ad6304ed438f7e7d4c59ddd227a1:98,ea73ad6304ed438f7e7d4c59ddd227a1,98,99,,,224,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình lKhái niệm tài nguyên găng lPhương pháp khóa trong lPhương pháp kiểm tra và xác lập lKỹ thuật đèn báo lVí dụ về đồng bộ tiến trình lCông cụ điều độ cấp cao
ea73ad6304ed438f7e7d4c59ddd227a1:99,ea73ad6304ed438f7e7d4c59ddd227a1,99,100,,,98,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.1 Khái niệm tài nguyên găng
ea73ad6304ed438f7e7d4c59ddd227a1:100,ea73ad6304ed438f7e7d4c59ddd227a1,100,101,,,98,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.1 Khái niệm tài nguyên găng
ea73ad6304ed438f7e7d4c59ddd227a1:101,ea73ad6304ed438f7e7d4c59ddd227a1,101,102,,,98,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.1 Khái niệm tài nguyên găng
ea73ad6304ed438f7e7d4c59ddd227a1:102,ea73ad6304ed438f7e7d4c59ddd227a1,102,103,,,503,"Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.1. Khái niệm tài nguyên găng Ví dụ #include <windows.h> #include <stdio.h> int x = 0, y = 1; void T1(){ while(1){ x = y + 1; printf(""%4d"", x); } } void T2(){ while(1){ y = 2; y = y * 2; } } int main(){ HANDLE h1, h2; DWORD Id; h1=CreateThread(NULL,0,(LPTHREAD_START_ROUTINE)T1,NULL,0,&Id); h2=CreateThread(NULL,0,(LPTHREAD_START_ROUTINE)T2,NULL,0,&Id); WaitForSingleObject(h1,INFINITE); WaitForSingleObject(h2,INFINITE); return 0; }"
ea73ad6304ed438f7e7d4c59ddd227a1:103,ea73ad6304ed438f7e7d4c59ddd227a1,103,104,,,116,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.1 Khái niệm tài nguyên găng Kết quả thực hiện
ea73ad6304ed438f7e7d4c59ddd227a1:104,ea73ad6304ed438f7e7d4c59ddd227a1,104,105,,,270,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.1 Khái niệm tài nguyên găng Giải thích Kết quả thực hiện các luồng song song phụ thuộc trật tự truy nhập biến dùng chung giữa chúng Thread T1 Thread T2 t x = y + 1 y = 2 y = y * 2 x = y + 1 x = y + 1
ea73ad6304ed438f7e7d4c59ddd227a1:105,ea73ad6304ed438f7e7d4c59ddd227a1,105,106,,,406,• Hệ thống gồm 2 tiến trình • Producer sản xuất ra các sản phẩm • Consumer tiêu thụ các sản phẩm được sản xuất ra • Công việc của Producer phải đồng bộ với Consumer. • Không đưa ra sản phẩm khi hết chỗ trống • Không lấy được sản phẩm khi chưa có Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.1 Khái niệm tài nguyên găng Bài toán người sản xuất (producer)-người tiêu thụ(consumer) I
ea73ad6304ed438f7e7d4c59ddd227a1:106,ea73ad6304ed438f7e7d4c59ddd227a1,106,107,,,618,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.1 Khái niệm tài nguyên găng Bài toán người sản xuất (producer)-người tiêu thụ(consumer) II Producer Consumer while(1) { /*produce an item in nextProduced*/ while (Counter == BUFFER_SIZE) ; /*do nothing*/ Buffer[IN] = nextProduced; IN = (IN + 1) % BUFFER_SIZE; Counter++; } while(1){ while(Counter == 0) ; /*do nothing*/ nextConsumed = Buffer[OUT]; OUT =(OUT + 1) % BUFFER_SIZE; Counter--; /*consume the item in nextConsumed*/ } Nhận xét l Producer sản xuất một sản phẩm l Consumer tiêu thụ một sản phẩm ⇒Số sản phẩm còn trong Buffer không thay đổi
ea73ad6304ed438f7e7d4c59ddd227a1:107,ea73ad6304ed438f7e7d4c59ddd227a1,107,108,,,467,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.1 Khái niệm tài nguyên găng Định nghĩa Tài nguyên Tất cả những gì cần thiết cho thực hiện tiến trình Tài nguyên găng l Tài nguyên hạn chế về khả năng sử dụng chung l Cần đồng thời cho nhiều tiến trình l Tài nguyên găng có thể là thiết bị vật lý hay dữ liệu dùng chung Vấn đề Dùng chung tài nguyên găng có thể dẫn đến không đảm bảo tính toàn vẹn dữ liệu ⇒ Đòi hỏi cơ chế đồng bộ hóa các tiến trình
ea73ad6304ed438f7e7d4c59ddd227a1:108,ea73ad6304ed438f7e7d4c59ddd227a1,108,109,,,731,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.1 Khái niệm tài nguyên găng Điều kiện cạnh tranh (Race condition) l Tình trạng trong đó kết quả của việc nhiều tiến trình cùng truy nhập tới dữ liệu phân chia phụ thuộc vào trật tự của các truy nhập l Làm cho chương trình không xác định l Ngăn ngừa điều kiện cạnh tranh được thực hiện bởi đồng bộ hóa (synchronize) các tiến trình thực hiện đồng thời l Chỉ một tiến trình truy nhập tới dữ liệu phân chia tại một thời điểm l Biến counter trong vấn đề Producer-Consumer l Đoạn lệnh truy nhập tới dữ liệu phân chia trong các tiến trình phải thực hiện theo thứ tự xác định l VD: Lệnh x←y+1 trong Thread T1 chỉ thực hiện khi cả 2 lệnh của Thread T2 đã thực hiện xong
ea73ad6304ed438f7e7d4c59ddd227a1:109,ea73ad6304ed438f7e7d4c59ddd227a1,109,110,,,405,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.1 Khái niệm tài nguyên găng Đoạn găng (Critical section) l Đoạn găng (chỗ hẹp) là đoạn chương trình sử dụng tài nguyên găng l Đoạn chương trình thực hiện truy nhập và thao tác trên dữ liệu dùng chung l Khi có nhiều tiến trình sử dụng tài nguyên găng thì phải điều độ l Mục đích: đảm bảo không có quá một tiến trình nằm trong đoạn găng
ea73ad6304ed438f7e7d4c59ddd227a1:110,ea73ad6304ed438f7e7d4c59ddd227a1,110,111,,,748,"Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.1 Khái niệm tài nguyên găng Yêu cầu của chương trình điều độ l Loại trừ lẫn nhau (Mutual Exclusion) Mỗi thời điểm, tài nguyên găng không phải phục vụ một số lượng tiến trình vượt quá khả năng của nó l Một tiến trình đang thực hiện trong đoạn găng (sử dụng tài nguyên găng) ⇒ Không một tiến trình nào khác được quyền vào đoạn găng l Tiến triển (Progress) Tài nguyên găng còn khả năng phục vụ và tồn tại tiến trình muốn vào đoạn găng, thì tiến trình đó phải được sử dụng tài nguyên găng l Chờ đợi hữu hạn (Bounded Waiting) Nếu tài nguyên găng hết khả năng phục vụ và vẫn tồn tại tiến trình muốn vào đoạn găng, thì tiến trình đó phải được xếp hàng chờ đợi và sự chờ đợi là hữu hạn"
ea73ad6304ed438f7e7d4c59ddd227a1:111,ea73ad6304ed438f7e7d4c59ddd227a1,111,112,,,422,"Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.1 Khái niệm tài nguyên găng Quy ước l Có 2 tiến trình P1&P2 thực hiện đồng thời l Các tiến trình dùng chung một tài nguyên găng l Mỗi tiến trình đặt đoạn găng ở đầu, tiếp theo là phần còn lại l Tiến trình phải xin phép trước khi vào đoạn găng {phần vào} l Tiến trình khi thoát khỏi đoạn găng thực hiện {phần ra} l Cấu trúc tổng quát của một tiến trình"
ea73ad6304ed438f7e7d4c59ddd227a1:112,ea73ad6304ed438f7e7d4c59ddd227a1,112,113,,,257,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.1 Khái niệm tài nguyên găng Phân loại các phương pháp l Các công cụ cấp thấp l Phương pháp khóa trong l Phương pháp kiểm tra và xác lập l Kỹ thuật đèn báo l Các công cụ cấp cao l Monitor
ea73ad6304ed438f7e7d4c59ddd227a1:113,ea73ad6304ed438f7e7d4c59ddd227a1,113,114,,,252,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.2. Phương pháp khóa trong lKhái niệm tài nguyên găng lPhương pháp khóa trong lPhương pháp kiểm tra và xác lập lKỹ thuật đèn báo lVí dụ về đồng bộ tiến trình lCông cụ điều độ cấp cao
ea73ad6304ed438f7e7d4c59ddd227a1:114,ea73ad6304ed438f7e7d4c59ddd227a1,114,115,,,408,"Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.2. Phương pháp khóa trong l Mỗi t/trình dùng một byte trong vùng nhớ chung làm khóa l Tiến trình vào đoạn găng, đóng khoá (byte khóa: true) l Tiến trình thoát khỏi đoạn găng, mở khóa (byte khóa: false) l Tiến trình muốn vào đoạn găng: kiểm tra khóa của tiến trình còn lại l Đang khóa ⇒ Đợi l Đang mở ⇒ Được quyền vào đoạn găng Nguyên tắc"
ea73ad6304ed438f7e7d4c59ddd227a1:115,ea73ad6304ed438f7e7d4c59ddd227a1,115,116,,,257,"Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.2. Phương pháp khóa trong l Share var C1,C2 Boolean // Các biến dùng chung làm khóa l Khởi tạo C1 = C2 = false //Tài nguyên găng đang tự do Thuật toán điều độ Tiến trình P1 Tiến trình P2"
ea73ad6304ed438f7e7d4c59ddd227a1:116,ea73ad6304ed438f7e7d4c59ddd227a1,116,117,,,257,"Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.2. Phương pháp khóa trong l Share var C1,C2 Boolean // Các biến dùng chung làm khóa l Khởi tạo C1 = C2 = false //Tài nguyên găng đang tự do Thuật toán điều độ Tiến trình P1 Tiến trình P2"
ea73ad6304ed438f7e7d4c59ddd227a1:117,ea73ad6304ed438f7e7d4c59ddd227a1,117,118,,,351,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.2. Phương pháp khóa trong lĐiều độ chưa hợp lý lHai t/trình yêu cầu tài nguyên tại một thời điểm lVấn đề loại trừ lẫn nhau (trường hợp 1) lVấn đề tiến triển (trường hợp 2) lNguyên nhân: Do tách rời giữa lKiểm tra quyền vào đoạn găng lXác lập quyền sử dụng tài nguyên găng Nhận xét
ea73ad6304ed438f7e7d4c59ddd227a1:118,ea73ad6304ed438f7e7d4c59ddd227a1,118,119,,,202,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.2. Phương pháp khóa trong l Sử dụng biến turn để chỉ ra tiến trình được quyền ưu tiên Thuật toán Dekker Tiến trình P1 Tiến trình P2
ea73ad6304ed438f7e7d4c59ddd227a1:119,ea73ad6304ed438f7e7d4c59ddd227a1,119,120,,,674,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.2. Phương pháp khóa trong lĐiều độ hợp lý cho mọi trường hợp lKhông đòi hỏi sự hỗ trợ đặc biệt của phần cứng nên có thể thực hiện bằng ngôn ngữ bất kỳ lQuá phức tạp khi số tiến trình và số tài nguyên tăng lên lPhải chờ đợi tích cực (busy waiting) trước khi vào đoạn găng l Khi chờ đợi vẫn phải thực hiện kiểm tra quyền vào đoạn găng => Lãng phí thời gian của processor Ghi chú: Thuật toán có thể thực hiện sai trong một số trường hợp l CPU cho phép thực hiện các lệnh không đúng trật tự l Chương trình dịch thực hiện tối ưu hóa khi sinh mã l Các mã bất biến bên trong vòng lặp được đưa ra ngoài Nhận xét
ea73ad6304ed438f7e7d4c59ddd227a1:120,ea73ad6304ed438f7e7d4c59ddd227a1,120,121,,,275,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.3 Phương pháp kiểm tra và xác lập (Test anh Set) lKhái niệm tài nguyên găng lPhương pháp khóa trong lPhương pháp kiểm tra và xác lập lKỹ thuật đèn báo lVí dụ về đồng bộ tiến trình lCông cụ điều độ cấp cao
ea73ad6304ed438f7e7d4c59ddd227a1:121,ea73ad6304ed438f7e7d4c59ddd227a1,121,122,,,622,"Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.3 Phương pháp kiểm tra và xác lập (Test anh Set) l Sử dụng sự hỗ trợ từ phần cứng l Phần cứng cung cấp các câu lệnh xử lý không tách rời l Kiểm tra và thay đổi nội dung của một word boolean TestAndSet(VAR boolean target) { boolean rv = target; target = true; return rv; } l Hoán đổi nội dung của 2 word khác nhau void Swap(VAR boolean , VAR boolean b) { boolean temp = a; a = b; b = temp; } l Xử lý không tách rời (atomically) l Khối lệnh không thể bị ngắt trong khi đang thực hiện l Được gọi đồng thời, sẽ được thực hiện theo thứ tự bất kỳ Nguyên tắc"
ea73ad6304ed438f7e7d4c59ddd227a1:122,ea73ad6304ed438f7e7d4c59ddd227a1,122,123,,,327,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.3 Phương pháp kiểm tra và xác lập (Test anh Set) l Biến phân chia Boolean: Lock: trạng thái của tài nguyên: l Bị khóa (Lock=true) l Tự do (Lock=false) l Khởi tạo: Lock = false ⇒ Tài nguyên tự do l Thuật toán cho tiến trình Pi Thuật toán với lệnh TestAndSet
ea73ad6304ed438f7e7d4c59ddd227a1:123,ea73ad6304ed438f7e7d4c59ddd227a1,123,124,,,323,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.3 Phương pháp kiểm tra và xác lập (Test anh Set) l Biến phân chia Lock cho biết trạng thái tài nguyên l Biến địa phương cho mỗi tiến trình: Key: Boolean l Khởi tạo: Lock = false ⇒ Tài nguyên tự do l Thuật toán cho tiến trình Pi Thuật toán với lệnh Swap
ea73ad6304ed438f7e7d4c59ddd227a1:124,ea73ad6304ed438f7e7d4c59ddd227a1,124,125,,,527,"Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.3.Phương pháp kiểm tra và xác lập (Test anh Set) lĐơn giản, không phức tạp khi số tiến trình và số đoạn găng tăng lên lCác tiến trình phải chờ đợi tích cực trước khi vào đoạn găng l Luôn kiểm tra xem tài nguyên găng đã được giải phóng chưa ⇒ Sử dụng Processor không hiệu quả lKhông đảm bảo yêu cầu chờ đợi hữu hạn l Tiến trình được vào đoạn găng tiếp theo, sẽ phụ thuộc thời điểm giải phóng tài nguyên của tiến trình đang chiếm giữ ⇒ Cần khắc phục Nhận xét"
ea73ad6304ed438f7e7d4c59ddd227a1:125,ea73ad6304ed438f7e7d4c59ddd227a1,125,126,,,119,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.3.Phương pháp kiểm tra và xác lập (Test anh Set)
ea73ad6304ed438f7e7d4c59ddd227a1:126,ea73ad6304ed438f7e7d4c59ddd227a1,126,127,,,245,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.4 Kỹ thuật đèn báo lKhái niệm tài nguyên găng lPhương pháp khóa trong lPhương pháp kiểm tra và xác lập lKỹ thuật đèn báo lVí dụ về đồng bộ tiến trình lCông cụ điều độ cấp cao
ea73ad6304ed438f7e7d4c59ddd227a1:127,ea73ad6304ed438f7e7d4c59ddd227a1,127,128,,,110,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.4. Kỹ thuật đèn báo Đèn báo (Semaphore)
ea73ad6304ed438f7e7d4c59ddd227a1:128,ea73ad6304ed438f7e7d4c59ddd227a1,128,129,,,108,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.4. Kỹ thuật đèn báo Sử dụng đèn báo I
ea73ad6304ed438f7e7d4c59ddd227a1:129,ea73ad6304ed438f7e7d4c59ddd227a1,129,130,,,109,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.4. Kỹ thuật đèn báo Sử dụng đèn báo II
ea73ad6304ed438f7e7d4c59ddd227a1:130,ea73ad6304ed438f7e7d4c59ddd227a1,130,131,,,114,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.4. Kỹ thuật đèn báo Hủy bỏ chờ đợi tích cực
ea73ad6304ed438f7e7d4c59ddd227a1:131,ea73ad6304ed438f7e7d4c59ddd227a1,131,132,,,106,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.4. Kỹ thuật đèn báo Cài đặt đèn báo
ea73ad6304ed438f7e7d4c59ddd227a1:132,ea73ad6304ed438f7e7d4c59ddd227a1,132,133,,,106,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.4. Kỹ thuật đèn báo Sử dụng đèn báo
ea73ad6304ed438f7e7d4c59ddd227a1:133,ea73ad6304ed438f7e7d4c59ddd227a1,133,134,,,174,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.4. Kỹ thuật đèn báo Ví dụ điều độ P1 P2 P3 running running running Semaphore S S.Value = 1 S.Ptr NULL t
ea73ad6304ed438f7e7d4c59ddd227a1:134,ea73ad6304ed438f7e7d4c59ddd227a1,134,135,,,182,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.4. Kỹ thuật đèn báo Ví dụ điều độ P1 P2 P3 running running running Semaphore S S.Value = 0 S.Ptr NULL t P1→P(S)
ea73ad6304ed438f7e7d4c59ddd227a1:135,ea73ad6304ed438f7e7d4c59ddd227a1,135,136,,,189,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.4. Kỹ thuật đèn báo Ví dụ điều độ P1 P2 P3 running block running Semaphore S S.Value = -1 S.Ptr t P1→P(S) P2→P(S) PCB2
ea73ad6304ed438f7e7d4c59ddd227a1:136,ea73ad6304ed438f7e7d4c59ddd227a1,136,137,,,200,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.4. Kỹ thuật đèn báo Ví dụ điều độ P1 P2 P3 running block block Semaphore S S.Value = -2 S.Ptr t P1→P(S) P2→P(S) PCB2 P3→P(S) PCB3
ea73ad6304ed438f7e7d4c59ddd227a1:137,ea73ad6304ed438f7e7d4c59ddd227a1,137,138,,,205,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.4. Kỹ thuật đèn báo Ví dụ điều độ P1 P2 P3 running running block Semaphore S S.Value = -1 S.Ptr t P1→P(S) P2→P(S) PCB3 P3→P(S) P1→V(S)
ea73ad6304ed438f7e7d4c59ddd227a1:138,ea73ad6304ed438f7e7d4c59ddd227a1,138,139,,,214,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.4. Kỹ thuật đèn báo Ví dụ điều độ P1 P2 P3 running running running Semaphore S S.Value = 0 S.Ptr t P1→P(S) P2→P(S) P3→P(S) P1→V(S) P2→V(S) NULL
ea73ad6304ed438f7e7d4c59ddd227a1:139,ea73ad6304ed438f7e7d4c59ddd227a1,139,140,,,222,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.4. Kỹ thuật đèn báo Ví dụ điều độ P1 P2 P3 running running running Semaphore S S.Value = 1 S.Ptr t P1→P(S) P2→P(S) P3→P(S) P1→V(S) P2→V(S) P3→V(S) NULL
ea73ad6304ed438f7e7d4c59ddd227a1:140,ea73ad6304ed438f7e7d4c59ddd227a1,140,141,,,222,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.4. Kỹ thuật đèn báo Ví dụ điều độ P1 P2 P3 running running running Semaphore S S.Value = 1 S.Ptr t P1→P(S) P2→P(S) P3→P(S) P1→V(S) P2→V(S) P3→V(S) NULL
ea73ad6304ed438f7e7d4c59ddd227a1:141,ea73ad6304ed438f7e7d4c59ddd227a1,141,142,,,231,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.4. Kỹ thuật đèn báo l Dễ dàng áp dụng cho các hệ thống phức tạp l Không tồn tại hiện tượng chờ đợi tích cực l Hiệu quả sử dụng phụ thuộc vào người dùng Nhận xét
ea73ad6304ed438f7e7d4c59ddd227a1:142,ea73ad6304ed438f7e7d4c59ddd227a1,142,143,,,444,"Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.4. Kỹ thuật đèn báo lCác phép xử lý P(S) và V(S) là không phân chia được ⇒bản thân P(S) và V(S) cũng là 2 tài nguyên găng ⇒Cũng cần điều độ. lHệ thống một VXL: Cấm ngắt khi thực hiện wait(), signal() lHệ thống nhiều vi xử lý lKhông thể cấm ngắt trên VXL khác lCó thể dùng phương pháp khoa trong ⇒ Hiện tượng chờ đợi tích cực, nhưng thời gian chờ đợi ngắn (10 lệnh) Nhận xét"
ea73ad6304ed438f7e7d4c59ddd227a1:143,ea73ad6304ed438f7e7d4c59ddd227a1,143,144,,,788,"Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.4. Kỹ thuật đèn báo l CreateSemaphore(. . .) : Tạo một Semaphore l LPSECURITY_ATTRIBUTES lpSemaphoreAttributes ⇒ Trỏ tới cấu trúc an ninh, thẻ trả về được kế thừa? l LONG InitialCount, ⇒ Giá trị khởi tạo cho đối tượng Semaphore l LONG MaximumCount, ⇒ Giá trị lớn nhất của đối tượng Semaphore l LPCTSTR lpName ⇒ Tên của đối tượng Semaphore Ví dụ CreateSemaphore(NULL,0,1,NULL); l Trả về thẻ (HANDLE) của đối tượng Semaphore hoặc NULL l WaitForSingleObject(HANDLE h, DWORD time) l ReleaseSemaphore (. . .) l HANDLE hSemaphore, ⇐Thẻ của đối tượng Semaphore l LONG lReleaseCount, ⇐Giá trị được tăng lên, l LPLONG lpPreviousCount ⇐Giá trị trước đó l Ví dụ: ReleaseSemaphore(S, 1, NULL); Đối tượng Semaphore trong WIN32 API"
ea73ad6304ed438f7e7d4c59ddd227a1:144,ea73ad6304ed438f7e7d4c59ddd227a1,144,145,,,98,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.4. Kỹ thuật đèn báo Ví dụ 1
ea73ad6304ed438f7e7d4c59ddd227a1:145,ea73ad6304ed438f7e7d4c59ddd227a1,145,146,,,98,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.4. Kỹ thuật đèn báo Ví dụ 1
ea73ad6304ed438f7e7d4c59ddd227a1:146,ea73ad6304ed438f7e7d4c59ddd227a1,146,147,,,256,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.5 Ví dụ về đồng bộ tiến trình lKhái niệm tài nguyên găng lPhương pháp khóa trong lPhương pháp kiểm tra và xác lập lKỹ thuật đèn báo lVí dụ về đồng bộ tiến trình lCông cụ điều độ cấp cao
ea73ad6304ed438f7e7d4c59ddd227a1:147,ea73ad6304ed438f7e7d4c59ddd227a1,147,148,,,332,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.5 Ví dụ về đồng bộ tiến trình lNgười sản xuất-người tiêu thụ (Producer- Consumer) lBữa ăn tối của triết gia (Dining Philosophers) lNgười đọc và biên tập viên (Readers-Writers) lNgười thợ cắt tóc ngủ gật (Sleeping Barber) lBathroom Problem lĐồng bộ theo Barriers
ea73ad6304ed438f7e7d4c59ddd227a1:148,ea73ad6304ed438f7e7d4c59ddd227a1,148,149,,,491,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.5 Ví dụ về đồng bộ tiến trình Bài toán người sản xuất (producer)-người tiêu thụ(consumer) Producer Consumer while(1) { /*produce an item in Buffer*/ while (Counter == BUFFER_SIZE) ; /*do nothing*/ Buffer[IN] = nextProduced; IN = (IN + 1) % BUFFER_SIZE; Counter++; } while(1){ while(Counter == 0) ; /*do nothing*/ nextConsumed = Buffer[OUT]; OUT =(OUT + 1) % BUFFER_SIZE; Counter--; /*consume the item in nextConsumed*/ }
ea73ad6304ed438f7e7d4c59ddd227a1:149,ea73ad6304ed438f7e7d4c59ddd227a1,149,150,,,550,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.5 Ví dụ về đồng bộ tiến trình Bài toán người sản xuất (producer)-người tiêu thụ(consumer) Producer Consumer while(1) { /*produce an in Buffer */ if(Counter==SIZE) block(); /*do nothing*/ Buffer[IN] = nextProduced; IN = (IN + 1) % BUFFER_SIZE; Counter++; if(Counter==1) wakeup(Consumer); } while(1){ if(Counter == 0) block(); /*do nothing*/ nextConsumed = Buffer[OUT]; OUT =(OUT + 1) % BUFFER_SIZE; Counter--; if(Counter==SIZE-1) wakeup(Producer); /*consume the item in Buffer*/ }
ea73ad6304ed438f7e7d4c59ddd227a1:150,ea73ad6304ed438f7e7d4c59ddd227a1,150,151,,,628,"l Nhiều tiến trình (Readers) cùng truy nhập một cơ sở dữ liệu (CSDL) l Một số tiến trình (Writers) cập nhật cơ sở dữ liệu l Cho phép số lượng tùy ý các tiến trình Readers cùng truy nhập CSDL l Đang tồn tại một tiến trình Reader truy cập CSDL, mọi tiến trình Readers khác mới xuất hiện đều được truy cập CSDL l (Tiến trình Writers phải xếp hàng chờ đợi) l Chỉ cho phép một tiến trình Writers cập nhật CSDL tại một thời điểm. l Vấn đề không trưng dụng. Các tiến trình ở trong đoạn găng mà không bị ngắt Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.5 Ví dụ về đồng bộ tiến trình Người đọc và biên tập viên"
ea73ad6304ed438f7e7d4c59ddd227a1:151,ea73ad6304ed438f7e7d4c59ddd227a1,151,152,,,469,"l N ghế đợi dành cho khách hàng l Một người thợ chỉ có thể cắt tóc cho một khách hàng tại một thời điểm l Không có khách hàng đợi, thợ cắt tóc ngủ l Khi một khách hàng tới l Nếu thợ cắt tóc đang ngủ⇒Đánh thức anh ta dậy làm việc l Nếu thợ cắt tóc đang làm việc l Không còn ghế đợi trống ⇒ bỏ đi l Còn ghế đợi trống⇒ Ngồi đợi Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.5 Ví dụ về đồng bộ tiến trình Người thợ cắt tóc ngủ gật (Sleeping Barber)"
ea73ad6304ed438f7e7d4c59ddd227a1:152,ea73ad6304ed438f7e7d4c59ddd227a1,152,153,,,573,"Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.5 Ví dụ về đồng bộ tiến trình Bathroom Problem lA bathroom is to be used by both men and women, but not at the same time lIf the bathroom is empty, then anyone can enter lIf the bathroom is occupied, then only a person of the same sex as the occupant(s) may enter lThe number of people that may be in the bathroom at the same time is limited Bài toán l Yêu cầu cài đặt bài toán thỏa mãn các ràng buộc l Có 2 kiểu tiến trình male() và female() l Mỗi t/trình ở trong Bathroom một khoảng t/gian ngẫu nhiên"
ea73ad6304ed438f7e7d4c59ddd227a1:153,ea73ad6304ed438f7e7d4c59ddd227a1,153,154,,,162,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.5 Ví dụ về đồng bộ tiến trình Đồng bộ barriers l Các tiến trình hướng tới một Ba-ri-e chung
ea73ad6304ed438f7e7d4c59ddd227a1:154,ea73ad6304ed438f7e7d4c59ddd227a1,154,155,,,255,"Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.5 Ví dụ về đồng bộ tiến trình Đồng bộ barriers l Các tiến trình hướng tới một Ba-ri-e chung l Khi đạt tới Ba-ri-e, tất cả các tiến trình đều bị block ngoại trừ tiến trình đến cuối cùng"
ea73ad6304ed438f7e7d4c59ddd227a1:155,ea73ad6304ed438f7e7d4c59ddd227a1,155,156,,,353,"Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.5 Ví dụ về đồng bộ tiến trình Đồng bộ barriers l Các tiến trình hướng tới một Ba-ri-e chung l Khi đạt tới Ba-ri-e, tất cả các tiến trình đều bị block ngoại trừ tiến trình đến cuối cùng l Khi tiến trình cuối tới, đánh thức tất cả các tiến trình đang bị block và cùng vượt qua Ba-ri-e"
ea73ad6304ed438f7e7d4c59ddd227a1:156,ea73ad6304ed438f7e7d4c59ddd227a1,156,157,,,537,"Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.5 Ví dụ về đồng bộ tiến trình Bài toán tạo phân tử H2O l Có 2 kiểu tiến trình (luồng): oxygen and hydrogen l Để kết hợp các tiến trình thành một phân tử nước, cần một Ba-ri-e để các tiến trình phải đợi cho tới khi một phân tử nước sẵn sàng được tạo ra. l Khi mỗi tiến trình vượt qua Ba-ri-e, nó phải kích hoạt liên kết. l Tất cả các tiến trình trong cùng một phân tử nước phải tạo liên kết, trước khi một tiến trình của phân tử nước khác gọi tới thủ tục tạo liên kết"
ea73ad6304ed438f7e7d4c59ddd227a1:157,ea73ad6304ed438f7e7d4c59ddd227a1,157,158,,,537,"Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.5 Ví dụ về đồng bộ tiến trình Bài toán tạo phân tử H2O l Có 2 kiểu tiến trình (luồng): oxygen and hydrogen l Để kết hợp các tiến trình thành một phân tử nước, cần một Ba-ri-e để các tiến trình phải đợi cho tới khi một phân tử nước sẵn sàng được tạo ra. l Khi mỗi tiến trình vượt qua Ba-ri-e, nó phải kích hoạt liên kết. l Tất cả các tiến trình trong cùng một phân tử nước phải tạo liên kết, trước khi một tiến trình của phân tử nước khác gọi tới thủ tục tạo liên kết"
ea73ad6304ed438f7e7d4c59ddd227a1:158,ea73ad6304ed438f7e7d4c59ddd227a1,158,159,,,537,"Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.5 Ví dụ về đồng bộ tiến trình Bài toán tạo phân tử H2O l Có 2 kiểu tiến trình (luồng): oxygen and hydrogen l Để kết hợp các tiến trình thành một phân tử nước, cần một Ba-ri-e để các tiến trình phải đợi cho tới khi một phân tử nước sẵn sàng được tạo ra. l Khi mỗi tiến trình vượt qua Ba-ri-e, nó phải kích hoạt liên kết. l Tất cả các tiến trình trong cùng một phân tử nước phải tạo liên kết, trước khi một tiến trình của phân tử nước khác gọi tới thủ tục tạo liên kết"
ea73ad6304ed438f7e7d4c59ddd227a1:159,ea73ad6304ed438f7e7d4c59ddd227a1,159,160,,,537,"Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.5 Ví dụ về đồng bộ tiến trình Bài toán tạo phân tử H2O l Có 2 kiểu tiến trình (luồng): oxygen and hydrogen l Để kết hợp các tiến trình thành một phân tử nước, cần một Ba-ri-e để các tiến trình phải đợi cho tới khi một phân tử nước sẵn sàng được tạo ra. l Khi mỗi tiến trình vượt qua Ba-ri-e, nó phải kích hoạt liên kết. l Tất cả các tiến trình trong cùng một phân tử nước phải tạo liên kết, trước khi một tiến trình của phân tử nước khác gọi tới thủ tục tạo liên kết"
ea73ad6304ed438f7e7d4c59ddd227a1:160,ea73ad6304ed438f7e7d4c59ddd227a1,160,161,,,537,"Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.5 Ví dụ về đồng bộ tiến trình Bài toán tạo phân tử H2O l Có 2 kiểu tiến trình (luồng): oxygen and hydrogen l Để kết hợp các tiến trình thành một phân tử nước, cần một Ba-ri-e để các tiến trình phải đợi cho tới khi một phân tử nước sẵn sàng được tạo ra. l Khi mỗi tiến trình vượt qua Ba-ri-e, nó phải kích hoạt liên kết. l Tất cả các tiến trình trong cùng một phân tử nước phải tạo liên kết, trước khi một tiến trình của phân tử nước khác gọi tới thủ tục tạo liên kết"
ea73ad6304ed438f7e7d4c59ddd227a1:161,ea73ad6304ed438f7e7d4c59ddd227a1,161,162,,,567,"Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.5 Ví dụ về đồng bộ tiến trình Bữa ăn tối của triết gia l 5 triết gia ăn tối quanh một bàn tròn l Trước mỗi triết gia là một đĩa mì l Giữa 2 đĩa kề nhau là một cái dĩa (fork) l Các triết gia thực hiện luân phiên, liên tục 2 việc :Ăn và Nghĩ l Mỗi triết gia cần 2 cái dĩa để ăn l Chỉ lấy một dĩa tại một thời điểm l Cái bên trái rồi tới cái bên phải l Ăn xong, triết gia để dĩa vào vị trí cũ Bài toán đồng bộ hóa tiến trình nổi tiếng, thể hiện tình trạng nhiều tiến trình phân chia nhiều tài nguyên"
ea73ad6304ed438f7e7d4c59ddd227a1:162,ea73ad6304ed438f7e7d4c59ddd227a1,162,163,,,472,"Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.5 Ví dụ về đồng bộ tiến trình Vấn đề triết gia ăn tối: Phương pháp đơn giản l Mỗi chiếc dĩa là một tài nguyên găng, được điều độ bởi một đèn báo fork[i] l Semaphore fork[5] = {1, 1, 1, 1, 1}; l Thuật toán cho Triết gia Pi l Nếu tất cả các triết gia cùng muốn ăn l Cùng lấy chiếc dĩa bên trái (gọi tới: wait(fork[i])) l Cùng đợi lấy chiếc dĩa bên phải (gọi tới: wait(fork[(i+1)%5])) ⇒ Bế tắc (deadlock)"
ea73ad6304ed438f7e7d4c59ddd227a1:163,ea73ad6304ed438f7e7d4c59ddd227a1,163,164,,,357,"Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.5 Ví dụ về đồng bộ tiến trình Vấn đề triết gia ăn tối: Giải pháp 1 l Chỉ cho phép một nhà triết học lấy dĩa tại một thời điểm l Semaphore mutex ← 1; l Thuật toán cho Triết gia Pi l Có thể làm cho 2 triết gia không kề nhau cùng được ăn tại một thời điểm (P1: ăn, P2: chiếm mutex⇒ P3 đợi)"
ea73ad6304ed438f7e7d4c59ddd227a1:164,ea73ad6304ed438f7e7d4c59ddd227a1,164,165,,,300,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.5 Ví dụ về đồng bộ tiến trình Vấn đề triết gia ăn tối: Giải pháp 2 l Thứ tự lấy dĩa của các triết gia khác nhau l Triết gia số hiệu chẵn lấy dĩa trái trước l Triết gia số hiệu lẻ lấy dĩa phải trước l Giải quyết được vấn đề bế tắc
ea73ad6304ed438f7e7d4c59ddd227a1:165,ea73ad6304ed438f7e7d4c59ddd227a1,165,166,,,879,"Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.5 Ví dụ về đồng bộ tiến trình Vấn đề triết gia ăn tối: Một số giải pháp khác l Trả lại dĩa bên trái nếu không lấy được cái bên phải l Kiểm tra dĩa phải sẵn sàng trước khi gọi wait(fork[(i+1)%5]) l Nếu không sẵn có: trả lại dĩa trái, đợi một thời gian rồi thử lại l Không bị bế tắc, nhưng không tiến triển:nạn đói (starvation) l Thực hiện trong thực tế, nhưng không đảm bảo về lý thuyết của đề bài l Sử dụng đèn báo đồng thời PSim(S1, S2, . . . , Sn) l Thu được tất cả đèn báo cùng một thời điểm hoặc không có bất kỳ đèn báo nào l Thao tác PSim(S1, S2, . . . , Sn) sẽ block() tiến trình/luồng gọi khi có bất kỳ một đèn báo nào không thể thu được l Thuật toán l Khó cài đặt đèn báo đồng thời l Giải pháp đề xuất bởi Tanenbaum (Tanenbaum 2001) PSim(fork[i], fork[(i+1)% 5]); { Ăn} VSim(fork[i], fork[(i+1)% 5]);"
ea73ad6304ed438f7e7d4c59ddd227a1:166,ea73ad6304ed438f7e7d4c59ddd227a1,166,167,,,134,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.5 Ví dụ về đồng bộ tiến trình Vấn đề triết gia ăn tối: Minh họa
ea73ad6304ed438f7e7d4c59ddd227a1:167,ea73ad6304ed438f7e7d4c59ddd227a1,167,168,,,115,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.5 Ví dụ về đồng bộ tiến trình True problem ?
ea73ad6304ed438f7e7d4c59ddd227a1:168,ea73ad6304ed438f7e7d4c59ddd227a1,168,169,,,252,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.6 Công cụ điều độ cấp cao lKhái niệm tài nguyên găng lPhương pháp khóa trong lPhương pháp kiểm tra và xác lập lKỹ thuật đèn báo lVí dụ về đồng bộ tiến trình lCông cụ điều độ cấp cao
ea73ad6304ed438f7e7d4c59ddd227a1:169,ea73ad6304ed438f7e7d4c59ddd227a1,169,170,,,546,"Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.6 Công cụ điều độ cấp cao Giới thiệu l Là một kiểu dữ liệu đặc biệt, được đề xuất bởi HOARE 1974 l Bao gồm các thủ tục, dữ liệu cục bộ, đoạn mã khởi tạo l Các tiến trình chỉ có thể truy nhập tới các biến bằng cách gọi tới các thủ tục trong Monitor l Tại một thời điểm chỉ có một tiến trình được quyền sử dụng Monitor l Tiến trình khác muốn sử dụng, phải chờ đợi l Cho phép các tiến trình đợi trong Monitor l Sử dụng các biến điều kiện (condition variable) Cú pháp của Monitor"
ea73ad6304ed438f7e7d4c59ddd227a1:170,ea73ad6304ed438f7e7d4c59ddd227a1,170,171,,,104,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.6 Công cụ điều độ cấp cao Mô hình
ea73ad6304ed438f7e7d4c59ddd227a1:171,ea73ad6304ed438f7e7d4c59ddd227a1,171,172,,,111,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.6 Công cụ điều độ cấp cao Biến điều kiện
ea73ad6304ed438f7e7d4c59ddd227a1:172,ea73ad6304ed438f7e7d4c59ddd227a1,172,173,,,104,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.6 Công cụ điều độ cấp cao Mô hình
ea73ad6304ed438f7e7d4c59ddd227a1:173,ea73ad6304ed438f7e7d4c59ddd227a1,173,174,,,134,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.6 Công cụ điều độ cấp cao Sử dụng Monitor: một tài nguyên chung
ea73ad6304ed438f7e7d4c59ddd227a1:174,ea73ad6304ed438f7e7d4c59ddd227a1,174,175,,,125,Chương 2 Quản lí tiến trình 4. Tài nguyên găng và điều độ tiến trình 4.6 Công cụ điều độ cấp cao Bài toán Producer - Consumer
ea73ad6304ed438f7e7d4c59ddd227a1:175,ea73ad6304ed438f7e7d4c59ddd227a1,175,176,,,138,Chương 2 Quản lí tiến trình ① Tiến trình ② Luồng (Thread) ③ Điều phối CPU ④ Tài nguyên găng và điều độ tiến trình ⑤ Bế tắc và xử lý bế tắc
ea73ad6304ed438f7e7d4c59ddd227a1:176,ea73ad6304ed438f7e7d4c59ddd227a1,176,179,,,226,Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.1. Khái niệm bế tắc(Deadlock) l Khái niệm bế tắc l Điều kiện xảy ra bế tắc l Các phương pháp xử lý bế tắc l Phòng ngừa bế tắc l Phòng tránh bế tắc l Nhận biết và khắc phục
ea73ad6304ed438f7e7d4c59ddd227a1:177,ea73ad6304ed438f7e7d4c59ddd227a1,177,180,,,638,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.1. Khái niệm bế tắc(Deadlock) l Hệ thống gồm nhiều tiến trình hoạt động đồng thời cùng sử dụng tài nguyên l Tài nguyên có nhiều loại (VD: CPU, bộ nhớ,..). l Mỗi loại tài nguyên có nhiều đơn vị (VD: 2 CPU, 5 máy in..) l Mỗi tiến trình thường gồm dãy liên tục các thao tác l Đòi hỏi tài nguyên: Nếu tài nguyên không có sẵn (đang được s/dụng bởi tiến trình khác) ⇒ tiến trình yêu cầu phải đợi l Sử dụng tài nguyên theo yêu cầu (in ấn, đọc dữ liệu...) l Giải phóng tài nguyên được cấp l Khi các tiến trình dùng chung ít nhất 2 tài nguyên, hệ thống có thể gặp ""nguy hiểm"" Khái niệm bế tắc"
ea73ad6304ed438f7e7d4c59ddd227a1:178,ea73ad6304ed438f7e7d4c59ddd227a1,178,181,,,357,Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.1. Khái niệm bế tắc(Deadlock) l Xét ví dụ: Hệ thống có hai tiến trình P1 & P2 l Hai tiến trình P1 & P2 dùng chung hai tài nguyên R1 & R2 l R1 được điều độ bởi đèn báo S1 (S1 ← 1) l R2 được điều độ bởi đèn báo S2 (S2 ← 1) l Đoạn mã cho P1 và P2 Khái niệm bế tắc P(S1) P(S2) { Sử dụng R1&R2 } V(S1) V(S2)
ea73ad6304ed438f7e7d4c59ddd227a1:179,ea73ad6304ed438f7e7d4c59ddd227a1,179,182,,,234,Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.1. Khái niệm bế tắc(Deadlock) Ví dụ P(S1) P(S2) { Sử dụng R1&R2 } V(S1) V(S2) P(S1) P(S2) { Sử dụng R1&R2 } V(S1) V(S2) Process P1 Process P2 Process P1 Process P2 t S2 = 1 S1 = 1
ea73ad6304ed438f7e7d4c59ddd227a1:180,ea73ad6304ed438f7e7d4c59ddd227a1,180,183,,,240,Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.1. Khái niệm bế tắc(Deadlock) Ví dụ P(S1) P(S2) { Sử dụng R1&R2 } V(S1) V(S2) P(S1) P(S2) { Sử dụng R1&R2 } V(S1) V(S2) Process P1 Process P2 Process P1 Process P2 t S2 = 1 S1 = 0 P(S1)
ea73ad6304ed438f7e7d4c59ddd227a1:181,ea73ad6304ed438f7e7d4c59ddd227a1,181,184,,,274,Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.1. Khái niệm bế tắc(Deadlock) Ví dụ P(S1) P(S2) { Sử dụng R1&R2 } V(S1) V(S2) P(S1) P(S2) { Sử dụng R1&R2 } V(S1) V(S2) Process P1 Process P2 Process P1 Process P2 t S2 = 1 S1 = -1 P(S1) P(S1) P2 block() Vào hàng đợi R1
ea73ad6304ed438f7e7d4c59ddd227a1:182,ea73ad6304ed438f7e7d4c59ddd227a1,182,185,,,280,Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.1. Khái niệm bế tắc(Deadlock) Ví dụ P(S1) P(S2) { Sử dụng R1&R2 } V(S1) V(S2) P(S1) P(S2) { Sử dụng R1&R2 } V(S1) V(S2) Process P1 Process P2 Process P1 Process P2 t S2 = 0 S1 = -1 P(S1) P(S1) P2 block() Vào hàng đợi R1 P(S2)
ea73ad6304ed438f7e7d4c59ddd227a1:183,ea73ad6304ed438f7e7d4c59ddd227a1,183,186,,,283,Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.1. Khái niệm bế tắc(Deadlock) Ví dụ P(S1) P(S2) { Sử dụng R1&R2 } V(S1) V(S2) P(S1) P(S2) { Sử dụng R1&R2 } V(S1) V(S2) Process P1 Process P2 Process P1 Process P2 t S2 = 0 S1 = 0 P(S1) P(S1) P(S2) Sử dụng R1&R2 V(S1) wakeup(P2)
ea73ad6304ed438f7e7d4c59ddd227a1:184,ea73ad6304ed438f7e7d4c59ddd227a1,184,187,,,317,Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.1. Khái niệm bế tắc(Deadlock) Ví dụ P(S1) P(S2) { Sử dụng R1&R2 } V(S1) V(S2) P(S1) P(S2) { Sử dụng R1&R2 } V(S1) V(S2) Process P1 Process P2 Process P1 Process P2 t S2 = -1 S1 = 0 P(S1) P(S1) P(S2) Sử dụng R1&R2 V(S1) wakeup(P2) P(S2) P2 block() Vào hàng đợi R2
ea73ad6304ed438f7e7d4c59ddd227a1:185,ea73ad6304ed438f7e7d4c59ddd227a1,185,188,,,295,Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.1. Khái niệm bế tắc(Deadlock) Ví dụ P(S1) P(S2) { Sử dụng R1&R2 } V(S1) V(S2) P(S1) P(S2) { Sử dụng R1&R2 } V(S1) V(S2) Process P1 Process P2 Process P1 Process P2 t S2 = 0 S1 = 0 P(S1) P(S1) P(S2) Sử dụng R1&R2 V(S1) P(S2) V(S2) wakeup(P2)
ea73ad6304ed438f7e7d4c59ddd227a1:186,ea73ad6304ed438f7e7d4c59ddd227a1,186,189,,,309,Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.1. Khái niệm bế tắc(Deadlock) Ví dụ P(S1) P(S2) { Sử dụng R1&R2 } V(S1) V(S2) P(S1) P(S2) { Sử dụng R1&R2 } V(S1) V(S2) Process P1 Process P2 Process P1 Process P2 t S2 = 0 S1 = 0 P(S1) P(S1) P(S2) Sử dụng R1&R2 V(S1) P(S2) V(S2) wakeup(P2) Sử dụng R1&R2
ea73ad6304ed438f7e7d4c59ddd227a1:187,ea73ad6304ed438f7e7d4c59ddd227a1,187,190,,,234,Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.1. Khái niệm bế tắc(Deadlock) Ví dụ P(S1) P(S2) { Sử dụng R1&R2 } V(S1) V(S2) P(S2) P(S1) { Sử dụng R1&R2 } V(S1) V(S2) Process P1 Process P2 Process P1 Process P2 t S2 = 1 S1 = 1
ea73ad6304ed438f7e7d4c59ddd227a1:188,ea73ad6304ed438f7e7d4c59ddd227a1,188,191,,,240,Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.1. Khái niệm bế tắc(Deadlock) Ví dụ P(S1) P(S2) { Sử dụng R1&R2 } V(S1) V(S2) P(S2) P(S1) { Sử dụng R1&R2 } V(S1) V(S2) Process P1 Process P2 Process P1 Process P2 t S2 = 1 S1 = 0 P(S1)
ea73ad6304ed438f7e7d4c59ddd227a1:189,ea73ad6304ed438f7e7d4c59ddd227a1,189,192,,,246,Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.1. Khái niệm bế tắc(Deadlock) Ví dụ P(S1) P(S2) { Sử dụng R1&R2 } V(S1) V(S2) P(S2) P(S1) { Sử dụng R1&R2 } V(S1) V(S2) Process P1 Process P2 Process P1 Process P2 t S2 = 0 S1 = 0 P(S1) P(S2)
ea73ad6304ed438f7e7d4c59ddd227a1:190,ea73ad6304ed438f7e7d4c59ddd227a1,190,193,,,280,Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.1. Khái niệm bế tắc(Deadlock) Ví dụ P(S1) P(S2) { Sử dụng R1&R2 } V(S1) V(S2) P(S2) P(S1) { Sử dụng R1&R2 } V(S1) V(S2) Process P1 Process P2 Process P1 Process P2 t S2 = -1 S1 = 0 P(S1) P(S2) P(S2) P1 block() Vào hàng đợi R2
ea73ad6304ed438f7e7d4c59ddd227a1:191,ea73ad6304ed438f7e7d4c59ddd227a1,191,194,,,314,Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.1. Khái niệm bế tắc(Deadlock) Ví dụ P(S1) P(S2) { Sử dụng R1&R2 } V(S1) V(S2) P(S2) P(S1) { Sử dụng R1&R2 } V(S1) V(S2) Process P1 Process P2 Process P1 Process P2 t S2 = -1 S1 = -1 P(S1) P(S2) P(S2) P1 block() Vào hàng đợi R2 P(S1) P2 block() Vào hàng đợi R1
ea73ad6304ed438f7e7d4c59ddd227a1:192,ea73ad6304ed438f7e7d4c59ddd227a1,192,195,,,323,Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.1. Khái niệm bế tắc(Deadlock) Ví dụ P(S1) P(S2) { Sử dụng R1&R2 } V(S1) V(S2) P(S2) P(S1) { Sử dụng R1&R2 } V(S1) V(S2) Process P1 Process P2 Process P1 Process P2 t S2 = -1 S1 = -1 P(S1) P(S2) P(S2) P1 block() Vào hàng đợi R2 P(S1) P2 block() Vào hàng đợi R1 Deadlock
ea73ad6304ed438f7e7d4c59ddd227a1:193,ea73ad6304ed438f7e7d4c59ddd227a1,193,196,,,254,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.1. Khái niệm bế tắc(Deadlock) Định nghĩa Bế tắc là tình trạng l Hai hay nhiều tiến trình cùng chờ đợi một sự kiện nào đó xảy ra l Nếu không có sự tác động gì từ bên ngoài, thì sự chờ đợi đó là vô hạn"
ea73ad6304ed438f7e7d4c59ddd227a1:194,ea73ad6304ed438f7e7d4c59ddd227a1,194,197,,,226,Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.1. Khái niệm bế tắc(Deadlock) l Khái niệm bế tắc l Điều kiện xảy ra bế tắc l Các phương pháp xử lý bế tắc l Phòng ngừa bế tắc l Phòng tránh bế tắc l Nhận biết và khắc phục
ea73ad6304ed438f7e7d4c59ddd227a1:195,ea73ad6304ed438f7e7d4c59ddd227a1,195,198,,,946,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.2. Điều kiện xảy ra bế tắc Cần có 4 điều kiện sau, không được thiếu điều kiện nào l Tồn tại tài nguyên găng l Tài nguyên được sử dụng theo mô hình không phân chia được l Chỉ có một tiến trình dung tài nguyên tại một thời điểm l Tiến trình khác cũng yêu cầu tài nguyên ⇒ yêu cầu phải được hoãn lại tới khi tài nguyên được giải phóng l Chờ đợi trước khi vào đoạn găng l Tiến trình không được vào đoạn găng phải xếp hàng chờ đợi. l Trong khi chờ đợi vẫn chiếm giữ các tài nguyên được cung cấp l Không có hệ thống phân phối lại tài nguyên găng l Tài nguyên không thể được trưng dụng l Tài nguyên được giải phỏng chỉ bởi tiến trình đang chiếm giữ khi đã hoàn thành nhiệm vụ l Chờ đợi vòng tròn l Tồn tại tập các tiến trình {P0, P2, . . . , Pn} đang đợi nhau theo kiểu: P0 → R1 → P1; P1 → R2 → P2; . . . Pn−1 → Rn →Pn; Pn → R0 → P0 l Chờ đợi vòng tròn tạo ra chu trình không kết thúc Điều kiện cần"
ea73ad6304ed438f7e7d4c59ddd227a1:196,ea73ad6304ed438f7e7d4c59ddd227a1,196,199,,,223,Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.2. Điều kiện xảy ra bế tắc l Tài nguyên găng l Chờ đợi trước khi vào đoạn găng l Trưng dụng tài nguyên găng l Chờ đợi vòng tròn Ví dụ: Bài toán bữa ăn tối của triết gia
ea73ad6304ed438f7e7d4c59ddd227a1:197,ea73ad6304ed438f7e7d4c59ddd227a1,197,200,,,587,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.2. Điều kiện xảy ra bế tắc l Dùng để mô hình hóa tình trạng bế tắc trong hệ thống l Là đồ thị định hướng gồm tập đỉnh V và tập cung E l Tập đỉnh V được chia thành 2 kiểu đỉnh l P = {P1, P2, . . . Pn} Tập chứa tất cả các tiến trình trong hệ thống l R = {R1, R2, . . . Rm} Tập chứa tất cả các kiểu tài nguyên trong hệ thống l Tập các cung E gồm 2 loại l Cung yêu cầu: đi từ tiến trình Pi tới tài nguyên Rj: Pi → Rj l Cung sử dụng: Đi từ tài nguyên Rj tới tiến trình Pi: Rj → Pi Đồ thị cung cấp tài nguyên (Resource Allocation Graph) I"
ea73ad6304ed438f7e7d4c59ddd227a1:198,ea73ad6304ed438f7e7d4c59ddd227a1,198,201,,,389,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.2. Điều kiện xảy ra bế tắc Khi một tiến trình Pi yêu cầu tài nguyên Rj l Cung yêu cầu Pi → Rj được chèn vào đồ thị l Nếu yêu cầu được thỏa mãn, cung yêu cầu chuyển thành cung sử dung Rj → Pi l Khi tiến trình Pi giải phóng tài nguyên Rj, cung sử dụng Rj → Pi bị xóa khỏi đồ thị Đồ thị cung cấp tài nguyên (Resource Allocation Graph) II"
ea73ad6304ed438f7e7d4c59ddd227a1:199,ea73ad6304ed438f7e7d4c59ddd227a1,199,202,,,480,Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.2. Điều kiện xảy ra bế tắc l Đỉnh kiểu tiến trình được thể hiện bằng hình tròn l Đỉnh kiểu tài nguyên được thể hiện bằng hình chữ nhật l Mỗi đơn vị của kiểu tài nguyên được biểu thị bằng một dấu chấm trong hình chữ nhật l Cung yêu cầu đi từ đỉnh tiến trình tới đỉnh tài nguyên l Cung sử dụng xuất phát từ dấu chấm bên trong đỉnh tài nguyên tới đỉnh tiến trình Đồ thị cung cấp tài nguyên: Biểu diễn đồ trong đồ thị P P P R R R
ea73ad6304ed438f7e7d4c59ddd227a1:200,ea73ad6304ed438f7e7d4c59ddd227a1,200,203,,,274,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.2. Điều kiện xảy ra bế tắc l Trạng thái hệ thống l 3 tiến trình P1, P2, P3 l 4 tài nguyên R1, R2, R3, R4 l P3 yêu cầu tài nguyên R4 l Xuất hiện cung yêu cầu P3 → R4 Đồ thị cung cấp tài nguyên: Ví dụ P1 P2 P3 R2 R3 R1 R4"
ea73ad6304ed438f7e7d4c59ddd227a1:201,ea73ad6304ed438f7e7d4c59ddd227a1,201,204,,,331,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.2. Điều kiện xảy ra bế tắc l Trạng thái hệ thống l 3 tiến trình P1, P2, P3 l 4 tài nguyên R1, R2, R3, R4 l P3 yêu cầu tài nguyên R4 l Xuất hiện cung yêu cầu P3 → R4 l Cung yêu cầu P3 → R4 chuyển thành cung sử dụng R4 → P3 Đồ thị cung cấp tài nguyên: Ví dụ P1 P2 P3 R2 R3 R1 R4"
ea73ad6304ed438f7e7d4c59ddd227a1:202,ea73ad6304ed438f7e7d4c59ddd227a1,202,205,,,403,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.2. Điều kiện xảy ra bế tắc l Trạng thái hệ thống l 3 tiến trình P1, P2, P3 l 4 tài nguyên R1, R2, R3, R4 l P3 yêu cầu tài nguyên R4 l Xuất hiện cung yêu cầu P3 → R4 l Cung yêu cầu P3 → R4 chuyển thành cung sử dụng R4 → P3 l P3 Giải phóng tài nguyên R4 l Cung sử dụng R4 → P3 bị xóa khỏi đồ thị Đồ thị cung cấp tài nguyên: Ví dụ P1 P2 P3 R2 R3 R1 R4"
ea73ad6304ed438f7e7d4c59ddd227a1:203,ea73ad6304ed438f7e7d4c59ddd227a1,203,206,,,515,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.2. Điều kiện xảy ra bế tắc l Trạng thái hệ thống l 3 tiến trình P1, P2, P3 l 4 tài nguyên R1, R2, R3, R4 l P3 yêu cầu tài nguyên R4 l Xuất hiện cung yêu cầu P3 → R4 l Cung yêu cầu P3 → R4 chuyển thành cung sử dụng R4 → P3 l P3 Giải phóng tài nguyên R4 l Cung sử dụng R4 → P3 bị xóa khỏi đồ thị l P3 yêu cầu tài nguyên R1 l Xuất hiện cung yêu cầu P3 → R1 l Trên đồ thị xuất hiện chu trình l Hệ thống bế tắc Đồ thị cung cấp tài nguyên: Ví dụ P1 P2 P3 R2 R3 R1 R4"
ea73ad6304ed438f7e7d4c59ddd227a1:204,ea73ad6304ed438f7e7d4c59ddd227a1,204,207,,,424,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.2. Điều kiện xảy ra bế tắc l Đồ thị không chứa chu trình, không bế tắc l Nếu đồ thị chứa đựng chu trình l Nếu tài nguyên chỉ có 1 đơn vị ⇒ Bế tắc l Nếu tài nguyên có nhiều hơn 1 đơn vị: có khả năng bế tắc Đồ thị cung cấp tài nguyên: Lập luận cơ bản Chu trình trên đồ thị và tình trạng bế tắc có liên quan ? P1 P3 P2 R2 R1 Đồ thị có chu trình nhưng hệ thống không bế tắc"
ea73ad6304ed438f7e7d4c59ddd227a1:205,ea73ad6304ed438f7e7d4c59ddd227a1,205,208,,,227,Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.3 Các phương pháp xử lý bế tắc l Khái niệm bế tắc l Điều kiện xảy ra bế tắc l Các phương pháp xử lý bế tắc l Phòng ngừa bế tắc l Phòng tránh bế tắc l Nhận biết và khắc phục
ea73ad6304ed438f7e7d4c59ddd227a1:206,ea73ad6304ed438f7e7d4c59ddd227a1,206,209,,,804,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.3. Các phương pháp xử lý bế tắc l Phòng ngừa l Áp dụng các biện pháp để đảm bảo hệ thống không bao giờ rơi vào tình trạng bế tắc l Tốn kém l Áp dụng cho hệ thống hay xảy ra bế tắc và tổn thất do bế tắc gây ra lớn l Phòng tránh l Kiểm tra từng yêu cầu tài nguyên của tiến trình và không chấp nhận yêu cầu nếu việc cung cấp tài nguyên có khả năng dẫn đến tình trạng bế tắc l Thường yêu cầu các thông tin phụ trợ l Áp dụng cho hệ thống ít xảy ra bế tắc nhưng tổn hại lớn l Nhận biết và khắc phục l Cho phép hệ thống hoạt động bình thường ⇒có thểrơi vào tình trạng bế tắc l Định kỳ kiểm tra xem bế tắc có đang xảy ra không l Nếu đang bế tắc, áp dụng các biện pháp loại bỏ bế tắc l Áp dụng cho hệ thống ít xảy ra bế tắc và thiệt hại không lớn Phương pháp"
ea73ad6304ed438f7e7d4c59ddd227a1:207,ea73ad6304ed438f7e7d4c59ddd227a1,207,210,,,216,Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.4 Phòng ngừa bế tắc l Khái niệm bế tắc l Điều kiện xảy ra bế tắc l Các phương pháp xử lý bế tắc l Phòng ngừa bế tắc l Phòng tránh bế tắc l Nhận biết và khắc phục
ea73ad6304ed438f7e7d4c59ddd227a1:208,ea73ad6304ed438f7e7d4c59ddd227a1,208,211,,,245,Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.4 Phòng ngừa bế tắc Tác động vào 1 trong 4 điều kiện cần của bế tắc để nó không xảy ra Tài nguyên găng Chờ đợi trước khi vào đoạn găng Trưng dụng tài nguyên găng Chờ đợi vòng tròn Nguyên tắc
ea73ad6304ed438f7e7d4c59ddd227a1:209,ea73ad6304ed438f7e7d4c59ddd227a1,209,212,,,576,Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.4 Phòng ngừa bế tắc Điều kiện tài nguyên găng l Giảm bớt mức độ găng của hệ thống l Tài nguyên phân chia được (file chỉ đọc): Sử dụng đồng thời l Tài nguyên không phân chia được: Sử dụng không đồng thời l Kỹ thuật SPOOL(Simultaneous peripheral operation on-line) l Không phân phối tài nguyên khi không thực sự cần thiết l Chỉ một số ít tiến trình có khả năng yêu cầu tài nguyên l Chỉ printer daemon mới làm việc với máy in ⇒ Bế tắc cho tài nguyên máy in bị hủy bỏ l Không phải tài nguyên nào cũng dùng kỹ thuật SPOOL được
ea73ad6304ed438f7e7d4c59ddd227a1:210,ea73ad6304ed438f7e7d4c59ddd227a1,210,213,,,702,Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.4 Phòng ngừa bế tắc Điều kiện chờ đợi trước khi vào đoạn găng Nguyên tắc: Đảm bảo môt tiến trình xin tài nguyên chỉ khi không sở hữu bất kỳ tài nguyên nào khác l Cung cấp trước l Tiến trình xin toàn bộ tài nguyên ngay từ đầu và chỉ thực hiện khi đã có đầy đủ tài nguyên l Hiệu quả sử dụng tài nguyên thấp l Tiến trình chỉ sử dụng tài nguyên ở giai đoạn cuối? l Tổng số tài nguyên đòi hỏi vượt quá khả năng của hệ thống? l Giải phóng tài nguyên l Tiến trình giải phóng tất cả tài nguyên trước khi xin (xin lại) tài nguyên mới l Nhận xét l Tốc độ thực hiện tiến trình chậm l Phải đảm bảo dữ liệu được giữ trong tài nguyên tạm giải phóng không bị mất
ea73ad6304ed438f7e7d4c59ddd227a1:211,ea73ad6304ed438f7e7d4c59ddd227a1,211,214,,,381,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.4 Phòng ngừa bế tắc Điều kiện chờ đợi trước khi vào đoạn găng: Ví dụ l Tiến trình gồm 2 giai đoạn l Sao chép dữ liệu từ băng từ sang một file trên đĩa từ l Sắp xếp dữ liệu trong file và đưa ra máy in l Phương pháp cung cấp trước l Xin cả băng từ, file trên đĩa và máy in l Lãng phí máy in giai đoạn đầu, băng từ giai đoạn cuối"
ea73ad6304ed438f7e7d4c59ddd227a1:212,ea73ad6304ed438f7e7d4c59ddd227a1,212,215,,,464,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.4 Phòng ngừa bế tắc Điều kiện chờ đợi trước khi vào đoạn găng: Ví dụ l Tiến trình gồm 2 giai đoạn l Sao chép dữ liệu từ băng từ sang một file trên đĩa từ l Sắp xếp dữ liệu trong file và đưa ra máy in l Phương pháp cung cấp trước l Xin cả băng từ, file trên đĩa và máy in l Lãng phí máy in giai đoạn đầu, băng từ giai đoạn cuối l Phương pháp giải phóng tài nguyên l Xin băng từ và file trên đĩa cho giai đoạn 1"
ea73ad6304ed438f7e7d4c59ddd227a1:213,ea73ad6304ed438f7e7d4c59ddd227a1,213,216,,,548,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.4 Phòng ngừa bế tắc Điều kiện chờ đợi trước khi vào đoạn găng: Ví dụ l Tiến trình gồm 2 giai đoạn l Sao chép dữ liệu từ băng từ sang một file trên đĩa từ l Sắp xếp dữ liệu trong file và đưa ra máy in l Phương pháp cung cấp trước l Xin cả băng từ, file trên đĩa và máy in l Lãng phí máy in giai đoạn đầu, băng từ giai đoạn cuối l Phương pháp giải phóng tài nguyên l Xin băng từ và file trên đĩa cho giai đoạn 1 l Giải phóng băng từ và file trên đĩa l Xin file trên đĩa và máy in cho giai đoạn 2"
ea73ad6304ed438f7e7d4c59ddd227a1:214,ea73ad6304ed438f7e7d4c59ddd227a1,214,217,,,626,Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.4 Phòng ngừa bế tắc Điều kiện trưng dụng tài nguyên găng Nguyên tắc: cho phép trưng dụng tài nguyên khi cần thiết l Tiến trình Pi xin tài nguyên Rj l Rj sẵn có: Cung cấp Rj cho Pi l Rj không sẵn: (Rj bị chiếm bởi tiến trình Pk) l Pk đang đợi tài nguyên khác l Trưng dụng Rj từ Pk và cung cấp cho Pi theo yêu cầu l Thêm Rj vào danh sách các tài nguyên đang thiếu của Pk l Pk được thực hiện trở lại khi l Có được tài nguyên đang thiếu l Đòi lại được Rj l Pk đang thực hiện l Pi phải đợi (không giải phóng tài nguyên) l Cho phép trưng dụng tài nguyên nhưng chỉ khi cần thiết
ea73ad6304ed438f7e7d4c59ddd227a1:215,ea73ad6304ed438f7e7d4c59ddd227a1,215,218,,,366,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.4 Phòng ngừa bế tắc Điều kiện trưng dụng tài nguyên găng Nguyên tắc: cho phép trưng dụng tài nguyên khi cần thiết l Chỉ áp dụng cho các tài nguyên có thể lưu trữ và khôi phục trạng thái dễ dàng l (CPU, không gian nhớ) l Khó có thể áp dụng cho các tài nguyên như máy in l Một tiến trình bị trưng dụng nhiều lần ?"
ea73ad6304ed438f7e7d4c59ddd227a1:216,ea73ad6304ed438f7e7d4c59ddd227a1,216,219,,,626,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.4 Phòng ngừa bế tắc Điều kiện chờ đợi vòng tròn l Đặt ra một thứ tự toàn cục của tất cả các kiểu tài nguyên l R = {R1, R2, . . . Rn} Tập tất cả các kiểu tài nguyên l Xây dựng hàm trật tự f : R → N l Hàm f được xây dựng dựa trên trật tự sử dụng các tài nguyên f(Băng từ) = 1 f( Đĩa từ) = 5 f(Máy in) = 12 l Tiến trình chỉ được yêu cầu tài nguyên theo trật tự tăng l Tiến trình chiếm giữ tài nguyên kiểu Rk chỉ được xin tài nguyên kiểu Rj thỏa mãn f(Rj) > f(Rk) l Tiến trình yêu cầu tới tài nguyên Rk sẽ phải giải phóng tất cả tài nguyên Ri thỏa mãn điều kiện f(Ri) ≥ f(Rk)"
ea73ad6304ed438f7e7d4c59ddd227a1:217,ea73ad6304ed438f7e7d4c59ddd227a1,217,220,,,609,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.4 Phòng ngừa bế tắc Điều kiện chờ đợi vòng tròn l Tiến trình chỉ được yêu cầu tài nguyên theo trật tự tăng l Tiến trình chiếm giữ tài nguyên kiểu Rk chỉ được xin tài nguyên kiểu Rj thỏa mãn f(Rj) > f(Rk) l Tiến trình yêu cầu tới tài nguyên Rk sẽ phải giải phóng tất cả tài nguyên Ri thỏa mãn điều kiện f(Ri) ≥ f(Rk) l Chứng minh l Giả thiết bế tắc xảy ra giữa các tiến trình {P1, P2, . . . Pm} l R1 → P1 → R2 → P2 ⇒ f(R1) < f(R2) l R2 → P2 → R3 → P3 ⇒ f(R2) < f(R3) . . . l Rm → Pm → R1 → P1 ⇒ f(Rm) < f(R1) l f(R1) < f(R2) < . . . < f(Rm) < f(R1) ⇒Vô lý"
ea73ad6304ed438f7e7d4c59ddd227a1:218,ea73ad6304ed438f7e7d4c59ddd227a1,218,221,,,217,Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.5 Phòng tránh bế tắc l Khái niệm bế tắc l Điều kiện xảy ra bế tắc l Các phương pháp xử lý bế tắc l Phòng ngừa bế tắc l Phòng tránh bế tắc l Nhận biết và khắc phục
ea73ad6304ed438f7e7d4c59ddd227a1:219,ea73ad6304ed438f7e7d4c59ddd227a1,219,222,,,145,Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.5 Phòng tránh bế tắc Ví dụ P1 P2 S2 = 1 S1 = 1 P(S1) P(S2) P(S2) P(S1) t S1 = 0 yêu cầu R1
ea73ad6304ed438f7e7d4c59ddd227a1:220,ea73ad6304ed438f7e7d4c59ddd227a1,220,223,,,149,Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.5 Phòng tránh bế tắc Ví dụ P1 P2 S2 = 1 P(S1) P(S2) P(S2) P(S1) t S1 = 0 sử dụng R1 yêu cầu R2
ea73ad6304ed438f7e7d4c59ddd227a1:221,ea73ad6304ed438f7e7d4c59ddd227a1,221,224,,,160,Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.5 Phòng tránh bế tắc Ví dụ P1 P2 S2 = 0 P(S1) P(S2) P(S2) P(S1) t S1 = 0 sử dụng R1 sử dụng R2 yêu cầu R1
ea73ad6304ed438f7e7d4c59ddd227a1:222,ea73ad6304ed438f7e7d4c59ddd227a1,222,225,,,189,Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.5 Phòng tránh bế tắc Ví dụ P1 P2 S2 = 0 P(S1) P(S2) P(S2) P(S1) t S1 = -1 Yêu cầu R2 sử dụng R2 yêu cầu R1 sử dụng R1 S2 = -1 DeadLock
ea73ad6304ed438f7e7d4c59ddd227a1:223,ea73ad6304ed438f7e7d4c59ddd227a1,223,226,,,170,Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.5 Phòng tránh bế tắc Ví dụ P1 P2 S2 = 1 P(S1) P(S2) P(S2) P(S1) t S1 = 0 sử dụng R1 yêu cầu R2 Block(P2) Yêu cầu R2
ea73ad6304ed438f7e7d4c59ddd227a1:224,ea73ad6304ed438f7e7d4c59ddd227a1,224,227,,,376,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.5 Phòng tránh bế tắc Ví dụ P1 P2 S2 = 0 P(S1) P(S2) P(S2) P(S1) t S1 = 0 sử dụng R1 yêu cầu R2 Block(P2) sử dụng R2 Nhận xét: Nếu biết được chuỗi yêu cầu/giải phóng tài nguyên của các tiến trình, hệ thống có thể đưa ra được chiến lược phân phối tài nguyên (chấp thuận hay phải đợi) cho mọi yêu cầu để bế tắc không xảy ra."
ea73ad6304ed438f7e7d4c59ddd227a1:225,ea73ad6304ed438f7e7d4c59ddd227a1,225,228,,,923,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.5 Phòng tránh bế tắc Nguyên tắc l Phải biết trước các thông tin về tiến trình và tài nguyên l Tiến trình phải khai báo lượng tài nguyên lớn nhất mỗi loại sẽ yêu cầu khi thực hiện l Quyết định dựa trên kết quả kiểm tra trạng thái cung cấp tài nguyên (Resource-Allocation State) -Trạng thái hệ thống l Trạng thái cung cấp tài nguyên xác định bởi các thông số l Số đơn vị tài nguyên có sẵn trong hệ thống l Số đơn vị tài nguyên đã được cấp cho mỗi tiến trình l Số đơn vị tài nguyên lớn nhất mỗi tiến trình có thể yêu cầu l Nếu hệ thống an toàn, sẽ đáp ứng cho yêu cầu l Thực hiện kiểm tra mỗi khi nhận được yêu cầu tài nguyên l Mục đích: Đảm bảo trạng thái hệ thống luôn an toàn l Thời điểm ban đầu (chưa c/cấp tài nguyên), hệ thống an toàn l Hệ thống chỉ cung cấp tài nguyên khi vẫn đảm bảo an toàn ⇒Hệ thống chuyển từ trạng thái an toàn này sang trạng thái an toàn khác"
ea73ad6304ed438f7e7d4c59ddd227a1:226,ea73ad6304ed438f7e7d4c59ddd227a1,226,229,,,303,Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.5 Phòng tránh bế tắc Trạng thái an toàn Trạng thái của hệ thống là an toàn khi l Có thể cung cấp tài nguyên cho từng tiến trình (đến yêu cầu lớn nhất) theo một trật tự nào đấy mà không xảy ra bế tắc l Tồn tại chuỗi an toàn của tất cả các tiến trình
ea73ad6304ed438f7e7d4c59ddd227a1:227,ea73ad6304ed438f7e7d4c59ddd227a1,227,230,,,782,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.5 Phòng tránh bế tắc Chuỗi an toàn Chuỗi tiến trình P={P1, P2, . . . , Pn} là an toàn nếu l Với mỗi tiến trình Pi, mọi yêu cầu tài nguyên trong tương lai đều có thể đáp ứng nhờ vào l Lượng tài nguyên hiện có trong hệ thống l Tài nguyên đang chiếm giữ bởi tất cả các tiến trình Pj(j < i) Trong chuỗi an toàn, khi Pi yêu cầu tài nguyên l Nếu không thể đáp ứng ngay lập tức, Pi đợi cho tới khi Pj kết thúc (j < i) l Khi Pj kết thúc và giải phóng tài nguyên, Pi sẽ nhận được tài nguyên cần thiết, thực hiện, giải phóng các tài nguyên đã được cung cấp và kết thúc l Khi Pi kết thúc và giải phóng tài nguyên ⇒ Pi+1 sẽ nhận được tài nguyên cần thiêt và kết thúc được . . . l Tất cả các tiến trình trong chuỗi an toàn đều kết thúc được"
ea73ad6304ed438f7e7d4c59ddd227a1:228,ea73ad6304ed438f7e7d4c59ddd227a1,228,231,,,807,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.5 Phòng tránh bế tắc Ví dụ minh họa Xem xét hệ thống gồm l 3 tiến trình P1, P2, P3 và 1 tài nguyên R có 12 đơn vị l (P1, P2, P3) có thể yêu cầu tối đa tới (10, 4, 9) đơn vị tài nguyên R l Tại thời điểm t0, (P1, P2, P3) đã được cấp (5, 2, 2) đơn vị tài nguyên R l Tại thời điểm hiện tại (t0) hệ thống có an toàn? l Hệ thống đã cấp (5 + 2 + 2) đơn vị, vậy còn lại 3 đơn vị l (P1, P2, P3) còn có thể yêu cầu (5, 2, 7) đơn vị l Với 3 đơn vị hiện có, mọi yêu cầu của P2 đều đáp ứng được ⇒ P2 chắc chắn kết thúc được và sẽ giải phóng 2 đơn vị R l Với 3 + 2 đơn vị, P1 chắc chắn kết thúc,sẽ giải phóng 5 đơn vị l Với 3 + 2 + 5 đơn vị P3 chắc chắn kết thúc được l Ở thời điểm t0 P1, P2, P3 đều chắc chắn kết thúc ⇒ hệ thống an toàn với dãy an toàn (P2, P1, P3)"
ea73ad6304ed438f7e7d4c59ddd227a1:229,ea73ad6304ed438f7e7d4c59ddd227a1,229,232,,,864,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.5 Phòng tránh bế tắc Ví dụ minh họa 2 Xem xét hệ thống gồm l 3 tiến trình P1, P2, P3 và 1 tài nguyên R có 12 đơn vị l Các tiến trình (P1, P2, P3) có thể yêu cầu tối đa tới (10, 4, 9) đơn vị tài nguyên R l Tại thời điểm t0, các tiến trình (P1, P2, P3) đã được cấp (5, 2, 2) đơn vị tài nguyên R l Tại thời điểm t1, tiến trình P3 yêu cầu và được cấp 1 đơn vị tài nguyên R. Hệ thống có an toàn? l Với 2 đơn vị hiện có, mọi yêu cầu của P2 đều đáp ứng được ⇒ P2 chắc chắn kết thúc, giải phóng 2 đơn vị R l Khi P2 kết thúc số tài nguyên sẵn có trong hệ thống là 4 l Với 4 đơn vị tài nguyên, P1 và P3 đều có thể phải đợi khi xin thêm 5 đơn vị tài nguyên l Vậy hệ thống không an toàn với dãy (P1, P3) l Nhận xét: Tại thời điểm t1 nếu tiến trình P3 phải đợi khi yêu cầu thêm 1 đơn vị tài nguyên, bế tắc sẽ được loại trừ"
ea73ad6304ed438f7e7d4c59ddd227a1:230,ea73ad6304ed438f7e7d4c59ddd227a1,230,233,,,539,Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.5 Phòng tránh bế tắc Ví dụ minh họa l Nhận xét l Hệ thống an toàn ⇒ Các tiến trình đều có thể kết thúc được ⇒ không xảy ra bế tắc l Hệ thống không an toàn ⇒ Có khả năng xảy ra bế tắc l Phương pháp l Không để hệ thống rơi vào tình trạng không an toàn l Kiểm tra mọi yêu cầu tài nguyên l Nếu hệ thống vẫn an toàn khi cung cấp ⇒ Cung cấp l Nếu hệ thống không an toàn khi cung cấp ⇒ Phải đợi l Thuật toán l Thuật toán dựa vào đồ thị cung cấp tài nguyên l Thuật toán người quản lý nhà băng
ea73ad6304ed438f7e7d4c59ddd227a1:231,ea73ad6304ed438f7e7d4c59ddd227a1,231,234,,,606,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.5 Phòng tránh bế tắc Thuật toán dựa vào đồ thị cung cấp tài nguyên l Sử dụng khi mỗi kiểu tài nguyên chỉ có 1 đơn vị l Có chu trình, sẽ có bế tắc l Thêm vào đồ thị loại cung mới: cung đòi hỏi Pi → Rj l Cùng hướng với cung yêu cầu, thể hiện trong đồ thị −− > l Cho biết Pi có thể yêu cầu Rj trong tương lai l Tiến trình khi tham gia hệ thống, phải thêm tất cả các cung đòi hỏi tương ứng vào đồ thị l Khi Pi yêu cầu Rj, cung đòi hỏi Pi → Rj chuyển thành cung yêu cầu Pi → Rj l Khi Pi giải phóng Rj, cung sử dụng Rj → Pi chuyển thành cung đòi hỏi Pi → Rj"
ea73ad6304ed438f7e7d4c59ddd227a1:232,ea73ad6304ed438f7e7d4c59ddd227a1,232,235,,,407,Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.5 Phòng tránh bế tắc Thuật toán dựa vào đồ thị cung cấp tài nguyên Thuật toán: Yêu cầu tài nguyên Rj của tiến trình Pi được thỏa mãn chỉ khi việc chuyển cung yêu cầu Pi → Rj thành cung sử dụng Rj → Pi không tạo chu trình trên đồ thị. l Không chu trình: Hệ thống an toàn l Có chu trình: Việc cung cấp tài nguyên đẩy hệ thống vào tình trạng không an toàn
ea73ad6304ed438f7e7d4c59ddd227a1:233,ea73ad6304ed438f7e7d4c59ddd227a1,233,236,,,308,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.5 Phòng tránh bế tắc Ví dụ Hệ thống: 2 tiến trình P1, P2 và 2 tài nguyên R1, R2, mỗi loại 1 đơn vị l P1 có thể xin R1, R2 trong tương lai l P2 có thể xin R1, R2 trong tương lai P1 P2 R2 R1 l P1 yêu cầu tài nguyên R1 l Cung đòi hỏi trở thành cung yêu cầu"
ea73ad6304ed438f7e7d4c59ddd227a1:234,ea73ad6304ed438f7e7d4c59ddd227a1,234,237,,,445,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.5 Phòng tránh bế tắc Ví dụ Hệ thống: 2 tiến trình P1, P2 và 2 tài nguyên R1, R2, mỗi loại 1 đơn vị l P1 có thể xin R1, R2 trong tương lai l P2 có thể xin R1, R2 trong tương lai P1 P2 R2 R1 l P1 yêu cầu tài nguyên R1 l Cung đòi hỏi trở thành cung yêu cầu l P2 yêu cầu tài nguyên R2 ⇒ cung đòi hỏi trở thành cung yêu cầu P2 → R2 l Yêu cầu của P1 được đáp ứng l Cung yêu cầu thành cung sử dụng"
ea73ad6304ed438f7e7d4c59ddd227a1:235,ea73ad6304ed438f7e7d4c59ddd227a1,235,238,,,576,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.5 Phòng tránh bế tắc Ví dụ Hệ thống: 2 tiến trình P1, P2 và 2 tài nguyên R1, R2, mỗi loại 1 đơn vị l P1 có thể xin R1, R2 trong tương lai l P2 có thể xin R1, R2 trong tương lai P1 P2 R2 R1 l P1 yêu cầu tài nguyên R1 l Cung đòi hỏi trở thành cung yêu cầu l P2 yêu cầu tài nguyên R2 ⇒ cung đòi hỏi trở thành cung yêu cầu P2 → R2 l Nếu đáp ứng ⇒Cung yêu cầu thành cung sử dụng ⇒ Khi P1 yêu cầu R2 ⇒ P1 phải đợi ⇒ Khi P2 yêu cầu R1 ⇒ P2 phải đợi l Yêu cầu của P1 được đáp ứng l Cung yêu cầu thành cung sử dụng Hệ thống bế tắc"
ea73ad6304ed438f7e7d4c59ddd227a1:236,ea73ad6304ed438f7e7d4c59ddd227a1,236,239,,,612,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.5 Phòng tránh bế tắc Ví dụ Hệ thống: 2 tiến trình P1, P2 và 2 tài nguyên R1, R2, mỗi loại 1 đơn vị l P1 có thể xin R1, R2 trong tương lai l P2 có thể xin R1, R2 trong tương lai P1 P2 R2 R1 l P1 yêu cầu tài nguyên R1 l Cung đòi hỏi trở thành cung yêu cầu l P2 yêu cầu tài nguyên R2 ⇒ cung đòi hỏi trở thành cung yêu cầu P2 → R2 l Nếu đáp ứng ⇒Cung yêu cầu thành cung sử dụng ⇒ Khi P1 yêu cầu R2 ⇒ P1 phải đợi ⇒ Khi P2 yêu cầu R1 ⇒ P2 phải đợi l Yêu cầu của P1 được đáp ứng l Cung yêu cầu thành cung sử dụng Hệ thống bế tắc l Yêu cầu của P2 không được đáp ứng"
ea73ad6304ed438f7e7d4c59ddd227a1:237,ea73ad6304ed438f7e7d4c59ddd227a1,237,240,,,751,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.5 Phòng tránh bế tắc Thuật toán người quản lý nhà băng: Giới thiệu l Thích hợp cho các hệ thống gồm các kiểu tài nguyên có nhiều đơn vị l Một tiến trình mới xuất hiện trong hệ thống cần khai báo số đơn vị lớn nhất của mỗi kiểu tài nguyên sẽ sử dụng l Không được vượt quá tổng số tài nguyên của hệ thống l Khi một tiến trình yêu cầu tài nguyên, hệ thống kiểm tra liệu đáp ứng cho yêu cầu hệ thống có còn an toàn không l Nếu hệ thống vẫn an toàn ⇒ Cung cấp tài nguyên cho yêu cầu l Nếu hệ thống không an toàn ⇒ Tiến trình phải đợi l Thuật toán cần l Các cấu trúc dữ liệu biểu diễn trạng thái phân phối tài nguyên l Thuật toán kiểm tra tình trạng an toàn của hệ thông l Thuật toán yêu cầu tài nguyên"
ea73ad6304ed438f7e7d4c59ddd227a1:238,ea73ad6304ed438f7e7d4c59ddd227a1,238,241,,,661,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.5 Phòng tránh bế tắc Các cấu trúc dữ liệu I Hệ thống n số tiến trình trong hệ thống m số kiểu tài nguyên trong hệ thống Các cấu trúc dữ liệu Available Vector chiều dài m cho biết số đơn vị tài nguyên sẵn có trong hệ thống. (Available[3] = 8 ⇒?) Max Ma trận n ∗m cho biết số lượng lớn nhất mỗi kiểu tài nguyên của từng tiến trình. (Max[2,3] = 5 ⇒?) Allocation Ma trận n ∗ m cho biết số lượng mỗi kiểu tài nguyên đã cấp cho tiến trình. (Allocation[2,3] = 2 ⇒?) Need Ma trận n ∗ m chỉ ra số lượng mỗi kiểu tài nguyên còn cần đến của từng tiến trình. Need[2,3] = 3 ⇒?) Need[i][j] = Max[i][j] - Allocation[i][j]"
ea73ad6304ed438f7e7d4c59ddd227a1:239,ea73ad6304ed438f7e7d4c59ddd227a1,239,242,,,451,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.5 Phòng tránh bế tắc Các cấu trúc dữ liệu I Quy ước l X, Y là các vector độ dài n l X ≤ Y ⇔ X[i] ≤ Y[i] ∀i = 1, 2, . . . , n l Các dòng của ma trận Max,Need,Allocation được xử lý như các vector l Thuật toán tính toán trên các vector l Các cấu trúc cục bộ Work vector độ dài m cho biết mỗi tài nguyên còn bao nhiêu Finish vector độ dài n, kiểu logic cho biết tiến trình có chắc chắn kết thúc không"
ea73ad6304ed438f7e7d4c59ddd227a1:240,ea73ad6304ed438f7e7d4c59ddd227a1,240,243,,,438,Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.5 Phòng tránh bế tắc Thuật toán kiểm tra An toàn BOOL Safe(Current Resource-Allocation State){ Work←Available for (i : 1 → n) Finish[i]←false flag← true While(flag){ flag←false for (i : 1 → n) if(Finish[i]=false AND Need[i] ≤Work){ Finish[i]← true Work ← Work+Allocation[i] flag← true }//endif }//endwhile for (i : 1 → n) if (Finish[i]=false)return false return true; }//End function
ea73ad6304ed438f7e7d4c59ddd227a1:241,ea73ad6304ed438f7e7d4c59ddd227a1,241,244,,,617,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.5 Phòng tránh bế tắc Ví dụ minh họa l Xét hệ thống gồm 5 tiến trình P0, P1, P2, P3, P4 và 3 tài nguyên R0, R1, R2 l Tài nguyên R0 có 10 đơn vị, R1 có 5 đơn vị, R2 có 7 đơn vị l Yêu cầu tài nguyên lớn nhất và lượng tài nguyên đã cấp của mỗi tiến trình R0 R1 R2 P0 7 5 3 P1 3 2 2 P2 9 0 2 P3 2 2 2 P4 4 3 3 Max R0 R1 R2 P0 0 1 0 P1 2 0 0 P2 3 0 2 P3 2 1 1 P4 0 0 2 Allocation l Hệ thống có an toàn? l Tiến trình P1 yêu cầu thêm 1 đơn vị R0 và 2 đơn vị R2? l Tiến trình P4 yêu cầu thêm 3 đơn vị R0 và 3 đơn vị R1? l Tiến trình P0 yêu cầu thêm 2 đơn vị R1. Cung cấp?"
ea73ad6304ed438f7e7d4c59ddd227a1:242,ea73ad6304ed438f7e7d4c59ddd227a1,242,245,,,430,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.5 Phòng tránh bế tắc Ví dụ minh họa : Kiểm tra tính an toàn l Số tài nguyên còn sẵn trong hệ thống Avaiable(R0, R1, R2) =(3, 3, 2) l Yêu cầu còn lại của mỗi tiến trình (Need = Max - Allocation) R0 R1 R2 P0 7 5 3 P1 3 2 2 P2 9 0 2 P3 2 2 2 P4 4 3 3 Max R0 R1 R2 P0 0 1 0 P1 2 0 0 P2 3 0 2 P3 2 1 1 P4 0 0 2 Allocation R0 R1 R2 P0 7 4 3 P1 1 2 2 P2 6 0 0 P3 0 1 1 P4 4 3 1 Need"
ea73ad6304ed438f7e7d4c59ddd227a1:243,ea73ad6304ed438f7e7d4c59ddd227a1,243,246,,,453,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.5 Phòng tránh bế tắc Ví dụ minh họa : Kiểm tra tính an toàn l Số tài nguyên còn sẵn trong hệ thống Avaiable(R0, R1, R2) =(3, 3, 2) R0 R1 R2 P0 7 5 3 P1 3 2 2 P2 9 0 2 P3 2 2 2 P4 4 3 3 Max R0 R1 R2 P0 0 1 0 P1 2 0 0 P2 3 0 2 P3 2 1 1 P4 0 0 2 Allocation R0 R1 R2 P0 7 4 3 P1 1 2 2 P2 6 0 0 P3 0 1 1 P4 4 3 1 Need Tiến trình P0 P1 P2 P3 P4 Finish F F F F F Work F F F T (5,3,2) (3,3,2) F T F (7,4,3)"
ea73ad6304ed438f7e7d4c59ddd227a1:244,ea73ad6304ed438f7e7d4c59ddd227a1,244,247,,,486,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.5 Phòng tránh bế tắc Ví dụ minh họa : Kiểm tra tính an toàn l Số tài nguyên còn sẵn trong hệ thống Avaiable(R0, R1, R2) =(3, 3, 2) R0 R1 R2 P0 7 5 3 P1 3 2 2 P2 9 0 2 P3 2 2 2 P4 4 3 3 Max R0 R1 R2 P0 0 1 0 P1 2 0 0 P2 3 0 2 P3 2 1 1 P4 0 0 2 Allocation R0 R1 R2 P0 7 4 3 P1 1 2 2 P2 6 0 0 P3 0 1 1 P4 4 3 1 Need Tiến trình P0 P1 P2 P3 P4 Finish F T F T T Work F F T (7,5,5) (7,4,5) T (10,5,7) Hệ thống an toàn (P1, P3, P4, P0, P2)"
ea73ad6304ed438f7e7d4c59ddd227a1:245,ea73ad6304ed438f7e7d4c59ddd227a1,245,248,,,852,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.5 Phòng tránh bế tắc Thuật toán yêu cầu tài nguyên l Request[i] Vector yêu cầu tài nguyên của tiến trình Pi l Request[3,2] = 2: Tiến trình P3 yêu cầu 2 đơn vị tài nguyên R2 l Khi Pi yêu cầu tài nguyên, hệ thống thực hiện ① if(Request[i]>Need[i]) Error(Yêu cầu vượt quá khai báo tài nguyên) ② if(Request[i]>Available) Block(Không đủ tài nguyên, tiến trình phải đợi) ③ Thiết lập trạng thái phân phối tài nguyên mới cho hệ thống l Available = Available - Request[i] l Allocation[i] = Allocation[i] + Request[i] l Need[i] = Need[i] - Request[i] ④ Phân phối tài nguyên dựa trên kết quả kiểm tra tính an toàn của trạng thái phân phối tài nguyên mới if(Safe(New Resource Allocation State)) Phân phối cho Pi theo yêu cầu else Tiến trình Pi phải đợi Khôi phục lại trạng thái cũ (Available, Allocation,Need)"
ea73ad6304ed438f7e7d4c59ddd227a1:246,ea73ad6304ed438f7e7d4c59ddd227a1,246,249,,,401,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.5 Phòng tránh bế tắc Ví dụ minh họa : P1 yêu cầu (1, 0, 2) l Request[1]≤Available ((1, 0, 2) ≤ (3, 3, 2)) ⇒ Có thể cung cấp l Nếu cung cấp : Available = ( 2 , 3, 0) R0 R1 R2 P0 0 1 0 P1 3 0 2 P2 3 0 2 P3 2 1 1 P4 0 0 2 Allocation R0 R1 R2 P0 7 4 3 P1 1 2 2 P2 6 0 0 P3 0 1 1 P4 4 3 1 Need Tiến trình P0 P1 P2 P3 P4 Finish F F F F F Work (2,3,0) F"
ea73ad6304ed438f7e7d4c59ddd227a1:247,ea73ad6304ed438f7e7d4c59ddd227a1,247,250,,,401,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.5 Phòng tránh bế tắc Ví dụ minh họa : P1 yêu cầu (1, 0, 2) l Request[1]≤Available ((1, 0, 2) ≤ (3, 3, 2)) ⇒ Có thể cung cấp l Nếu cung cấp : Available = ( 2 , 3, 0) R0 R1 R2 P0 0 1 0 P1 3 0 2 P2 3 0 2 P3 2 1 1 P4 0 0 2 Allocation R0 R1 R2 P0 7 4 3 P1 1 2 2 P2 6 0 0 P3 0 1 1 P4 4 3 1 Need Tiến trình P0 P1 P2 P3 P4 Finish F F F F F Work (2,3,0) F"
ea73ad6304ed438f7e7d4c59ddd227a1:248,ea73ad6304ed438f7e7d4c59ddd227a1,248,251,,,401,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.5 Phòng tránh bế tắc Ví dụ minh họa : P1 yêu cầu (1, 0, 2) l Request[1]≤Available ((1, 0, 2) ≤ (3, 3, 2)) ⇒ Có thể cung cấp l Nếu cung cấp : Available = ( 2 , 3, 0) R0 R1 R2 P0 0 1 0 P1 3 0 2 P2 3 0 2 P3 2 1 1 P4 0 0 2 Allocation R0 R1 R2 P0 7 4 3 P1 1 2 2 P2 6 0 0 P3 0 1 1 P4 4 3 1 Need Tiến trình P0 P1 P2 P3 P4 Finish F T F F F Work (5,3,2) F"
ea73ad6304ed438f7e7d4c59ddd227a1:249,ea73ad6304ed438f7e7d4c59ddd227a1,249,252,,,401,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.5 Phòng tránh bế tắc Ví dụ minh họa : P1 yêu cầu (1, 0, 2) l Request[1]≤Available ((1, 0, 2) ≤ (3, 3, 2)) ⇒ Có thể cung cấp l Nếu cung cấp : Available = ( 2 , 3, 0) R0 R1 R2 P0 0 1 0 P1 3 0 2 P2 3 0 2 P3 2 1 1 P4 0 0 2 Allocation R0 R1 R2 P0 7 4 3 P1 1 2 2 P2 6 0 0 P3 0 1 1 P4 4 3 1 Need Tiến trình P0 P1 P2 P3 P4 Finish F T F F F Work (5,3,2) F"
ea73ad6304ed438f7e7d4c59ddd227a1:250,ea73ad6304ed438f7e7d4c59ddd227a1,250,253,,,401,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.5 Phòng tránh bế tắc Ví dụ minh họa : P1 yêu cầu (1, 0, 2) l Request[1]≤Available ((1, 0, 2) ≤ (3, 3, 2)) ⇒ Có thể cung cấp l Nếu cung cấp : Available = ( 2 , 3, 0) R0 R1 R2 P0 0 1 0 P1 3 0 2 P2 3 0 2 P3 2 1 1 P4 0 0 2 Allocation R0 R1 R2 P0 7 4 3 P1 1 2 2 P2 6 0 0 P3 0 1 1 P4 4 3 1 Need Tiến trình P0 P1 P2 P3 P4 Finish F T F T F Work (7,4,3) F"
ea73ad6304ed438f7e7d4c59ddd227a1:251,ea73ad6304ed438f7e7d4c59ddd227a1,251,254,,,401,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.5 Phòng tránh bế tắc Ví dụ minh họa : P1 yêu cầu (1, 0, 2) l Request[1]≤Available ((1, 0, 2) ≤ (3, 3, 2)) ⇒ Có thể cung cấp l Nếu cung cấp : Available = ( 2 , 3, 0) R0 R1 R2 P0 0 1 0 P1 3 0 2 P2 3 0 2 P3 2 1 1 P4 0 0 2 Allocation R0 R1 R2 P0 7 4 3 P1 1 2 2 P2 6 0 0 P3 0 1 1 P4 4 3 1 Need Tiến trình P0 P1 P2 P3 P4 Finish F T F T T Work (7,4,5) F"
ea73ad6304ed438f7e7d4c59ddd227a1:252,ea73ad6304ed438f7e7d4c59ddd227a1,252,255,,,401,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.5 Phòng tránh bế tắc Ví dụ minh họa : P1 yêu cầu (1, 0, 2) l Request[1]≤Available ((1, 0, 2) ≤ (3, 3, 2)) ⇒ Có thể cung cấp l Nếu cung cấp : Available = ( 2 , 3, 0) R0 R1 R2 P0 0 1 0 P1 3 0 2 P2 3 0 2 P3 2 1 1 P4 0 0 2 Allocation R0 R1 R2 P0 7 4 3 P1 1 2 2 P2 6 0 0 P3 0 1 1 P4 4 3 1 Need Tiến trình P0 P1 P2 P3 P4 Finish T T F T T Work (7,5,5) F"
ea73ad6304ed438f7e7d4c59ddd227a1:253,ea73ad6304ed438f7e7d4c59ddd227a1,253,256,,,423,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.5 Phòng tránh bế tắc Ví dụ minh họa : P1 yêu cầu (1, 0, 2) l Request[1]≤Available ((1, 0, 2) ≤ (3, 3, 2)) ⇒ Có thể cung cấp l Nếu cung cấp : Available = ( 2 , 3, 0) R0 R1 R2 P0 0 1 0 P1 3 0 2 P2 3 0 2 P3 2 1 1 P4 0 0 2 Allocation R0 R1 R2 P0 7 4 3 P1 1 2 2 P2 6 0 0 P3 0 1 1 P4 4 3 1 Need Tiến trình P0 P1 P2 P3 P4 Finish T T T T T Work (10,5,7) Yêu cầu được chấp nhận"
ea73ad6304ed438f7e7d4c59ddd227a1:254,ea73ad6304ed438f7e7d4c59ddd227a1,254,257,,,579,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.5 Phòng tránh bế tắc Ví dụ minh họa : (tiếp tục) l Tiến trình P4 yêu cầu thêm 3 đơn vị R0 và 3 đơn vị R2 l Request[4] = (3, 0, 3) l Available = (2, 3, 0) ⇒ Không đủ tài nguyên, P4 phải đợi l Tiến trình P0 yêu cầu thêm 2 đơn vị R1 l Request[0]≤Available ((0, 2, 0) ≤ (2, 3, 0)) ⇒ Có thể cung cấp l Nếu cung cấp : Available = (2 , 1, 0) l Thực hiện thuật toán an toàn ⇒ Tất cả các tiến trình đều có thể không kết thúc ⇒ Nếu chấp nhận, hệ thống rơi vào trạng thái không an toàn ⇒ Đủ tài nguyên nhưng không cung cấp. P0 phải đợi"
ea73ad6304ed438f7e7d4c59ddd227a1:255,ea73ad6304ed438f7e7d4c59ddd227a1,255,258,,,221,Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.6 Nhận biết và khắc phục l Khái niệm bế tắc l Điều kiện xảy ra bế tắc l Các phương pháp xử lý bế tắc l Phòng ngừa bế tắc l Phòng tránh bế tắc l Nhận biết và khắc phục
ea73ad6304ed438f7e7d4c59ddd227a1:256,ea73ad6304ed438f7e7d4c59ddd227a1,256,259,,,544,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.6 Nhận biết và khắc phục Giới thiệu l Nguyên tắc l Không áp dụng các biện pháp phòng ngừa hoặc phòng tránh, để cho bế tắc xảy ra l Định kỳ kiểm tra xem bế tắc có đang xảy ra không. Nếu có tìm cách khắc phục l Để thực hiện, hệ thống phải cung cấp l Thuật toán xác định hệ thống đang bế tắc không l Thuật toán chữa bế tắc l Nhận biết bế tắc l Thuật toán dựa trên đồ thị cung cấp tài nguyên l Thuật toán chỉ ra bế tắc tổng quát l Khắc phục bế tắc l Kết thúc tiến trình l Trưng dụng tài nguyên"
ea73ad6304ed438f7e7d4c59ddd227a1:257,ea73ad6304ed438f7e7d4c59ddd227a1,257,260,,,795,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.6 Nhận biết và khắc phục Thuận toán dựa trên đồ thị cung cấp tài nguyên l Áp dụng khi mỗi tài nguyên trong hệ thống có một đơn vị l Kiểm tra hệ thống có bế tắc bằng cách kiểm tra chu trình trên đồ thị l Nếu trên đồ thị có chu trình, hệ thống đang bế tắc l Định kỳ gọi tới các thuật toán kiểm tra chu trình trên đồ thị l Thuật toán đòi hỏi n2 thao tác (n: số đỉnh của đồ thị) l Sử dụng đồ thị chờ đợi - phiên bản thu gọn của đồ thị cung cấp tài nguyên l Chỉ có các đỉnh dạng tiến trình l Cung chờ đợi Pi → Pj: Tiến trình Pi đang đợi tiến trình Pj giải phóng tài nguyên Pi cần l Cung chờ đợi Pi → Pj tồn tại trên đồ thị đợi khi và chỉ khi trên đồ thị phân phối tài nguyên tương ứng tồn tại đồng thời cung yêu cầu Pi → R và cung sử dụng R → Pj"
ea73ad6304ed438f7e7d4c59ddd227a1:258,ea73ad6304ed438f7e7d4c59ddd227a1,258,261,,,161,Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.6 Nhận biết và khắc phục Đồ thị chờ đợi: Ví dụ P1 P3 R2 R3 R1 R4 R5 P5 P2 P4 P1 P3 P5 P2 P4 Đồ thị chờ đợi
ea73ad6304ed438f7e7d4c59ddd227a1:259,ea73ad6304ed438f7e7d4c59ddd227a1,259,262,,,683,Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.6 Nhận biết và khắc phục Thuật toán chỉ ra bế tắc tổng quát : Giới thiệu l Sử dụng cho các hệ thống có các kiểu tài nguyên gồm nhiều đơn vị l Thuật toán tương tự thuật toán người quản lý nhà băng l Các cấu trúc dữ liệu l Available Vector độ dài m: Tài nguyên sẵn có trong hệ thống l Allocation Ma trận n ∗ m: Tài nguyên đã cấp cho tiến trình l Request Ma trận n ∗ m Tài nguyên tiến trình yêu cầu l Các cấu trúc cục bộ l Work Vector độ dài m cho biết tài nguyên hiện đang có l Finish Vector độ dài n cho biết tiến trình có thể kết thúc không l Các qui ước l Quan hệ ≤ giữa các Vector l Xử lý các dòng ma trận n ∗ m như các vector
ea73ad6304ed438f7e7d4c59ddd227a1:260,ea73ad6304ed438f7e7d4c59ddd227a1,260,263,,,593,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.6 Nhận biết và khắc phục Thuật toán chỉ ra bế tắc tổng quát BOOL Deadlock(Current Resource-Allocation State){ Work←Available for (i : 1 → n) if(Allocation[i]≠0) Finish[i]←false elseFinish[i]←true; flag← true While(flag){ flag←false for (i : 1 → n) if(Finish[i]=false AND Request[i] ≤Work){ Finish[i]← true Work ← Work+Allocation[i] flag← true }//endif }//endwhile for (i : 1 → n) if (Finish[i]=false)return true; return false; }//End function //Allocation= 0 không nằm trong chu trình đợi //Finish[i] = false, tiến trình Pi đang bị bế tắc"
ea73ad6304ed438f7e7d4c59ddd227a1:261,ea73ad6304ed438f7e7d4c59ddd227a1,261,264,,,435,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.6 Nhận biết và khắc phục Ví dụ minh họa l 5 tiến trình P0, P1, P2, P3, P4; 3 tài nguyên R0, R1, R2 l Tài nguyên R0 có 7 đơn vị, R1 có 2 đơn vị, R2 có 6 đơn vị l Trạng thái cung cấp tài nguyên tại thời điểm t0 R0 R1 R2 P0 0 0 0 P1 2 0 2 P2 0 0 0 P3 1 0 0 P4 6 0 2 Request R0 R1 R2 P0 0 1 0 P1 2 0 0 P2 3 0 3 P3 2 1 1 P4 0 0 2 Allocation l Tài nguyên hiện có (R0, R1, R2) =(0, 0, 0)"
ea73ad6304ed438f7e7d4c59ddd227a1:262,ea73ad6304ed438f7e7d4c59ddd227a1,262,265,,,324,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.6 Nhận biết và khắc phục Ví dụ minh họa R0 R1 R2 P0 0 0 0 P1 2 0 2 P2 0 0 0 P3 1 0 0 P4 6 0 2 Request R0 R1 R2 P0 0 1 0 P1 2 0 0 P2 3 0 3 P3 2 1 1 P4 0 0 2 Allocation l Tài nguyên hiện có (R0, R1, R2) =(0, 0, 0) Tiến trình P0 P1 P2 P3 P4 Finish F F F F F Work (0,0,0) F"
ea73ad6304ed438f7e7d4c59ddd227a1:263,ea73ad6304ed438f7e7d4c59ddd227a1,263,266,,,326,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.6 Nhận biết và khắc phục Ví dụ minh họa R0 R1 R2 P0 0 0 0 P1 2 0 2 P2 0 0 0 P3 1 0 0 P4 6 0 2 Request R0 R1 R2 P0 0 1 0 P1 2 0 0 P2 3 0 3 P3 2 1 1 P4 0 0 2 Allocation l Tài nguyên hiện có (R0, R1, R2) =(0, 0, 0) Tiến trình P0 P1 P2 P3 P4 Finish T F F F F Work (0,1,0) F F"
ea73ad6304ed438f7e7d4c59ddd227a1:264,ea73ad6304ed438f7e7d4c59ddd227a1,264,267,,,324,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.6 Nhận biết và khắc phục Ví dụ minh họa R0 R1 R2 P0 0 0 0 P1 2 0 2 P2 0 0 0 P3 1 0 0 P4 6 0 2 Request R0 R1 R2 P0 0 1 0 P1 2 0 0 P2 3 0 3 P3 2 1 1 P4 0 0 2 Allocation l Tài nguyên hiện có (R0, R1, R2) =(0, 0, 0) Tiến trình P0 P1 P2 P3 P4 Finish T F T F F Work (3,1,3) F"
ea73ad6304ed438f7e7d4c59ddd227a1:265,ea73ad6304ed438f7e7d4c59ddd227a1,265,268,,,324,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.6 Nhận biết và khắc phục Ví dụ minh họa R0 R1 R2 P0 0 0 0 P1 2 0 2 P2 0 0 0 P3 1 0 0 P4 6 0 2 Request R0 R1 R2 P0 0 1 0 P1 2 0 0 P2 3 0 3 P3 2 1 1 P4 0 0 2 Allocation l Tài nguyên hiện có (R0, R1, R2) =(0, 0, 0) Tiến trình P0 P1 P2 P3 P4 Finish T F T T F Work (5,2,4) F"
ea73ad6304ed438f7e7d4c59ddd227a1:266,ea73ad6304ed438f7e7d4c59ddd227a1,266,269,,,324,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.6 Nhận biết và khắc phục Ví dụ minh họa R0 R1 R2 P0 0 0 0 P1 2 0 2 P2 0 0 0 P3 1 0 0 P4 6 0 2 Request R0 R1 R2 P0 0 1 0 P1 2 0 0 P2 3 0 3 P3 2 1 1 P4 0 0 2 Allocation l Tài nguyên hiện có (R0, R1, R2) =(0, 0, 0) Tiến trình P0 P1 P2 P3 P4 Finish T F T T F Work (5,2,4) F"
ea73ad6304ed438f7e7d4c59ddd227a1:267,ea73ad6304ed438f7e7d4c59ddd227a1,267,270,,,324,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.6 Nhận biết và khắc phục Ví dụ minh họa R0 R1 R2 P0 0 0 0 P1 2 0 2 P2 0 0 0 P3 1 0 0 P4 6 0 2 Request R0 R1 R2 P0 0 1 0 P1 2 0 0 P2 3 0 3 P3 2 1 1 P4 0 0 2 Allocation l Tài nguyên hiện có (R0, R1, R2) =(0, 0, 0) Tiến trình P0 P1 P2 P3 P4 Finish T T T T F Work (7,2,4) F"
ea73ad6304ed438f7e7d4c59ddd227a1:268,ea73ad6304ed438f7e7d4c59ddd227a1,268,271,,,365,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.6 Nhận biết và khắc phục Ví dụ minh họa R0 R1 R2 P0 0 0 0 P1 2 0 2 P2 0 0 0 P3 1 0 0 P4 6 0 2 Request R0 R1 R2 P0 0 1 0 P1 2 0 0 P2 3 0 3 P3 2 1 1 P4 0 0 2 Allocation l Tài nguyên hiện có (R0, R1, R2) =(0, 0, 0) Tiến trình P0 P1 P2 P3 P4 Finish T T T T T Work (7,2,6) Hệ thống không bế tắc (P0, P2, P3, P1, P4)"
ea73ad6304ed438f7e7d4c59ddd227a1:269,ea73ad6304ed438f7e7d4c59ddd227a1,269,272,,,358,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.6 Nhận biết và khắc phục Ví dụ minh họa l tại thời điểm t1: P2 yêu cầu thêm 1 đơn vị tài nguyên R2 l Trạng thái cung cấp tài nguyên R0 R1 R2 P0 0 0 0 P1 2 0 2 P2 0 0 1 P3 1 0 0 P4 6 0 2 Request R0 R1 R2 P0 0 1 0 P1 2 0 0 P2 3 0 3 P3 2 1 1 P4 0 0 2 Allocation l Tài nguyên hiện có (R0, R1, R2) =(0, 0, 0)"
ea73ad6304ed438f7e7d4c59ddd227a1:270,ea73ad6304ed438f7e7d4c59ddd227a1,270,273,,,279,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.6 Nhận biết và khắc phục Ví dụ minh họa R0 R1 R2 P0 0 0 0 P1 2 0 2 P2 0 0 1 P3 1 0 0 P4 6 0 2 Request R0 R1 R2 P0 0 1 0 P1 2 0 0 P2 3 0 3 P3 2 1 1 P4 0 0 2 Allocation Tiến trình P0 P1 P2 P3 P4 Finish F F F F F Work (0,0,0) F"
ea73ad6304ed438f7e7d4c59ddd227a1:271,ea73ad6304ed438f7e7d4c59ddd227a1,271,274,,,285,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.6 Nhận biết và khắc phục Ví dụ minh họa R0 R1 R2 P0 0 0 0 P1 2 0 2 P2 0 0 1 P3 1 0 0 P4 6 0 2 Request R0 R1 R2 P0 0 1 0 P1 2 0 0 P2 3 0 3 P3 2 1 1 P4 0 0 2 Allocation Tiến trình P0 P1 P2 P3 P4 Finish T F F F F Work (0,1,0) F F F F"
ea73ad6304ed438f7e7d4c59ddd227a1:272,ea73ad6304ed438f7e7d4c59ddd227a1,272,275,,,386,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.6 Nhận biết và khắc phục Ví dụ minh họa R0 R1 R2 P0 0 0 0 P1 2 0 2 P2 0 0 1 P3 1 0 0 P4 6 0 2 Request R0 R1 R2 P0 0 1 0 P1 2 0 0 P2 3 0 3 P3 2 1 1 P4 0 0 2 Allocation Tiến trình P0 P1 P2 P3 P4 Finish T F F F F Work (0,1,0) F F F F P0 có thể kết thúc nhưng hệ thống đang bế tắc. Các tiến trình đang chờ đợi lẫn nhau (P1, P2, P3, P4)"
ea73ad6304ed438f7e7d4c59ddd227a1:273,ea73ad6304ed438f7e7d4c59ddd227a1,273,276,,,893,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.6 Nhận biết và khắc phục Khắc phục bế tắc: Phương pháp kết thúc tiến trình Nguyên tắc: Hủy bỏ các tiến trình đang trong tình trạng bế tắc và lấy lại tài nguyên đã cấp cho tiến trình bị hủy bỏ l Hủy bỏ tất cả các tiến trình l Nhanh chóng hủy bỏ bế tắc l Quá tốn kém l Các tiến trình bị hủy bỏ có thể gần kết thúc l Hủy bỏ lần lượt tiến trình cho tới khi bế tắc không xảy ra l Sau khi hủy bỏ, phải kiểm tra xem bế tắc còn tồn tại không l Thuật toán kiểm tra bế tắc có độ phức tạp m ∗ n2 l Cần chỉ ra thứ tự tiến trình bị hủy bỏ để phá vỡ bế tắc l Độ ưu tiên của tiến trình. l Tiến trình đã tồn tại bao lâu, còn bao lâu nữa thì kết thúc l Tài nguyên tiến trình đang chiếm giữ, còn cần để kết thúc l . . . l Vấn đề hủy bỏ tiến trình l Tiến trình đang cập nhật file ⇒ File không hoàn chỉnh l Tiến trình sử dụng máy in ⇒ Reset trạng thái máy in"
ea73ad6304ed438f7e7d4c59ddd227a1:274,ea73ad6304ed438f7e7d4c59ddd227a1,274,277,,,728,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.6 Nhận biết và khắc phục Khắc phục bế tắc: Phương pháp trưng dụng tài nguyên Trưng dụng liên tục một vài tài nguyên từ một số tiến trình đang bế tắc cho các tiến trình khác đến khi bế tắc được hủy bỏ Các vấn đề cần quan tâm ① Lựa chọn nạn nhân (victim) l Tài nguyên nào và tiến trình nào được chọn? l Trật tự trưng dụng để chi phí nhỏ nhất l Lượng tài nguyên nắm giữ, thời gian sử dụng. . . ② Quay lui (Rollback) l Quay lui tới một trạng thái an toàn trước đó và bắt đầu lại l Yêu cầu lưu giữ thông tin trạng thái của t/trình đang thực hiện ③ Đói tài nguyên (Starvation) l Một tiến trình bị trưng dụng quá nhiều lần ⇒chờ đợi vô hạn l Giải pháp: ghi lại số lần bị trưng dụng"
ea73ad6304ed438f7e7d4c59ddd227a1:275,ea73ad6304ed438f7e7d4c59ddd227a1,275,278,,,104,Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.6 Nhận biết và khắc phục Cách xử lý bế tắc khác ?
ea73ad6304ed438f7e7d4c59ddd227a1:276,ea73ad6304ed438f7e7d4c59ddd227a1,276,279,,,665,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc Tổng kết l Bế tắc là tình trạng 2 hay nhiều tiến trình cùng chờ đợi độc lập một sự kiện chỉ có thể xảy ra bởi sự hoạt động của các tiến trình đang đợi l Bế tắc xảy ra khi hội đủ 4 điều kiện l Tồn tại tài nguyên găng l Phải chờ đợi trước khi vào đoạn găng l Không tồn tại hệ thống phân phối lại tài nguyên l Tồn tại hiện tượng chờ đợi vòng tròn l Để xử lý bế tắc có 3 lớp thuật toán l Phòng ngừa bế tắc l Tác động vào các điều kiện xảy ra bế tắc l Dự báo và phòng tránh l Ngăn ngừa hệ thống rơi vào tình trạng có thể dẫn đến bế tắc l Nhận biết và khắc phục l Cho phép bế tắc xảy ra, chỉ ra bế tắc và khắc phục sau"
ea73ad6304ed438f7e7d4c59ddd227a1:277,ea73ad6304ed438f7e7d4c59ddd227a1,277,280,,,390,"Chương 2 Quản lí tiến trình 5.Bế tắc và xử lí bế tắc 5.6 Nhận biết và khắc phục Ví dụ minh họa l 5 tiến trình P0, P1, P2, P3, P4; 3 tài nguyên R0, R1, R2 l Tài nguyên R0 có 6 đơn vị, R1 có 4 đơn vị, R2 có 7 đơn vị l Trạng thái cung cấp tài nguyên tại thời điểm t0 R0 R1 R2 P0 0 0 0 P1 2 1 2 P2 0 0 2 P3 1 0 0 P4 6 0 2 Request R0 R1 R2 P0 0 1 1 P1 1 0 0 P2 3 0 2 P3 2 1 1 P4 0 2 2 Allocation"
